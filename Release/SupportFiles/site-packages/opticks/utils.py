from ctypes import *
from . import _opticks

__doc__ = "Misc utility functions"

try:
   __api = CDLL("SimpleApiLib")
   __api.setHandle(pythonapi.PyCObject_AsVoidPtr(py_object(_opticks.handle())))
   def genwrap(name, *args, **kargs):
       """Create a wrapper function for an API function.
          First arg is the name of the C function.
          Second arg is the return type (a ctypes type or None for void).
          Remaining args are the ctypes types for the function arguments.
          The 'errorCheck' keyword is a bool indicating if checks should be made
          for Simple API errors. These errors will be turned into a SimpleApiError exception.
          The default is to include error checking."""
       prototype = apply(CFUNCTYPE, args)
       func = prototype((name, __api))
       errorCheck = kargs.get('errorCheck', True)
       if errorCheck:
          import errors
          func.errcheck = errors.simpleErrorCheck
       return func
except:
    print "ERROR: The SimpleApiLib dynamic library could not be located.  The opticks module WILL NOT FUNCTION PROPERLY."
    def genwrap(name, *args, **kargs):
        def foo(*args, **kargs):
           raise RuntimeError("Must be run from within Opticks application")
        return foo

def getVersionInfo():
   "Return a tuple containing (Opticks version, Python PlugIn Version) as strings."
   over = stringBufferWrap(genwrap("getOpticksVersion", c_uint32, c_char_p, c_uint32))
   pver = _opticks.pythonVersion()
   return over,pver

def stringBufferWrap(func, *args, **kargs):
   """This function calls a 'c_uint32 func(c_char_p, c_uin32)' function and
      returns a python string. Pass in the python function (usually created with 'genwrap()').
      The minimal buffer size will be calculated before retrieving the string.
      The 'defaultBufferSize' keyword allows specification of an initial buffer size.
      This may result in a single function call instead of two. The default is to always calculate the minimum buffer size.
      If remaining args are present, they will be passed to 'func' before the buffer argument."""
   import errors
   defaultBufferSize = kargs.get('defaultBufferSize', 0)
   buf = create_string_buffer(defaultBufferSize)
   tmpargs = args + (buf,sizeof(buf))
   sz = apply(func, tmpargs)
   if sz > sizeof(buf):
      resize(buf, sz)
      tmpargs = args + (buf,sizeof(buf))
      apply(func, tmpargs)
   return string_at(buf)

def runTests(*args):
   if len(args) == 0: args = ["animation",
                              "data.aoi",
                              "data.raster",
                              "data.signature",
                              "data.types",
                              "dynamictypes",
                              "errors",
                              "execute",
                              "geo",
                              "metadata",
                              "view.layer",
                              "view.view"]
   args = map(lambda x: "opticks.%s" % x, args)
   import unittest,sys
   runner = unittest.TextTestRunner(sys.stdout, verbosity=2)
   suite = unittest.TestLoader().loadTestsFromNames(args)
   runner.run(suite)

def loadTestFile(name, batch=False):
   "Load a file from the current test data path."
   import os.path
   loadFile = genwrap("loadFile", c_uint32, c_char_p, c_int)
   getTestDataPath = genwrap("getTestDataPath", c_uint32, c_char_p, c_uint32)
   path = os.path.join(stringBufferWrap(getTestDataPath), name)
   rval = loadFile(path, int(batch))
   return rval
