from ctypes import *
from ..utils import genwrap,stringBufferWrap
from .. import data,errors
import view

__doc__ = "Functions and data types for dealing with layers."

# important IEEE-754 contant
NaN = 1e30000/1e30000 # overflow to cause Inf then divide to cause NaN

class Layer(Structure):
   _fields_ = [("handle", c_void_p)]
   __owns = False

   def __init__(self, name=None, typ=None, other=None):
      """Get a Layer by name.
         The name may be a session ID or a layer specification. See the Simple API
         module in the main developer documentation for more information on layer
         specifications. In summary, a layer specification is two parts, both optional:
         viewName|layerName where the default view is the active view and the default
         layer depends on a number of factors and is detailed in the main developer
         documentation.
         If typ is None, access any layer type. Otherwise, access only layers of the
         type specified.
         If other is specified the internal handle for that Layer will be copied to the new Layer.
         This is generally an internal usage.
         """
      if other is not None:
         assert(name is None and typ is None and isinstance(other, Layer))
         self.handle = other.handle
      else:
         self.handle = genwrap("getLayer", Layer, c_char_p, c_char_p)(name, typ).handle
      self.__owns = False

   def __del__(self):
      if self.__owns:
         genwrap("destroyLayer", None, Layer, errorCheck=False)(self)

   def destroy(self, val=True):
      """Mark this layer for destruction. When the layer object is garbage collected
         it will be removed from the view and destroyed. If val is False, destruction
         will be cancelled."""
      self.__owns = val

   @property
   def name(self):
      return stringBufferWrap(self._getLayerName, self)

   @property
   def type(self):
      return stringBufferWrap(self._getLayerType, self)

   @property
   def element(self):
      return self._getLayerElement(self)

   @property
   def view(self):
      return self._getLayerView(self)

   def getscale(self):
      x, y = c_double(0.0), c_double(0.0)
      self._getLayerScaleOffset(self, byref(x), byref(y), None, None)
      return x.value, y.value
   def setscale(self, (x, y)):
      self._setLayerScaleOffset(self, x, y, NaN, NaN)
   scale = property(getscale, setscale, doc="The Layer scale factor.")

   def getoffset(self):
      x, y = c_double(0.0), c_double(0.0)
      self._getLayerScaleOffset(self, None, None, byref(x), byref(y))
      return x.value, y.value
   def setoffset(self, (x, y)):
      self._setLayerScaleOffset(self, NaN, NaN, x, y)
   offset = property(getoffset, setoffset, doc="The Layer offset in pixels.")

   def getdisplayindex(self):
      return self._getLayerDisplayIndex(self)
   def setdisplayindex(self, index):
      self._setLayerDisplayIndex(self, index)
   displayindex = property(getdisplayindex, setdisplayindex, doc="Indicates the ordering in the layer stack.")

   @property
   def displayed(self):
      return bool(self._isLayerDisplayed(self))

   def show(self):
      self._setLayerDisplayed(self, 1);

   def hide(self):
      self._setLayerDisplayed(self, 0);

   def derive(self, name=None, typ=None):
      """Derive a new layer or copy an existing layer.
         If typ is None, a copy of the layer will be created.
         name is the new layer's name. If name is None, the new layer will have the same name as the original layer.
         Returns a new Layer."""
      if typ is None:
         typ = self.type
      return Layer(other=self._deriveLayer(self, name, typ))

   def convert(self, typ):
      "Convert to a new layer type."
      self.handle = self._convertLayer(self, typ).handle

   @property
   def active(self):
      return self._isLayerActive(self)

   def activate(self):
      self._activateLayer(self)

Layer._getLayerName = genwrap("getLayerName", c_uint32, Layer, c_char_p, c_uint32)
Layer._getLayerType = genwrap("getLayerType", c_uint32, Layer, c_char_p, c_uint32)
Layer._getLayerElement = genwrap("getLayerElement", data.types.DataElement, Layer)
Layer._getLayerView = genwrap("getLayerView", view.View, Layer)
Layer._getLayerScaleOffset = genwrap("getLayerScaleOffset", c_int, Layer, POINTER(c_double), POINTER(c_double), POINTER(c_double), POINTER(c_double))
Layer._setLayerScaleOffset = genwrap("setLayerScaleOffset", c_int, Layer, c_double, c_double, c_double, c_double)
Layer._isLayerDisplayed = genwrap("isLayerDisplayed", c_int, Layer)
Layer._setLayerDisplayed = genwrap("setLayerDisplayed", c_int, Layer, c_int)
Layer._getLayerDisplayIndex = genwrap("getLayerDisplayIndex", c_uint32, Layer)
Layer._setLayerDisplayIndex = genwrap("setLayerDisplayIndex", c_int, Layer, c_uint32)
Layer._deriveLayer = genwrap("deriveLayer", Layer, Layer, c_char_p, c_char_p)
Layer._convertLayer = genwrap("convertLayer", Layer, Layer, c_char_p)
Layer._isLayerActive = genwrap("isLayerActive", c_int, Layer)
Layer._activateLayer = genwrap("activateLayer", c_int, Layer)

class PassArea(c_uint32):
   "Opticks PassAreaEnum type."
   LOWER = 0
   UPPER = 1
   MIDDLE = 2
   OUTSIDE = 3

   def __repr__(self):
      strname = "Unknown"
      if self.value == self.LOWER: strname = "Below 1st threshold"
      elif self.value == self.UPPER: strname = "Above 1st threshold"
      elif self.value == self.MIDDLE: strname = "Between 1st and 2nd thresholds"
      elif self.value == self.OUTSIDE: strname = "Outside 1st and 2nd thresholds"
      return "<PassArea: %s>" % strname

class RegionUnits(c_uint32):
   "Opticks RegionUnitsEnum type."
   RAW_VALUE = 0
   PERCENTAGE = 1
   PERCENTILE = 2
   STD_DEV = 3

   def __repr__(self):
      strname = "Unknown"
      if self.value == self.RAW_VALUE: strname = "Raw value"
      elif self.value == self.PERCENTAGE: strname = "Percentage"
      elif self.value == self.PERCENTILE: strname = "Percentile"
      elif self.value == self.STD_DEV: strname = "Standard deviation"
      return "<RegionUnits: %s>" % strname

class StretchType(c_uint32):
   "Opticks StretchTypeEnum type."
   LINEAR = 0
   LOGARITHMIC = 1
   EXPONENTIAL = 2
   EQUALIZE = 3

   def __repr__(self):
      strname = "Unknown"
      if self.value == self.LINEAR: strname = "Linear"
      elif self.value == self.LOGARITHMIC: strname = "Logarithmic"
      elif self.value == self.EXPONENTIAL: strname = "Exponential"
      elif self.value == self.EQUALIZE: strname = "Histogram Equalization"
      return "<StretchType: %s>" % strname

class Color(object):
   "Opticks Color type"

   def __init__(self, value=None, red=0, green=0, blue=0, alpha=255):
      if value is None:
         self.red, self.green, self.blue, self.alpha = red, green, blue, alpha
      elif isinstance(value, Color):
         # copy constructor
         self.red, self.green, self.blue, self.alpha = value.red, value.green, value.blue, value.alpha
      elif isinstance(value, str):
         if len(value) == 9 and value[0] == '#':
            from string import atoi
            self.red, self.green, self.blue, self.alpha = atoi(value[1:3], 16), atoi(value[3:5], 16), atoi(value[5:7], 16), atoi(value[7:9], 16)
         else:
            raise TypeError("Color initialation must be an encoded int, '#RRGGBBAA', '(red, green, blue)', '(red, green, blue, alpha)', or 'red=0, green=0, blue=0, alpha=255'")
      elif isinstance(value, tuple) and (len(value) == 3 or len(value) == 4):
         if len(value) == 3: value = value + (alpha, )
         self.red, self.green, self.blue, self.alpha = value
      elif isinstance(value, int) or isinstance(value, long):
         self.red, self.green, self.blue, self.alpha = (value >> 24) & 0xff, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff
      else:
         raise TypeError("Color initialation must be an encoded int, '#RRGGBBAA', '(red, green, blue)', '(red, green, blue, alpha)', or 'red=0, green=0, blue=0, alpha=255'")

   def __eq__(self, other):
      return self.red == other.red and self.green == other.green and self.blue == other.blue and self.alpha == other.alpha

   @property
   def value(self):
      return (self.red << 24) | (self.green << 16) | (self.blue << 8) | self.alpha

   def __repr__(self):
      return '#%02X%02X%02X%02X' % (self.red, self.green, self.blue, self.alpha)

class RasterChannel(c_uint32):
   "Opticks RasterChannelEnum type."
   GRAY = 0
   RED = 1
   GREEN = 2
   BLUE = 3

   def __repr__(self):
      strname = "Unknown"
      if self.value == self.GRAY: strname = "gray/colormap/indexed"
      elif self.value == self.RED: strname = "red"
      elif self.value == self.GREEN: strname = "green"
      elif self.value == self.BLUE: strname = "blue"
      return "<RasterChannel: %s>" % strname

class ComplexComponent(c_uint32):
   "Opticks ComplexComponentEnum type."
   MAGNITUDE = 0
   PHASE = 1
   INPHASE = 2
   QUADRATURE = 3

   def __repr__(self):
      strname = "Unknown"
      if self.value == self.MAGNITUDE: strname = "magnitude"
      elif self.value == self.PHASE: strname = "phase"
      elif self.value == self.INPHASE: strname = "in-phase"
      elif self.value == self.QUADRATURE: strname = "quadrature"
      return "<ComplexComponent: %s>" % strname

class ThresholdLayer(Layer):
   "A Threshold layer."

   class Info(Structure):
      _fields_ = [('firstThreshold', c_double),
                  ('secondThreshold', c_double),
                  ('passArea', PassArea),
                  ('regionUnits', RegionUnits)]

      def __repr__(self):
         return "<ThresholdInfo: %f - %f %r %r>" % (self.firstThreshold, self.secondThreshold, self.passArea, self.regionUnits)

   def __init__(self, name=None, other=None):
      """Get a Threshold Layer by name.
         See Layer documentation for information on values for name.
         If other is specified the internal handle for that Layer will be copied to the new Layer.
         The typ value for the Layer contructor will be 'ThresholdLayer'.
         Other may be a Layer object which will be cast to a ThresholdLayer.
         """
      if other is not None:
         if not isinstance(other, Layer) or other.type != 'ThresholdLayer':
            raise TypeError("Layer is not a ThresholdLayer.")
         Layer.__init__(self, other=other)
      else:
         Layer.__init__(self, name=name, typ='ThresholdLayer')

   def getinfo(self):
      info = ThresholdLayer.Info()
      genwrap('getThresholdLayerInfo', c_int, Layer, POINTER(ThresholdLayer.Info))(self, byref(info))
      return info
   def setinfo(self, info):
      assert(isinstance(info, ThresholdLayer.Info))
      genwrap('setThresholdLayerInfo', c_int, Layer, POINTER(ThresholdLayer.Info))(self, byref(info))
   info = property(getinfo, setinfo, doc="Threshold parameters.")

   def getthresholds(self):
      info = self.info
      return info.firstThreshold, info.secondThreshold
   def setthresholds(self, (first, second)):
      info = self.info
      info.firstThreshold, info.secondThreshold = first, second
      self.info = info
   thresholds = property(getthresholds, setthresholds, doc="First and second thresholds")

   def getpassarea(self):
      return self.info.passArea
   def setpassarea(self, value):
      info = self.info
      info.passArea = value
      self.info = info
   passarea = property(getpassarea, setpassarea, doc="Pass area enum")

   def getregionunits(self):
      return self.info.regionUnits
   def setregionunits(self, value):
      info = self.info
      info.regionUnits = value
      self.info = info
   regionunits = property(getregionunits, setregionunits, doc="Region units enum")

class PseudocolorClass(object):
   "A pseudocolor class."

   _getPseudocolorClassName = genwrap("getPseudocolorClassName", c_uint32, Layer, c_int32, c_char_p, c_uint32)
   _getPseudocolorClassValue = genwrap("getPseudocolorClassValue", c_int32, Layer, c_int32)
   _getPseudocolorClassColor = genwrap("getPseudocolorClassColor", c_uint32, Layer, c_int32)
   _isPseudocolorClassDisplayed = genwrap("isPseudocolorClassDisplayed", c_int, Layer, c_int32)
   _setPseudocolorClassName = genwrap("setPseudocolorClassName", c_int, Layer, c_int32, c_char_p)
   _setPseudocolorClassValue = genwrap("setPseudocolorClassValue", c_int, Layer, c_int32, c_int32)
   _setPseudocolorClassColor = genwrap("setPseudocolorClassColor", c_int, Layer, c_int32, c_uint32)
   _setPseudocolorClassDisplayed = genwrap("setPseudocolorClassDisplayed", c_int, Layer, c_int32, c_int)

   def __init__(self, layer, id):
      self.__layer, self.__id = layer, id

   def __repr__(self):
      if self.displayed:
         return "<PseudocolorClass '%s' %i displayed as %s>" % (self.name, self.value, self.color)
      return "<PseudocolorClass '%s' %i hidden with color %s>" % (self.name, self.value, self.color)

   def getname(self):
      return stringBufferWrap(self._getPseudocolorClassName, self.__layer, self.__id)
   def setname(self, name):
      self._setPseudocolorClassName(self.__layer, self.__id, name)
   name = property(getname, setname, doc="The pseudocolor class name.")

   def getvalue(self):
      return self._getPseudocolorClassValue(self.__layer, self.__id)
   def setvalue(self, value):
      self._setPseudocolorClassValue(self.__layer, self.__id, value)
   value = property(getvalue, setvalue, doc="The pseudocolor class value.")

   def getcolor(self):
      return Color(self._getPseudocolorClassColor(self.__layer, self.__id))
   def setcolor(self, color):
      if not isinstance(color, Color):
         color = PseudocolorClass.Color(color)
      self._setPseudocolorClassColor(self.__layer, self.__id, color.value)
   color = property(getcolor, setcolor, doc="The pseudocolor class color.")

   def getdisplayed(self):
      return bool(self._isPseudocolorClassDisplayed(self.__layer, self.__id))
   def setdisplayed(self, value):
      self._setPseudocolorClassDisplayed(self.__layer, self.__id, value)
   displayed = property(getdisplayed, setdisplayed, doc="Is the pseudocolor class displayed?")

class PseudocolorLayer(Layer):
   "A Pseudocolor layer."

   _getPseudocolorClassCount = genwrap("getPseudocolorClassCount", c_uint32, Layer)
   _getPseudocolorClassId = genwrap("getPseudocolorClassId", c_int32, Layer, c_uint32)
   _addPseudocolorClass = genwrap("addPseudocolorClass", c_int32, Layer, c_char_p, POINTER(c_int32), POINTER(c_uint32), POINTER(c_int))

   def __init__(self, name=None, other=None):
      """Get a Pseudocolor Layer by name.
         See Layer documentation for information on values for name.
         If other is specified the internal handle for that Layer will be copied to the new Layer.
         The typ value for the Layer contructor will be 'PseudocolorLayer'.
         Other may be a Layer object which will be cast to a PseudocolorLayer.
         """
      if other is not None:
         if not isinstance(other, Layer) or other.type != 'PseudocolorLayer':
            raise TypeError("Layer is not a PseudocolorLayer.")
         Layer.__init__(self, other=other)
      else:
         Layer.__init__(self, name=name, typ='PseudocolorLayer')

   def __len__(self):
      return self._getPseudocolorClassCount(self)

   def __getitem__(self, index):
      return PseudocolorClass(self, self._getPseudocolorClassId(self, index))

   def __iter__(self):
      def doiter(layer, cnt):
         for index in xrange(cnt):
            yield layer[index]
      return doiter(self, len(self))

   def addClass(self, name=None, value=None, color=None, displayed=None):
      """Add a new class.
         If name, value, color, and displayed are not None, the class is initialized to those values.
         If any of name, value, color, or displayed is None, an uninitialized class is created."""
      if name is not None and value is not None and color is not None and displayed is not None:
         if not isinstance(value, c_int32): value = c_int32(value)
         if not isinstance(color, Color): color = Color(color)
         color = c_uint32(color.value)
         if displayed: displayed = c_int(1)
         else: displayed = c_int(0)
         return PseudocolorClass(self, self._addPseudocolorClass(self, name, byref(value), byref(color), byref(displayed)))
      return PseudocolorClass(self, self._addPseudocolorClass(self, None, None, None, None))

class RasterLayerStretchInfo(Structure):
   _fields_ = [('lowerStretch', c_double),
               ('upperStretch', c_double),
               ('stretchType', StretchType),
               ('stretchUnits', RegionUnits)]

   def __repr__(self):
      return "<RasterLayerStretchInfo: %f-%f, type %s, units %s>" % (self.lowerStretch, self.upperStretch, self.stretchType, self.stretchUnits)

class RasterStatistics(Structure):
   _fields_ = [('min', c_double),
               ('max', c_double),
               ('mean', c_double),
               ('stddev', c_double),
               ('_histogramCenters', POINTER(c_double)),
               ('_histogramCounts', POINTER(c_uint)),
               ('_percentiles', POINTER(c_double)),
               ('resolution', c_uint32)]
   @property
   def histogramCenters(self):
      if hasattr(self, "_storedCenters"):
         return self._storedCenters
      self._storedCenters = self._histogramCenters[:256]
      return self._storedCenters

   @property
   def histogramCounts(self):
      if hasattr(self, "_storedCounts"):
         return self._storedCounts
      self._storedCounts = self._histogramCounts[:256]
      return self._storedCounts

   @property
   def percentiles(self):
      if hasattr(self, "_storedPercentiles"):
         return self._storedPercentiles
      self._storedPercentiles = self._percentiles[:1001]
      return self._storedPercentiles

   def __repr__(self):
      return "<RasterStatistics: %i resolution>" % self.resolution

class RasterLayer(Layer):
   "A Raster layer."

   _getRasterLayerStretchInfo = genwrap("getRasterLayerStretchInfo", c_int, Layer, RasterChannel, POINTER(RasterLayerStretchInfo))
   _setRasterLayerStretchInfo = genwrap("setRasterLayerStretchInfo", c_int, Layer, RasterChannel, POINTER(RasterLayerStretchInfo))
   _getRasterLayerComplexComponent = genwrap("getRasterLayerComplexComponent", ComplexComponent, Layer)
   _setRasterLayerComplexComponent = genwrap("setRasterLayerComplexComponent", c_int, Layer, ComplexComponent)
   _getRasterLayerColormapName = genwrap("getRasterLayerColormapName", c_uint32, Layer, c_char_p, c_uint32)
   _setRasterLayerColormapName = genwrap("setRasterLayerColormapName", c_int, Layer, c_char_p)
   _getRasterLayerColormapValues = genwrap("getRasterLayerColormapValues", c_int, Layer, POINTER(c_uint32))
   _setRasterLayerColormapValues = genwrap("setRasterLayerColormapValues", c_int, Layer, c_char_p, POINTER(c_uint32))
   _getRasterLayerGpuEnabled = genwrap("getRasterLayerGpuEnabled", c_int, Layer);
   _setRasterLayerGpuEnabled = genwrap("setRasterLayerGpuEnabled", c_int, Layer, c_int);
   _getRasterLayerFilterCount = genwrap("getRasterLayerFilterCount", c_uint32, Layer, c_int)
   _getRasterLayerFilterName = genwrap("getRasterLayerFilterName", c_uint32, Layer, c_uint32, c_int, c_char_p, c_uint32)
   _setRasterLayerFilters = genwrap("setRasterLayerFilters", c_int, Layer, c_uint32, POINTER(c_char_p))
   _resetRasterLayerFilter = genwrap("resetRasterLayerFilter", c_int, Layer, c_char_p)
   _setRasterLayerFilterFrozen = genwrap("setRasterLayerFilterFrozen", c_int, Layer, c_char_p, c_int)
   _isRasterLayerRgbDisplayed = genwrap("isRasterLayerRgbDisplayed", c_int, Layer);
   _setRasterLayerRgbDisplayed = genwrap("setRasterLayerRgbDisplayed", c_int, Layer, c_int);
   _getRasterLayerDisplayedBand = genwrap("getRasterLayerDisplayedBand", c_uint32, Layer, RasterChannel, POINTER(c_void_p));
   _setRasterLayerDisplayedBand = genwrap("setRasterLayerDisplayedBand", c_int, Layer, RasterChannel, c_uint32, data.types.DataElement);
   _getRasterLayerStatistics = genwrap("getRasterLayerStatistics", c_int, Layer, RasterChannel, ComplexComponent, POINTER(RasterStatistics));

   def __init__(self, name=None, other=None):
      """Get a Raster Layer by name.
         See Layer documentation for information on values for name.
         If other is specified the internal handle for that Layer will be copied to the new Layer.
         The typ value for the Layer contructor will be 'RasterLayer'.
         Other may be a Layer object which will be cast to a RasterLayer.
         """
      if other is not None:
         if not isinstance(other, Layer) or other.type != 'RasterLayer':
            raise TypeError("Layer is not a RasterLayer.")
         Layer.__init__(self, other=other)
      else:
         Layer.__init__(self, name=name, typ='RasterLayer')

   def getstretch(self, channel):
      nfo = RasterLayerStretchInfo()
      self._getRasterLayerStretchInfo(self, channel, byref(nfo))
      return nfo

   def setstretch(self, channel, nfo):
      self._setRasterLayerStretchInfo(self, channel, byref(nfo))

   def getcomplexcomponent(self):
      return self._getRasterLayerComplexComponent(self)
   def setcomplexcomponent(self, value):
      self._setRasterLayerComplexComponent(self, value)
   complexcomponent = property(getcomplexcomponent, setcomplexcomponent, doc="Complex component displayed.")

   def getcolormapname(self):
      return stringBufferWrap(self._getRasterLayerColormapName, self)
   def setcolormapname(self, name):
      self._setRasterLayerColormapName(self, name)
   colormapname = property(getcolormapname, setcolormapname, doc="Internal name or filename of the colormap.")

   def getcolormap(self):
      cmap = (c_uint32 * 256)()
      self._getRasterLayerColormapValues(self, cmap)
      return map(Color, cmap)
   def setcolormap(self, value, name=None):
      "Set a new colormap. Value is a sequence of 256 colors. name is an optional name to associate with the colormap."
      if len(value) != 256:
         raise ValueError("Colormap must be a sequence of 256 colors.")
      cmap = (c_uint32 * 256)()
      cmap[:] = map(lambda x: Color(x).value, value)
      self._setRasterLayerColormapValues(self, name, cmap)
   colormap = property(getcolormap, setcolormap, doc="Colormap table which is applied when in grayscale/colormap/indexed display mode.")

   def getgpuenabled(self):
      return bool(self._getRasterLayerGpuEnabled(self))
   def setgpuenabled(self, value):
      self._setRasterLayerGpuEnabled(self, value)
   gpuenabled = property(getgpuenabled, setgpuenabled, doc="Is the GPU rendering this layer?")

   def getrgbdisplayed(self):
      return bool(self._isRasterLayerRgbDisplayed(self))
   def setrgbdisplayed(self, value):
      self._setRasterLayerRgbDisplayed(self, value)
   rgbdisplayed = property(getrgbdisplayed, setrgbdisplayed)

   def getdisplayedband(self, channel):
      rval = c_void_p(0)      
      bandnum = self._getRasterLayerDisplayedBand(self, channel, byref(rval))
      if not rval:
         re = None
      else:
         de = data.types.DataElement(subtypeAsVoid=rval, typ="RasterElement")
         re = data.raster.RasterElement(element=de)
      return (bandnum, re)

   def setdisplayedband(self, channel, band, element=None):
      if element is None:
         (num, re) = self.getdisplayedband(channel)
         if re is not None:
            self._setRasterLayerDisplayedBand(self, channel, band, re)
      else:
         self._setRasterLayerDisplayedBand(self, channel, band, element)

   def setrgbbands(self, red=None, green=None, blue=None):
      self.setrgbdisplayed(True)
      if red is not None:
         self.setdisplayedband(RasterChannel.RED, red, self.element)
      if green is not None:
         self.setdisplayedband(RasterChannel.GREEN, green, self.element)
      if blue is not None:
         self.setdisplayedband(RasterChannel.BLUE, blue, self.element)

   def setgrayband(self, gray):
      self.setrgbdisplayed(False)
      self.setdisplayedband(RasterChannel.GRAY, gray, self.element)

   def getstatistics(self, channel, component=ComplexComponent.MAGNITUDE):
      stat = RasterStatistics()
      self._getRasterLayerStatistics(self, channel, component, stat)
      return stat
      
   @property
   def filters(self):
      rval = []
      for index in range(self._getRasterLayerFilterCount(self, 0)):
         rval.append(stringBufferWrap(self._getRasterLayerFilterName, self, index, 0))
      return rval

   def getenabledfilters(self):
      rval = []
      for index in range(self._getRasterLayerFilterCount(self, 1)):
         rval.append(stringBufferWrap(self._getRasterLayerFilterName, self, index, 1))
      return rval
   def setenabledfilters(self, value):
      value = list(value)
      count = len(value)
      filters = (c_char_p * count)()
      filters[:] = value
      self._setRasterLayerFilters(self, count, filters)
   enabledfilters = property(getenabledfilters, setenabledfilters, doc="Currently enabled GPU filters.")

   def resetFilter(self, filter):
      "Reset a feedback filter. If filter is not a feedback filter, do nothing."
      self._resetRasterLayerFilter(self, filter)

   def freezeFilter(self, filter, freeze=True):
      "Freeze of unfreeze a feedback filter. If filter is not a feedback filter, do nothing."
      self._setRasterLayerFilterFrozen(self, filter, int(freeze))

####
# Test suite
####
import unittest
from ..utils import loadTestFile
from .. import errors
class LayerTestCase(unittest.TestCase):
   def setUp(self):
      self.failUnless(loadTestFile("ir_bushehr_06jun02_ps.tif"))
   
   def tearDown(self):
      import view
      view.View().destroy()

   def testLayerAccess(self):
      rl = Layer(typ="RasterLayer")
      self.failUnless(rl)
      self.failUnless(rl.name.endswith("ir_bushehr_06jun02_ps.tif"))
      gl = Layer()
      self.failUnless(gl)
      self.failUnlessEqual(gl.name, "Corner Coordinates")
      rl = Layer("|ir_bushehr_06jun02_ps.tif")
      self.failUnless(rl)
      self.failUnless(rl.name.endswith("ir_bushehr_06jun02_ps.tif"))
      rl = Layer("ir_bushehr_06jun02_ps.tif|ir_bushehr_06jun02_ps.tif")
      self.failUnless(rl)
      self.failUnless(rl.name.endswith("ir_bushehr_06jun02_ps.tif"))
      self.failUnlessRaises(errors.SimpleApiError, Layer, "ir_bushehr_06jun02_ps.tif|ir_bushehr_06jun02_ps.tif", "BadType")
      rl = Layer("ir_bushehr_06jun02_ps.tif|ir_bushehr_06jun02_ps.tif", "RasterLayer")
      self.failUnless(rl)
      self.failUnless(rl.name.endswith("ir_bushehr_06jun02_ps.tif"))
      gl = Layer("ir_bushehr_06jun02_ps.tif|Corner Coordinates", "GcpLayer")
      self.failUnless(gl)
      self.failUnlessEqual(gl.name, "Corner Coordinates")
      self.failUnlessEqual(gl.element.name, "Corner Coordinates")
      self.failUnless(gl.view)

   def testScaleOffset(self):
      gl = Layer("|Corner Coordinates")
      self.failUnlessEqual(gl.scale, (1.0, 1.0))
      self.failUnlessEqual(gl.offset, (0.0, 0.0))
      gl.scale = 0.5,0.25
      gl.offset = 100,200
      self.failUnlessEqual(gl.scale, (0.5, 0.25))
      self.failUnlessEqual(gl.offset, (100.0, 200.0))

   def testDisplayed(self):
      gl = Layer("|Corner Coordinates")
      self.failUnless(gl.displayed)
      gl.hide()
      gl.hide() # ensure an exception is not thrown
      self.failIf(gl.displayed)
      gl.show()
      self.failUnless(gl.displayed)

   def testDisplayIndex(self):
      gl = Layer("|Corner Coordinates")
      rl = Layer(typ="RasterLayer")
      self.failUnlessEqual(gl.displayindex, 0)
      self.failUnlessEqual(rl.displayindex, 1)
      gl.displayindex = 1
      self.failUnlessEqual(gl.displayindex, 1)
      self.failUnlessEqual(rl.displayindex, 0)

   def testConversion(self):
      rl = Layer(typ="RasterLayer")
      rl.derive(typ="ThresholdLayer")
      tl = Layer(typ="ThresholdLayer")
      self.failUnlessEqual(tl.type, "ThresholdLayer")
      tl.convert("PseudocolorLayer")
      self.failUnlessEqual(tl.type, "PseudocolorLayer")

   def testThresholdLayer(self):
      rl = Layer(typ="RasterLayer")
      rl.derive(typ="ThresholdLayer")
      tl = Layer(typ="ThresholdLayer")
      tl.passarea = PassArea.OUTSIDE
      self.failUnlessEqual(tl.passarea, PassArea.OUTSIDE)
      tl.thresholds = 10, 15
      self.failUnlessEqual(tl.thresholds, (10.0, 15.0))
      tl.regionunits = RegionUnits.STD_DEV
      self.failUnlessEqual(tl.regionunits, RegionUnits.STD_DEV)

   def testColormap(self):
      rl = RasterLayer()
      self.failUnlessEqual(rl.colormapname, "Default Grayscale")
      rl.colormapname='StopLight'
      self.failUnlessEqual(rl.colormapname, "Stop Light")
      rl.colormapname='RedTemp'
      self.failUnlessEqual(rl.colormapname, "RedTemp")
      rl.colormapname='WeatherMap.clu'
      self.failUnlessEqual(rl.colormapname, "WeatherMap")
      rl.colormapname='Hot Iron'
      self.failUnlessEqual(rl.colormapname, "Hot Iron")
      self.failUnlessRaises(errors.SimpleApiError, rl.setcolormapname, "foo")
      m = zip(xrange(256), xrange(256), (0,) * 256)
      rl.setcolormap(m, "Yellow")
      self.failUnlessEqual(map(Color, m), rl.colormap)
      self.failUnlessEqual(rl.colormapname, "Yellow")
      m.reverse()
      rl.colormap = m
      self.failUnlessEqual(map(Color, m), rl.colormap)
      self.failUnlessEqual(rl.colormapname, "")

   def testStatistics(self):
      rl = RasterLayer()
      stat = rl.getstatistics(RasterChannel.GRAY)
      self.failUnlessAlmostEqual(stat.min, 8.0)
      self.failUnlessAlmostEqual(stat.max, 2047.0)
      self.failUnlessAlmostEqual(stat.mean, 1127.29884817)
      self.failUnlessAlmostEqual(stat.stddev, 428.13824196)
      self.failUnlessEqual(stat.resolution, 1)
      self.failUnlessEqual(len(stat.histogramCenters), 256)
      self.failUnlessEqual(len(stat.histogramCounts), 256)
      self.failUnlessEqual(len(stat.percentiles), 1001)

   def testDisplayMode(self):
      rl = RasterLayer()
      rl.rgbdisplayed = True
      self.failUnlessEqual(rl.rgbdisplayed, True)
      rl.rgbdisplayed = False
      self.failUnlessEqual(rl.rgbdisplayed, False)

   def testDisplayBand(self):
      rl = RasterLayer()
      rl.setdisplayedband(RasterChannel.GRAY, 1) 
      (bandnum, re) = rl.getdisplayedband(RasterChannel.GRAY)
      self.failUnlessEqual(bandnum, 1)
      self.failUnlessEqual(re.name, rl.element.name)
      self.failUnlessEqual(re.handle, rl.element.handle)

      rl.setdisplayedband(RasterChannel.GRAY, 1000) #bandnum intentionally out-of-range
      (bandnum, re) = rl.getdisplayedband(RasterChannel.GRAY)
      self.failUnlessEqual(bandnum, 0)
      self.failUnlessEqual(re, None)

      rl.setdisplayedband(RasterChannel.GRAY, 1, rl.element)
      (bandnum, re) = rl.getdisplayedband(RasterChannel.GRAY)
      self.failUnlessEqual(bandnum, 1)
      self.failUnlessEqual(re.name, rl.element.name)
      self.failUnlessEqual(re.handle, rl.element.handle)

      rl.setrgbbands(red=0, green=1, blue=2)
      (rednum, red) = rl.getdisplayedband(RasterChannel.RED)
      (greennum, green) = rl.getdisplayedband(RasterChannel.GREEN)
      (bluenum, blue) = rl.getdisplayedband(RasterChannel.BLUE)
      self.failUnlessEqual(rl.rgbdisplayed, True)
      self.failUnlessEqual(rednum, 0)
      self.failUnlessEqual(greennum, 1)
      self.failUnlessEqual(bluenum, 2)
      self.failUnlessEqual(red.handle, rl.element.handle)
      self.failUnlessEqual(green.handle, rl.element.handle)
      self.failUnlessEqual(blue.handle, rl.element.handle)

      rl.setgrayband(2)
      (graynum, gray) = rl.getdisplayedband(RasterChannel.GRAY)
      self.failUnlessEqual(rl.rgbdisplayed, False)
      self.failUnlessEqual(graynum, 2)
      self.failUnlessEqual(gray.handle, rl.element.handle)
     

