"""Welcome to the Opticks Python scripting engine.

Please note that certain functionality is not available in the interpreter
window, most notably the raw_input() function. This prevents the
proper functioning of help(), license(),
and similar functions although help(object) will work.

"""
# Initialize the connection to Opticks.
import _opticks
import sys
import ctypes

__copyright__ = """The information in this file is
 Copyright(c) 2009 Ball Aerospace & Technologies Corporation
 and is subject to the terms and conditions of the
 GNU Lesser General Public License Version 2.1
 The license text is available from
 http://www.gnu.org/licenses/lgpl.html"""

class OpticksError(Exception):
    pass

class SimpleApiError(OpticksError):
    """Python exception wrapper for a Simple API error.
    The 'code' member contains the numeric error code.
    The 'message' member contains the user readable error message.
    The 'result' member contains the return result from the original
    function call.

    """

    SIMPLE_NO_ERROR = 0
    SIMPLE_WRONG_TYPE = 1
    SIMPLE_NOT_FOUND = 2
    SIMPLE_BAD_PARAMS = 3
    SIMPLE_BUFFER_SIZE = 4
    SIMPLE_NO_MEM = 5
    SIMPLE_EXISTS = 6
    SIMPLE_WRONG_VIEW_TYPE = 7
    SIMPLE_OTHER_FAILURE = -1

    def __init__(self, code, result=None):
        OpticksError.__init__(self, code, self._getErrorString(code))
        self.code = code
        self.message = self._getErrorString(code)
        self.result = result

def _simple_error_check(result, func, args):
    """This errcheck function queries the last error state
    and raises an exception if an error occured

    """
    #pylint: disable=W0212,W0613
    err = SimpleApiError._get_last_error()
    if err != SimpleApiError.SIMPLE_NO_ERROR:
        raise SimpleApiError(err, result)
    return args


try:
    if sys.platform == 'linux2':
        __API = ctypes.CDLL("libSimpleApiLib.so")
    else:
        __API = ctypes.CDLL("SimpleApiLib")
    pyobj = ctypes.py_object(_opticks.handle())
    __API.setHandle(ctypes.pythonapi.PyCObject_AsVoidPtr(pyobj))
    def _genwrap(name, *args, **kargs):
        """Create a wrapper function for an API function.
        First arg is the name of the C function.
        Second arg is the return type (a ctypes type or None for void).
        Remaining args are the ctypes types for the function arguments.
        The 'errorCheck' keyword is a bool indicating if checks should be
        made for Simple API errors. These errors will be turned into
        a SimpleApiError exception. The default is to include
        error checking.

        """
        prototype = apply(ctypes.CFUNCTYPE, args)
        func = prototype((name, __API))
        error_check = kargs.get('errorCheck', True)
        if error_check:
            func.errcheck = _simple_error_check
        return func
except EnvironmentError:
    print "ERROR: The SimpleApiLib dynamic library could not be located. "\
          "The opticks module WILL NOT FUNCTION PROPERLY."
    def _genwrap(name, *args, **kargs):
        #pylint: disable=W0613
        def dummy_placeholder(*args, **kargs):
            raise RuntimeError("Must be run from within Opticks application")
        return dummy_placeholder

def version_info():
    """Return a tuple containing (Opticks version, Python PlugIn Version)
    as strings.

    """
    tempf = _genwrap("getOpticksVersion", ctypes.c_uint32,
                     ctypes.c_char_p, ctypes.c_uint32)
    over = _stringbuffer_wrap(tempf)
    pver = _opticks.pythonVersion()
    return over, pver

def _stringbuffer_wrap(func, *args, **kargs):
    """This function calls a
    'ctypes.c_uint32 func(ctypes.c_char_p, ctypes.c_uin32)' function and
    returns a python string. Pass in the python function
    (usually created with '_genwrap()'). The minimal buffer size will
    be calculated before retrieving the string. The 'defaultBufferSize'
    keyword allows specification of an initial buffer size. This may
    result in a single function call instead of two. The default is to
    always calculate the minimum buffer size. If remaining args are
    present, they will be passed to 'func' before the buffer argument.

    """
    default_buffersize = kargs.get('defaultBufferSize', 0)
    buf = ctypes.create_string_buffer(default_buffersize)
    tmpargs = args + (buf, ctypes.sizeof(buf))
    size = apply(func, tmpargs)
    if size > ctypes.sizeof(buf):
        ctypes.resize(buf, size)
        tmpargs = args + (buf, ctypes.sizeof(buf))
        apply(func, tmpargs)
    return ctypes.string_at(buf)

SimpleApiError._get_last_error = \
    _genwrap("getLastError", ctypes.c_int, errorCheck=False)
SimpleApiError._set_last_error = \
    _genwrap("setLastError", None, ctypes.c_int, errorCheck=False)
SimpleApiError._getErrorString = \
    _genwrap("getErrorString", ctypes.c_char_p, ctypes.c_int, errorCheck=False)

def _void_p_to_native(typename, value):
    #pylint: disable=W0212
    typ = None
    isvector = False
    if typename.startswith("vector<"):
        typename = typename[7:-1]
        isvector = True
    if typename == "char":
        typ = ctypes.c_byte
    elif typename == "unsigned char":
        typ = ctypes.c_ubyte
    elif typename == "short":
        typ = ctypes.c_short
    elif typename == "unsigned short":
        typ = ctypes.c_ushort
    elif typename == "int":
        typ = ctypes.c_int
    elif typename == "unsigned int":
        typ = ctypes.c_uint
    elif typename == "long":
        typ = ctypes.c_long
    elif typename == "unsigned long":
        typ = ctypes.c_ulong
    elif typename == "Int64" or typename == "int64":
        typ = ctypes.c_longlong
    elif typename == "UInt64" or typename == "uint64":
        typ = ctypes.c_ulonglong
    elif typename == "float":
        typ = ctypes.c_float
    elif typename == "double":
        typ = ctypes.c_double
    else:
        return ctypes.cast(value, ctypes.c_void_p)
    if isvector:
        rval = ctypes.c_void_p(0)
        size = DataVariant._vectorToArray(value, "vector<%s>" % typename,
                                          ctypes.byref(rval))
        size /= ctypes.sizeof(typ)
        typ = typ * size
        return ctypes.cast(rval, ctypes.POINTER(typ)).contents
    return ctypes.cast(value, ctypes.POINTER(typ)).contents.value

def _prep_for_set(value, typ):
    #pylint: disable=W0212
    retval = None
    if isinstance(value, (DataVariant, ctypes.c_void_p)):
        retval = value
    elif isinstance(value, DataElement):
        rval = value.cast_data_element(typ)
        if rval != 0:
            retval = ctypes.c_void_p(rval)
    elif typ == "char":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_byte(value)),
                             ctypes.c_void_p)
    elif typ == "short":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_short(value)),
                             ctypes.c_void_p)
    elif typ == "int":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_int(value)),
                             ctypes.c_void_p)
    elif typ == "long":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_long(value)),
                             ctypes.c_void_p)
    elif typ == "Int64":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_longlong(value)),
                             ctypes.c_void_p)
    elif typ == "unsigned char":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_ubyte(value)),
                             ctypes.c_void_p)
    elif typ == "unsigned short":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_ushort(value)),
                             ctypes.c_void_p)
    elif typ == "unsigned int":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_uint(value)),
                             ctypes.c_void_p)
    elif typ == "unsigned long":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_ulong(value)),
                             ctypes.c_void_p)
    elif typ == "UInt64":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_ulonglong(value)),
                             ctypes.c_void_p)
    elif typ == "float":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_float(value)),
                             ctypes.c_void_p)
    elif typ == "double":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_double(value)),
                             ctypes.c_void_p)
    else: # try an XML string conversion
        retval = DataVariant._createDataVariantFromString(typ, str(value), 1)
    return retval

class DataElement(ctypes.Structure, object):
    "An Opticks data element handle."
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, name, wrapper=None):
        """Get a DataElement.
        If name is passed, the DataElement with that name is accessed.

        """
        ctypes.Structure.__init__(self)
        if wrapper is None:
            self.handle = self._getDataElement(name, None, int(0)).handle
        else:
            self.handle = wrapper
        self.__owns = False

    @classmethod
    def cast(cls, subtype_as_void, typ):
        tempf = _genwrap("castToDataElement", DataElement,
                         ctypes.c_void_p, ctypes.c_char_p)
        handle = tempf(subtype_as_void, typ).handle
        newe = DataElement(None, wrapper = handle)
        return newe

    def __del__(self):
        if self.__owns:
            tempf = _genwrap("destroyDataElement", None, DataElement,
                             errorCheck=False)
            tempf(self)

    def destroy(self, val=True):
        self.__owns = val

    def leafclass(self):
        elem = self
        typ = self.type
        if typ == "AoiElement":
            elem = Aoi(None, element=self)
        elif typ == "RasterElement":
            elem = RasterElement(None, element=self)
        elif typ == "Signature":
            elem = Signature(None, element=self)
        elif typ == "SignatureSet":
            elem = SignatureSet(None, element=self)
        elif typ == "GcpList":
            elem = GcpList(None, element=self)
        return elem

    @property
    def name(self):
        return _stringbuffer_wrap(self._getDataElementName, self)

    @property
    def type(self):
        return _stringbuffer_wrap(self._getDataElementType, self)

    @property
    def filename(self):
        return _stringbuffer_wrap(self._getDataElementFilename, self)

    @property
    def metadata(self):
        handle = self._getDataElementMetadata(self).handle
        return DynamicObject(handle)

    @property
    def children(self):
        class ChildList(object):
            #pylint: disable=W0212
            def __init__(self, element):
                self.element = element

            def __len__(self):
                return self.element._getDataElementChildCount(self.element)

            def __getitem__(self, index):
                if index >= len(self):
                    raise IndexError
                elem = self.element._getDataElementChild(self.element, index)
                return elem.leafclass()
        return ChildList(self)

    def cast_data_element(self, typ):
        return self._cast_data_element(self, typ)

    def copy_classification(self, element):
        return self._copy_classification(element, self)

DataElement._cast_data_element = \
    _genwrap("castDataElement", ctypes.c_void_p, DataElement, ctypes.c_char_p)
DataElement._getDataElement = \
    _genwrap("getDataElement", DataElement,
             ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int)
DataElement._getDataElementName = \
    _genwrap("getDataElementName", ctypes.c_uint32, DataElement,
             ctypes.c_char_p, ctypes.c_uint32)
DataElement._getDataElementType = \
    _genwrap("getDataElementType", ctypes.c_uint32, DataElement,
             ctypes.c_char_p, ctypes.c_uint32)
DataElement._getDataElementFilename = \
    _genwrap("getDataElementFilename", ctypes.c_uint32, DataElement,
             ctypes.c_char_p, ctypes.c_uint32)
DataElement._getDataElementChildCount = \
    _genwrap("getDataElementChildCount", ctypes.c_uint32, DataElement)
DataElement._getDataElementChild = \
    _genwrap("getDataElementChild", DataElement, DataElement, ctypes.c_uint32)
DataElement._copy_classification = \
    _genwrap("copyClassification", None, DataElement, DataElement)

class DataVariant(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, value=None, vtype=None, xml=True):
        ctypes.Structure.__init__(self)
        if isinstance(value, DataVariant):
            self.handle, self.__owns = value.handle, False
            return
        self.__owns = True
        import types
        if vtype is not None and not isinstance(value, ctypes.c_void_p):
            self.handle = \
                DataVariant._createDataVariantFromString(str(vtype),
                                                         str(value),
                                                         xml).handle
            return
        if vtype is None and value is not None:
            vtype = None
            if type(value) == types.StringType:
                self.handle = \
                    DataVariant._createDataVariantFromString("string",
                                                             str(value),
                                                             1).handle
                return
            elif type(value) == types.IntType or type(value) == types.LongType:
                if value < 0:
                    if value > -(2**(ctypes.sizeof(ctypes.c_byte)*8)/2):
                        vtype = "char"
                        value = ctypes.pointer(ctypes.c_byte(value))
                    elif value > -(2**(ctypes.sizeof(ctypes.c_short)*8)/2):
                        vtype = "short"
                        value = ctypes.pointer(ctypes.c_short(value))
                    elif value > -(2**(ctypes.sizeof(ctypes.c_int)*8)/2):
                        vtype = "int"
                        value = ctypes.pointer(ctypes.c_int(value))
                    elif value > -(2**(ctypes.sizeof(ctypes.c_long)*8)/2):
                        vtype = "long"
                        value = ctypes.pointer(ctypes.c_long(value))
                    elif value > -(2**(ctypes.sizeof(ctypes.c_longlong)*8)/2):
                        vtype = "Int64"
                        value = ctypes.pointer(ctypes.c_longlong(value))
                else:
                    if value < 2**(ctypes.sizeof(ctypes.c_ubyte)*8):
                        vtype = "unsigned char"
                        value = ctypes.pointer(ctypes.c_ubyte(value))
                    elif value < 2**(ctypes.sizeof(ctypes.c_ushort)*8):
                        vtype = "unsigned short"
                        value = ctypes.pointer(ctypes.c_ushort(value))
                    elif value < 2**(ctypes.sizeof(ctypes.c_uint)*8):
                        vtype = "unsigned int"
                        value = ctypes.pointer(ctypes.c_uint(value))
                    elif value < 2**(ctypes.sizeof(ctypes.c_ulong)*8):
                        vtype = "unsigned long"
                        value = ctypes.pointer(ctypes.c_ulong(value))
                    elif value < 2**(ctypes.sizeof(ctypes.c_ulonglong)*8):
                        vtype = "UInt64"
                        value = ctypes.pointer(ctypes.c_ulonglong(value))
            elif type(value) == types.FloatType:
                vtype, value = "float", ctypes.pointer(ctypes.c_float(value))
            else:
                raise OpticksError("Can't automatically convert %s." %
                                   str(type(value)))
        self.handle = self._createDataVariant(vtype, value).handle

    def __del__(self):
        if self.__owns:
            self._freeDataVariant(self)

    def __repr__(self):
        if not self.valid:
            return "<DataVariant: invalid>"
        return "<DataVariant: '%s' type: '%s'>" % (self.xml, self.dv_type)

    @property
    def display(self):
        if not self.valid:
            return None
        return _stringbuffer_wrap(self._getDataVariantValueString, self, 0)

    @property
    def xml(self):
        if not self.valid:
            return None
        return _stringbuffer_wrap(self._getDataVariantValueString, self, 1)

    @property
    def valid(self):
        return bool(self._isDataVariantValid(self))

    @property
    def dv_type(self):
        if not self.valid:
            return ""
        buf = ctypes.create_string_buffer(32)
        self._getDataVariantTypeName(self, buf, 32)
        return ctypes.string_at(buf)

    @property
    def value(self):
        if self.dv_type == "string": # special case..can't handle std::string
            return self.xml
        return _void_p_to_native(self.dv_type, self._getDataVariantValue(self))

class PlugInArgList(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __del__(self):
        if self.__owns:
            self._freePlugInArgList(self)

    def __repr__(self):
        return "PlugInArgList(%i)" % self.handle.value

    def __len__(self):
        return self._getPlugInArgCount(self)

    def __getitem__(self, key):
        from types import IntType
        if type(key) == IntType:
            return self._getPlugInArgByIndex(self, key)
        return self._getPlugInArgByName(self, key)

    def keys(self):
        #pylint: disable=W0212
        rval = []
        for idx in range(len(self)):
            argref = self._getPlugInArgByIndex(self, idx)
            rval.append(_stringbuffer_wrap(PlugInArg._getPlugInArgName,
                                           argref))
        return rval

class PlugInArg(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __repr__(self):
        return "PlugInArg(%i)" % self.handle

    @property
    def name(self):
        return _stringbuffer_wrap(self._getPlugInArgName, self)

    @property
    def type(self):
        return _stringbuffer_wrap(self._getPlugInArgTypeName, self)

    @property
    def description(self):
        return _stringbuffer_wrap(self._getPlugInArgDescription, self)

    @property
    def default_set(self):
        return bool(self._isPlugInArgDefaultSet(self))

    @property
    def actual_set(self):
        return bool(self._isPlugInArgActualSet(self))

    @property
    def value(self):
        return _void_p_to_native(self.type, self._getPlugInArgValue(self))

    def get_default(self):
        if not self.default_set:
            raise OpticksError("Default value is not set.")
        return _void_p_to_native(self.type,
                                 self._getPlugInArgDefaultValue(self))

    def set_default(self, value):
        value = _prep_for_set(value, self.type)
        if isinstance(value, DataVariant):
            self._setPlugInArgDefaultValueFromDataVariant(self, value)
        elif isinstance(value, ctypes.c_void_p):
            self._setPlugInArgDefaultValueFromVoid(self, value)
        else:
            raise OpticksError("Unable to store value.")

    # this can be changed to use .setter when we supporting only python >= 2.6
    default = property(get_default, set_default)

    def get_actual(self):
        if not self.actual_set:
            raise OpticksError("Actual value is not set.")
        return _void_p_to_native(self.type, self._getPlugInArgActualValue(self))

    def set_actual(self, value):
        value = _prep_for_set(value, self.type)
        if isinstance(value, DataVariant):
            self._setPlugInArgActualValueFromDataVariant(self, value)
        elif isinstance(value, ctypes.c_void_p):
            self._setPlugInArgActualValueFromVoid(self, value)
        else:
            raise OpticksError("Unable to store value.")

    # this can be changed to use .setter when we supporting only python >= 2.6
    actual = property(get_actual, set_actual)

class WizardNode(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]

    @property
    def name(self):
        return _stringbuffer_wrap(self._getWizardNodeName, self)

    @property
    def type(self):
        return _stringbuffer_wrap(self._getWizardNodeType, self)

    def get_value(self):
        value = _void_p_to_native(self.type, self._getWizardNodeValue(self))
        if isinstance(value, ctypes.c_void_p):
            new_dv = DataVariant(value, self.type)
            if new_dv.valid:
                value = new_dv
        return value

    def set_value(self, value):
        value = _prep_for_set(value, self.type)
        if isinstance(value, DataVariant):
            self._setWizardNodeValue(self, self._getDataVariantValue(value))
        elif isinstance(value, ctypes.c_void_p):
            self._setWizardNodeValue(self, value)
        else:
            raise OpticksError("Unable to store value.")

    value = property(get_value, set_value)

    def __repr__(self):
        return ("<WizardNode object: '%s' of type: '%s'>" %
                (self.name, self.type))

DataVariant._createDataVariantFromString = \
    _genwrap("createDataVariantFromString", DataVariant,
             ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int)
DataVariant._vectorToArray = \
    _genwrap("vectorToArray", ctypes.c_uint32, ctypes.c_void_p,
             ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p))
DataVariant._createDataVariant = \
    _genwrap("createDataVariant", DataVariant, ctypes.c_char_p,
             ctypes.c_void_p)
DataVariant._freeDataVariant = \
    _genwrap("freeDataVariant", None, DataVariant)
DataVariant._isDataVariantValid = \
    _genwrap("isDataVariantValid", ctypes.c_int, DataVariant)
DataVariant._getDataVariantTypeName = \
    _genwrap("getDataVariantTypeName", ctypes.c_uint32, DataVariant,
             ctypes.c_char_p, ctypes.c_uint32)
DataVariant._getDataVariantValue = \
    _genwrap("getDataVariantValue", ctypes.c_void_p, DataVariant)
DataVariant._getDataVariantValueString = \
    _genwrap("getDataVariantValueString", ctypes.c_uint32, DataVariant,
             ctypes.c_int, ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._getPlugInArgName = \
    _genwrap("getPlugInArgName", ctypes.c_uint32, PlugInArg,
             ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._getPlugInArgTypeName = \
    _genwrap("getPlugInArgTypeName", ctypes.c_uint32, PlugInArg,
             ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._getPlugInArgDescription = \
    _genwrap("getPlugInArgDescription", ctypes.c_uint32, PlugInArg,
             ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._isPlugInArgDefaultSet = \
    _genwrap("isPlugInArgDefaultSet", ctypes.c_int, PlugInArg)
PlugInArg._isPlugInArgActualSet = \
    _genwrap("isPlugInArgActualSet", ctypes.c_int, PlugInArg)
PlugInArg._getPlugInArgValue = \
    _genwrap("getPlugInArgValue", ctypes.c_void_p, PlugInArg)
PlugInArg._getPlugInArgDefaultValue = \
    _genwrap("getPlugInArgDefaultValue", ctypes.c_void_p, PlugInArg)
PlugInArg._getPlugInArgActualValue = \
    _genwrap("getPlugInArgActualValue", ctypes.c_void_p, PlugInArg)
PlugInArg._setPlugInArgDefaultValueFromVoid = \
    _genwrap("setPlugInArgDefaultValueFromVoid", None, PlugInArg,
             ctypes.c_void_p)
PlugInArg._setPlugInArgDefaultValueFromDataVariant = \
    _genwrap("setPlugInArgDefaultValueFromDataVariant", None, PlugInArg,
             DataVariant)
PlugInArg._setPlugInArgActualValueFromVoid = \
    _genwrap("setPlugInArgActualValueFromVoid", None, PlugInArg,
             ctypes.c_void_p)
PlugInArg._setPlugInArgActualValueFromDataVariant = \
    _genwrap("setPlugInArgActualValueFromDataVariant", None, PlugInArg,
             DataVariant)
PlugInArgList._freePlugInArgList = \
    _genwrap("freePlugInArgList", None, PlugInArgList)
PlugInArgList._getPlugInArgCount = \
    _genwrap("getPlugInArgCount", ctypes.c_uint32, PlugInArgList)
PlugInArgList._getPlugInArgByName = \
    _genwrap("getPlugInArgByName", PlugInArg, PlugInArgList, ctypes.c_char_p)
PlugInArgList._getPlugInArgByIndex = \
    _genwrap("getPlugInArgByIndex", PlugInArg, PlugInArgList, ctypes.c_uint32)
WizardNode._getWizardNodeName = \
    _genwrap("getWizardNodeName", ctypes.c_uint32, WizardNode,
             ctypes.c_char_p, ctypes.c_uint32)
WizardNode._getWizardNodeType = \
    _genwrap("getWizardNodeType", ctypes.c_uint32, WizardNode,
             ctypes.c_char_p, ctypes.c_uint32)
WizardNode._getWizardNodeValue = \
    _genwrap("getWizardNodeValue", ctypes.c_void_p, WizardNode)
WizardNode._setWizardNodeValue = \
    _genwrap("setWizardNodeValue", ctypes.c_int, WizardNode, ctypes.c_void_p)

class PlugIn(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, name, batch=True):
        ctypes.Structure.__init__(self)
        self.handle, self.__owns = self._createPlugIn(name, batch).handle, True

    def __del__(self):
        if self.__owns:
            self._freePlugIn(self)

    @property
    def inputs(self):
        return self._getPlugInInputArgList(self)

    @property
    def outputs(self):
        return self._getPlugInOutputArgList(self)

    def __call__(self):
        return bool(self._executePlugIn(self))

class Wizard(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]

    class WizardNodeList(object):
        def __init__(self, wizard, input_list):
            assert(wizard is not None)
            self.__wizard, self.__input_list = wizard, input_list

        def __len__(self):
            if self.__input_list:
                return self._getWizardInputNodeCount(self.__wizard)
            return self._getWizardOutputNodeCount(self.__wizard)

        def __getitem__(self, key):
            from types import IntType
            if type(key) == IntType:
                if self.__input_list:
                    return self._getWizardInputNodeByIndex(self.__wizard, key)
                return self._getWizardOutputNodeByIndex(self.__wizard, key)
            if self.__input_list:
                return self._getWizardInputNodeByName(self.__wizard, str(key))
            return self._getWizardOutputNodeByName(self.__wizard, str(key))

        def iter(self):
            return self.iter_keys()

        def iter_values(self):
            def do_iter(wizard, cnt, input_list):
                for idx in xrange(cnt):
                    if input_list:
                        yield self._getWizardInputNodeByIndex(wizard, idx)
                    else:
                        yield self._getWizardInputNodeByIndex(wizard, idx)
            return do_iter(self.__wizard, len(self), self.__input_list)

        def iter_keys(self):
            def do_iter(wizard, cnt, input_list):
                for idx in xrange(cnt):
                    node = None
                    if input_list:
                        node = self._getWizardInputNodeByIndex(wizard, idx)
                    else:
                        node = self._getWizardInputNodeByIndex(wizard, idx)
                    yield node.name
            return do_iter(self.__wizard, len(self), self.__input_list)

    def __init__(self, filename):
        ctypes.Structure.__init__(self)
        self.handle, self.__owns = self._loadWizard(filename).handle, True

    def __del__(self):
        if self.__owns:
            self._freeWizard(self)

    @property
    def inputs(self):
        return Wizard.WizardNodeList(self, True)

    @property
    def outputs(self):
        return Wizard.WizardNodeList(self, False)

    def __call__(self):
        return bool(self._executeWizard(self))

    @property
    def name(self):
        return _stringbuffer_wrap(self._getWizardName, self)

PlugIn._createPlugIn = \
    _genwrap("createPlugIn", PlugIn, ctypes.c_char_p, ctypes.c_int)
PlugIn._freePlugIn = _genwrap("freePlugIn", None, PlugIn, errorCheck=False)
PlugIn._getPlugInInputArgList = \
    _genwrap("getPlugInInputArgList", PlugInArgList, PlugIn)
PlugIn._getPlugInOutputArgList = \
    _genwrap("getPlugInOutputArgList", PlugInArgList, PlugIn)
PlugIn._executePlugIn = _genwrap("executePlugIn", ctypes.c_int, PlugIn)
Wizard._loadWizard = _genwrap("loadWizard", Wizard, ctypes.c_char_p)
Wizard._freeWizard = _genwrap("freeWizard", None, Wizard, errorCheck=False)
Wizard._getWizardName = \
    _genwrap("getWizardName", ctypes.c_uint32, Wizard, ctypes.c_char_p,
             ctypes.c_uint32)
Wizard.WizardNodeList._getWizardInputNodeCount = \
    _genwrap("getWizardInputNodeCount", ctypes.c_uint32, Wizard)
Wizard.WizardNodeList._getWizardOutputNodeCount = \
    _genwrap("getWizardOutputNodeCount", ctypes.c_uint32, Wizard)
Wizard.WizardNodeList._getWizardInputNodeByIndex = \
    _genwrap("getWizardInputNodeByIndex", WizardNode, Wizard, ctypes.c_uint32)
Wizard.WizardNodeList._getWizardOutputNodeByIndex = \
    _genwrap("getWizardOutputNodeByIndex", WizardNode, Wizard, ctypes.c_uint32)
Wizard.WizardNodeList._getWizardInputNodeByName = \
    _genwrap("getWizardInputNodeByName", WizardNode, Wizard, ctypes.c_char_p)
Wizard.WizardNodeList._getWizardOutputNodeByName = \
    _genwrap("getWizardOutputNodeByName", WizardNode, Wizard,
             ctypes.c_char_p)
Wizard._executeWizard = _genwrap("executeWizard", ctypes.c_int, Wizard)

class DynamicObject(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, wrapper=None):
        ctypes.Structure.__init__(self)
        if wrapper is None:
            self.handle = self._createDynamicObject().handle
            self.__owns = True
        else:
            self.handle, self.__owns = wrapper, False

    def __del__(self):
        if self.__owns:
            self._freeDynamicObject(self)

    def clear(self):
        self._clearMetadata(self)

    def __len__(self):
        return self._getMetadataAttributeCount(self)

    def __getitem__(self, key):
        val = DataVariant(self._getMetadataAttributeByPath(self, key))
        if not val.valid:
            raise KeyError("'DynamicObject' has no attribute '%s'" % key)
        elif val.dv_type == 'DynamicObject':
            val = DynamicObject(ctypes.cast(val.value, ctypes.c_void_p))
        return val

    def __setitem__(self, key, value):
        if isinstance(value, DynamicObject):
            value = DataVariant(ctypes.cast(self.handle, ctypes.c_void_p),
                                "DynamicObject")
        elif not isinstance(value, DataVariant):
            value = DataVariant(value)
        if not value.valid:
            raise ValueError("Invalid 'DataVariant' value.")
        self._setMetadataAttributeByPath(self, key, value)

    def __delitem__(self, key):
        try:
            self._removeMetadataAttributeByPath(self, key)
        except SimpleApiError:
            raise KeyError("'DynamicObject' has no attribute '%s'" % key)


    def __getattr__(self, name):
        if name == '__members__':
            rval = []
            for idx in range(len(self)):
                rval.append(_stringbuffer_wrap(self._getMetadataAttributeName,
                                               self, idx))
            return rval
        val = DataVariant(self._getMetadataAttribute(self, name))
        if not val.valid:
            raise AttributeError("'DynamicObject' has no attribute '%s'" % name)
        elif val.dv_type == 'DynamicObject':
            val = DynamicObject(ctypes.cast(val.value, ctypes.c_void_p))
        return val

    def __setattr__(self, name, value):
        if name.startswith('_') or name == "handle":
            return object.__setattr__(self, name, value)
        return self.__setitem__(name, value)

    def __delattr__(self, name):
        try:
            self._removeMetadataAttribute(self, name)
        except SimpleApiError:
            raise KeyError("'DynamicObject' has no attribute '%s'" % name)

    def __iter__(self):
        return self.iter_keys()

    def iter_keys(self):
        def do_iter(meta, cnt):
            for idx in xrange(cnt):
                yield _stringbuffer_wrap(self._getMetadataAttributeName,
                                         meta, idx)
        return do_iter(self, len(self))

    def __reversed__(self):
        def do_iter(meta, cnt):
            for idx in xrange(cnt-1, -1, -1):
                yield _stringbuffer_wrap(self._getMetadataAttributeName,
                                         meta, idx)
        return do_iter(self, len(self))

    def __str__(self):
        return "<DynamicObject with %i attribute(s)>" % len(self)

    def __repr__(self):
        return ("DynamicObject(wrapper=DynamicObject(%i))" %
                ctypes.addressof(self))

class ConfigurationSettings(object):
    def __init__(self):
        self.__defaults = None

    def __getitem__(self, key):
        tempf = _genwrap("getConfigurationSetting", DataVariant,
                         ctypes.c_char_p)
        return tempf(key)

    def __setitem__(self, key, value):
        if not isinstance(value, DataVariant):
            value = DataVariant(value)
        tempf = _genwrap("setConfigurationSetting", ctypes.c_int,
                         ctypes.c_char_p, DataVariant)
        tempf(key, value)

    def add_to_defaults(self, key):
        """Add the specified configuration setting to the defaults
        list which is maintained as a member object until
        serialized or cleared.

        """
        if self.__defaults is None:
            self.__defaults = DynamicObject()
        tempf = _genwrap("copyConfigurationSetting", ctypes.c_int,
                         ctypes.c_char_p, DynamicObject)
        tempf(key, self.__defaults)

    def serialize_defaults(self, filename):
        if self.__defaults is None:
            raise ValueError("No configuration settings in defaults.")
        tempf = _genwrap("serializeConfigurationSettingDefaults",
                         ctypes.c_int, ctypes.c_char_p, DynamicObject)
        tempf(filename, self.__defaults)
        self.clear_defaults()

    def clear_defaults(self):
        self.__defaults = None

DynamicObject._createDynamicObject = \
    _genwrap("createDynamicObject", DynamicObject)
DynamicObject._freeDynamicObject = \
    _genwrap("freeDynamicObject", None, DynamicObject, errorCheck=False)
DynamicObject._getMetadataAttributeCount = \
    _genwrap("getMetadataAttributeCount", ctypes.c_uint32, DynamicObject)
DynamicObject._getMetadataAttributeName = \
    _genwrap("getMetadataAttributeName", ctypes.c_uint32,
             DynamicObject, ctypes.c_uint32, ctypes.c_char_p, ctypes.c_uint32)
DynamicObject._getMetadataAttribute = \
    _genwrap("getMetadataAttribute", DataVariant, DynamicObject,
             ctypes.c_char_p)
DynamicObject._getMetadataAttributeByPath = \
    _genwrap("getMetadataAttributeByPath", DataVariant, DynamicObject,
             ctypes.c_char_p)
DynamicObject._setMetadataAttribute = \
    _genwrap("setMetadataAttribute", None, DynamicObject,
             ctypes.c_char_p, DataVariant)
DynamicObject._setMetadataAttributeByPath = \
    _genwrap("setMetadataAttributeByPath", None, DynamicObject,
             ctypes.c_char_p, DataVariant)
DynamicObject._removeMetadataAttribute = \
    _genwrap("removeMetadataAttribute", None, DynamicObject, ctypes.c_char_p)
DynamicObject._removeMetadataAttributeByPath = \
    _genwrap("removeMetadataAttributeByPath", None, DynamicObject,
             ctypes.c_char_p)
DynamicObject._clearMetadata  = _genwrap("clearMetadata", None, DynamicObject)
DataElement._getDataElementMetadata = \
    _genwrap("getDataElementMetadata", DynamicObject, DataElement)

class IntComplex32(ctypes.Structure):
    "Integer complex with 16-bit real and 16-bit imaginary elements."
    _fields_ = [("real", ctypes.c_int16), ("imag", ctypes.c_int16)]

class FloatComplex64(ctypes.Structure):
    "Floating point complex with 32-bit real and 32-bit imaginary elements."
    _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]

class Encoding(ctypes.c_uint32):
    "Opticks data encoding type."
    INT1SBYTE = 0
    INT1UBYTE = 1
    INT2SBYTES = 2
    INT2UBYTES = 3
    INT4SCOMPLEX = 4
    INT4SBYTES = 5
    INT4UBYTES = 6
    FLT4BYTES = 7
    FLT8COMPLEX = 8
    FLT8BYTES = 9

    def __repr__(self):
        if self.value == self.INT1SBYTE:
            strname = "INT1SBYTE"
        elif self.value == self.INT1UBYTE:
            strname = "INT1UBYTE"
        elif self.value == self.INT2SBYTES:
            strname = "INT2SBYTES"
        elif self.value == self.INT2UBYTES:
            strname = "INT2UBYTES"
        elif self.value == self.INT4SBYTES:
            strname = "INT4SBYTES"
        elif self.value == self.INT4UBYTES:
            strname = "INT4UBYTES"
        elif self.value == self.INT4SCOMPLEX:
            strname = "INT4SCOMPLEX"
        elif self.value == self.FLT4BYTES:
            strname = "FLT4BYTES"
        elif self.value == self.FLT8BYTES:
            strname = "FLT8BYTES"
        elif self.value == self.FLT8COMPLEX:
            strname = "FLT8COMPLEX"
        else:
            strname = "Unknown"
        return "<Encoding: %s>" % strname

    def to_ctype(self):
        "Return an appropriate ctypes data type for this encoding type."
        retval = None
        if self.value == self.INT1SBYTE:
            retval = ctypes.POINTER(ctypes.c_int8)
        elif self.value == self.INT1UBYTE:
            retval = ctypes.POINTER(ctypes.c_uint8)
        elif self.value == self.INT2SBYTES:
            retval = ctypes.POINTER(ctypes.c_int16)
        elif self.value == self.INT2UBYTES:
            retval = ctypes.POINTER(ctypes.c_uint16)
        elif self.value == self.INT4SBYTES:
            retval = ctypes.POINTER(ctypes.c_int32)
        elif self.value == self.INT4UBYTES:
            retval = ctypes.POINTER(ctypes.c_uint32)
        elif self.value == self.INT4SCOMPLEX:
            retval = ctypes.POINTER(IntComplex32)
        elif self.value == self.FLT4BYTES:
            retval = ctypes.POINTER(ctypes.c_float)
        elif self.value == self.FLT8BYTES:
            retval = ctypes.POINTER(ctypes.c_double)
        elif self.value == self.FLT8COMPLEX:
            retval = ctypes.POINTER(FloatComplex64)
        else:
            retval = ctypes.c_void_p
        return retval

    def to_numpy_type(self):
        "Return an appropriate numpy dtype for this encoding type."
        retval = None
        if self.value == self.INT1SBYTE:
            retval = "int8"
        elif self.value == self.INT1UBYTE:
            retval = "uint8"
        elif self.value == self.INT2SBYTES:
            retval = "int16"
        elif self.value == self.INT2UBYTES:
            retval = "uint16"
        elif self.value == self.INT4SBYTES:
            retval = "int32"
        elif self.value == self.INT4UBYTES:
            retval = "uint32"
        elif self.value == self.INT4SCOMPLEX:
            retval = "i2i2"
        elif self.value == self.FLT4BYTES:
            retval = "float32"
        elif self.value == self.FLT8BYTES:
            retval = "float64"
        elif self.value == self.FLT8COMPLEX:
            retval = "complex64"
        else:
            retval = "void"
        return retval

    @classmethod
    def from_numpy_type(cls, typestr):
        "Return an appropriate numpy dtype for this encoding type."
        retval = None
        if typestr == "int8":
            retval = cls.INT1SBYTE
        elif typestr == "uint8":
            retval = cls.INT1UBYTE
        elif typestr == "int16":
            retval = cls.INT2SBYTES
        elif typestr == "uint16":
            retval = cls.INT2UBYTES
        elif typestr == "int32":
            retval = cls.INT4SBYTES
        elif typestr == "uint32":
            retval = cls.INT4UBYTES
        elif typestr == "float32":
            retval = cls.FLT4BYTES
        elif typestr == "float64":
            retval = cls.FLT8BYTES
        elif typestr == "complex64":
            retval = cls.FLT8COMPLEX
        else:
            raise TypeError("'%s' can't be represented in Opticks." % typestr)
        return retval

class Interleave(ctypes.c_uint32):
    "Opticks data interleave format."
    BSQ = 0
    BIP = 1
    BIL = 2

    def __repr__(self):
        if self.value == self.BSQ:
            return "<Interleave: BSQ>"
        elif self.value == self.BIP:
            return "<Interleave: BIP>"
        elif self.value == self.BIL:
            return "<Interleave: BIL>"
        return "<Interleave: Unknown"

class ProcessingLocationPreference(ctypes.c_uint32):
    "Processing location hint for creation of raster elements."
    PREFER_RAM = 0
    RAM = 1
    ONDISK = 2

    def __repr__(self):
        if self.value == self.ONDISK:
            return "<ProcessingLocationPreference: on-disk only>"
        elif self.value == self.RAM:
            return "<ProcessingLocationPreference: in memory only>"
        elif self.value == self.PREFER_RAM:
            return "<ProcessingLocationPreference: prefer in memory>"
        return "<Interleave: Unknown"

class DataInfo(ctypes.Structure):
    "Information about a raster element."
    _fields_ = [("rows", ctypes.c_uint32),
                ("columns", ctypes.c_uint32),
                ("bands", ctypes.c_uint32),
                ("interleave", Interleave),
                ("encoding", Encoding),
                ("encoding_size", ctypes.c_uint32),
                ("num_bad_values", ctypes.c_uint32),
                ("p_bad_values", ctypes.POINTER(ctypes.c_int32))]

    def __init__(self, *args):
        #pylint: disable=W0231
        pass # don't call the base class __init__

    def __new__(cls, data_element=None):
        create_data_info = _genwrap("createDataInfo",
                                    ctypes.POINTER(DataInfo), DataElement)
        rval = create_data_info(data_element).contents
        if rval:
            rval.__coreOwns = True
        return rval

    def __del__(self):
        if self.__coreOwns:
            tempf = _genwrap("destroyDataInfo", None,
                             ctypes.POINTER(DataInfo), errorCheck=False)
            tempf(self)

    def __repr__(self):
        return ("<DataInfo: %i,%i,%i %s %s>" %
                (self.rows, self.columns, self.bands,
                self.interleave, self.encoding))

    def get_bad_values(self):
        rval = []
        for idx in range(self.num_bad_values):
            rval.append(self.p_bad_values[idx])
        return rval

    def set_bad_values(self, val):
        #pylint: disable=W0201
        assert(isinstance(val, list))
        self.num_bad_values = len(val)
        tempv = (ctypes.c_int32 * self.num_bad_values)
        self.p_bad_values = ctypes.cast(ctypes.POINTER(ctypes.c_int32),
                                        tempv)
        for idx in range(self.num_bad_values):
            self.p_bad_values[idx] = ctypes.c_int32(val[idx])

    bad_values = property(get_bad_values, set_bad_values)

class RasterElementArgs(ctypes.Structure):
    "Argument structure for creation of a new raster element."
    #pylint: disable=R0902
    _fields_ = [("rows", ctypes.c_uint32),
                ("columns", ctypes.c_uint32),
                ("bands", ctypes.c_uint32),
                ("interleave", Interleave),
                ("encoding", Encoding),
                ("location", ProcessingLocationPreference),
                ("parent", DataElement),
                ("num_bad_values", ctypes.c_uint32),
                ("p_bad_values", ctypes.POINTER(ctypes.c_int32))]

    def __repr__(self):
        return ("<RasterElementArgs: %i,%i,%i %s %s %s>" %
                (self.rows, self.columns, self.bands, self.interleave,
                self.encoding, self.location))

    def from_numpy_array(self, array):
        """This will fill in details from a numpy array. Before
        calling this function you must set
        'interleave' appropriately.

        """
        #pylint: disable=W0201
        try:
            #pylint: disable=W0612, W0621
            import numpy
        except ImportError:
            # numpy not available
            raise NotImplementedError("numpy is not available")
        if len(array.shape) == 3:
            if self.interleave.value == Interleave.BSQ:
                self.bands, self.rows, self.columns = array.shape
            elif self.interleave.value == Interleave.BIL:
                self.rows, self.bands, self.columns = array.shape
            elif self.interleave.value == Interleave.BIP:
                self.rows, self.columns, self.bands = array.shape
        elif len(array.shape) == 2:
            self.bands = 1
            self.rows, self.columns = array.shape
        else:
            raise ValueError("Array must be 2-d or 3-d")
        self.encoding = self.encoding.from_numpy_type(array.dtype.name)

    def get_bad_values(self):
        rval = []
        for idx in range(self.num_bad_values):
            rval.append(self.p_bad_values[idx])
        return rval

    def set_bad_values(self, val):
        #pylint: disable=W0201
        assert(isinstance(val, list))
        self.num_bad_values = len(val)
        tempv = (ctypes.c_int32 * self.num_bad_values)()
        self.p_bad_values = ctypes.cast(tempv,
                                        ctypes.POINTER(ctypes.c_int32))
        for idx in range(self.num_bad_values):
            self.p_bad_values[idx] = ctypes.c_int32(val[idx])

    bad_values = property(get_bad_values, set_bad_values)

class DataPointerArgs(ctypes.Structure):
    "Argument structure for creation of a new data pointer."
    _fields_ = [("row_start", ctypes.c_uint32),
                ("row_end", ctypes.c_uint32),
                ("column_start", ctypes.c_uint32),
                ("column_end", ctypes.c_uint32),
                ("band_start", ctypes.c_uint32),
                ("band_end", ctypes.c_uint32),
                ("interleave", Interleave)]

    def __repr__(self):
        return ("<DataPointerArgs: %i-%i, %i-%i, %i-%i, %s>" %
                (self.row_start, self.row_end, self.column_start,
                self.column_end, self.band_start, self.band_end,
                self.interleave))

class DataAccessorArgs(ctypes.Structure):
    "Argument structure for creation of a new data accessor."
    _fields_ = [("row_start", ctypes.c_uint32),
                ("row_end", ctypes.c_uint32),
                ("concurrent_rows", ctypes.c_uint32),
                ("column_start", ctypes.c_uint32),
                ("column_end", ctypes.c_uint32),
                ("concurrent_columns", ctypes.c_uint32),
                ("band_start", ctypes.c_uint32),
                ("band_end", ctypes.c_uint32),
                ("concurrent_bands", ctypes.c_uint32),
                ("interleave", Interleave),
                ("writable", ctypes.c_uint32)]

    def __repr__(self):
        return ("<DataAccessorArgs: %i-%i, %i-%i, %i-%i, %s>" %
                (self.row_start, self.row_end, self.column_start,
                self.column_end, self.band_start, self.band_end,
                self.interleave))

class AoiIterator(ctypes.Structure):
    "An iterator over an AOI."
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, element = None, raster = None, bounding_box = None):
        """Create a new AOI iteraor over a specified raster
        element or bounding box. Pass in either a raster element
        or a 4-tuple (x1, y1, x2, y2) bounding box. If element is None,
        iterate over the entire raster or bounding_box.

        """
        ctypes.Structure.__init__(self)
        assert(raster is not None or bounding_box is not None)
        assert(not (raster is not None and bounding_box is not None))

        try:
            if raster is not None:
                if element is None:
                    tempf = _genwrap("createAoiIteratorOverRaster",
                                     AoiIterator, ctypes.c_void_p, DataElement)
                    self.handle = tempf(element, raster).handle
                else:
                    tempf = _genwrap("createAoiIteratorOverRaster",
                                     AoiIterator, DataElement, DataElement)
                    self.handle = tempf(element, raster).handle
            else:
                if element is None:
                    tempf = _genwrap("createAoiIteratorOverBoundingBox",
                                     AoiIterator, ctypes.c_void_p,
                                     ctypes.c_int32, ctypes.c_int32,
                                     ctypes.c_int32, ctypes.c_int32)
                    self.handle = tempf(element, bounding_box[0],
                                        bounding_box[1], bounding_box[2],
                                        bounding_box[3]).handle
                else:
                    tempf = _genwrap("createAoiIteratorOverBoundingBox",
                                     AoiIterator, DataElement,
                                     ctypes.c_int32, ctypes.c_int32,
                                     ctypes.c_int32, ctypes.c_int32)
                    self.handle = tempf(element, bounding_box[0],
                                        bounding_box[1], bounding_box[2],
                                        bounding_box[3]).handle
            self.__last = False
        except SimpleApiError, err:
            if err.code == SimpleApiError.SIMPLE_NOT_FOUND:
                self.__last = False
        self.__first, self.__owns = True, True

    def __del__(self):
        if self.__owns:
            _genwrap("freeAoiIterator", None, AoiIterator)(self)

    def __iter__(self):
        return self

    def next(self):
        if not self.__first and not self.__last:
            if self._nextAoiIterator(self) == 0:
                self.__last = True
        if self.__last:
            raise StopIteration()
        self.__first = False
        column, row = ctypes.c_int32(-1), ctypes.c_int32(-1)
        self._getAoiIteratorLocation(self,
                                     ctypes.byref(column),
                                     ctypes.byref(row))
        return column.value, row.value
AoiIterator._nextAoiIterator = \
    _genwrap("nextAoiIterator", ctypes.c_int, AoiIterator)
AoiIterator._getAoiIteratorLocation = \
    _genwrap("getAoiIteratorLocation", ctypes.c_int, AoiIterator,
             ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32))

class Aoi(DataElement):
    "An AOI with support for iteration and random access."
    _getAoiValue = \
        _genwrap("getAoiValue", ctypes.c_int, DataElement,
                 ctypes.c_int32, ctypes.c_int32)
    _setAoiValue = \
        _genwrap("setAoiValue", ctypes.c_int, DataElement,
                 ctypes.c_uint32, ctypes.c_uint32, ctypes.c_int)
    _getAoiMinimalBoundingBox = \
        _genwrap("getAoiMinimalBoundingBox", ctypes.c_int,
                 DataElement, ctypes.POINTER(ctypes.c_int32),
                 ctypes.POINTER(ctypes.c_int32),
                 ctypes.POINTER(ctypes.c_int32),
                 ctypes.POINTER(ctypes.c_int32))

    def __init__(self, name, element=None):
        """Get an AOI.
        If name is specified, get the named AOI.
        If element is specified, use an existing DataElement.

        """
        assert(name is not None or element is not None)
        assert(not (name is not None and element is not None))
        if element is not None:
            handle = element.handle
        else:
            handle = self._getDataElement(name, "AoiElement", int(0)).handle
        DataElement.__init__(self, None, wrapper=handle)

    @classmethod
    def create(cls, name):
        found = False
        try:
            cls._getDataElement(name, "AoiElement", int(0))
            #if above doesn't throw, then element already exists
            found = True
        except SimpleApiError:
            #didn't exist, so we can create
            pass
        if found:
            raise SimpleApiError(SimpleApiError.SIMPLE_EXISTS)
        elem = cls._getDataElement(name, "AoiElement", int(1))
        return Aoi(None, element=elem)

    def __getitem__(self, (column, row)):
        return bool(self._getAoiValue(self, column, row))

    def __setitem__(self, (column, row), value):
        self._setAoiValue(self, column, row, int(value))

    @property
    def minimal_bounding_box(self):
        min_column = ctypes.c_int32(0)
        min_row = ctypes.c_int32(0)
        max_column = ctypes.c_int32(0)
        max_row = ctypes.c_int32(0)
        self._getAoiMinimalBoundingBox(self,
                                       ctypes.byref(min_column),
                                       ctypes.byref(min_row),
                                       ctypes.byref(max_column),
                                       ctypes.byref(max_row))
        return min_column.value, min_row.value, max_column.value, max_row.value

    def __iter__(self):
        return apply(self.iter_bounding, self.minimal_bounding_box)

    def iter_raster(self, raster_element):
        """Create an iterator over an AOI bounded by the extents
        of a RasterElement.

        """
        return AoiIterator(self, raster = raster_element)

    def iter_bounding(self, min_column, min_row, max_column, max_row):
        """Create an iterator over an AOI bounded by the
        specified pixel coordinates.

        """
        bbox = (min_column, min_row, max_column, max_row)
        return AoiIterator(self, bounding_box = bbox)

class DataAccessor(ctypes.Structure):
    """Wrapper for an Opticks data accessor. This is the most
    flexible data access method but is also the most complex.

    """
    _fields_ = [("handle", ctypes.c_void_p)]

    def __del__(self):
        if self.__owns:
            tempf = _genwrap("destroyDataAccessor", None, DataAccessor,
                             errorCheck=False)
            tempf(self)

    def initialize(self, *args):
        #pylint: disable=W0201
        "Not user callable...this is used by RasterElement.get_data_accessor"
        # args = owns, encoding, colcount, writable
        self.__owns, self.__encoding, self.__col_count, self.__writable = args

    @property
    def row(self):
        "Get a ctypes pointer to the current row."
        return ctypes.cast(ctypes.c_void_p(self._getDataAccessorRow(self)),
                           self.__encoding)

    def next_row(self, count = 1, reset_column = True):
        """Advance the data accessor count number of rows.
        If reset column is True, the data accessor will point to
        the original start column of the new row.

        """
        self._nextDataAccessorRow(self, count, reset_column)

    @property
    def column(self):
        "Get a ctypes pointer to the current column."
        return ctypes.cast(ctypes.c_void_p(self._getDataAccessorColumn(self)),
                           self.__encoding)

    def next_column(self, count = 1):
        "Advance the data accessor count number of columns."
        self._nextDataAccessorColumn(self, count)

    def __getitem__(self, (row, column)):
        "Access the data point at a specific (row, column)."
        self.to_pixel(row, column)
        if not self.valid:
            raise OpticksError("Location (%i, %i) is invalid." % (row, column))
        return self.column.contents.value

    def __setitem__(self, (row, column), value):
        if not self.__writable:
            raise OpticksError("Accessor is read-only")
        self.to_pixel(row, column)
        if not self.valid:
            raise OpticksError("Location (%i, %i) is invalid." % (row, column))
        self.column[0] = value

    def to_pixel(self, row, column):
        self._to_pixel(self, row, column)

    def iter_rows(self, incr = 1):
        """Create an iterator across rows which accesses
        the entire row each iteration.

        """
        def do_iter(acc, incr):
            while acc.valid:
                yield acc.row
                acc.next_row(incr)
        return do_iter(self, incr)

    def iter_columns(self, incr = 1):
        "Create an iteractor across columns in the current row."
        def do_iter(acc, col_count, incr):
            #pylint: disable=W0612
            for idx in xrange(col_count):
                yield acc.column
                acc.next_column(incr)
        return do_iter(self, self.__col_count, incr)

    @property
    def valid(self):
        return self._valid(self)

    @property
    def row_size(self):
        return self._rowsize(self)

DataAccessor._getDataAccessorRow = \
    _genwrap("getDataAccessorRow", ctypes.c_void_p, DataAccessor)
DataAccessor._getDataAccessorColumn = \
    _genwrap("getDataAccessorColumn", ctypes.c_void_p, DataAccessor)
DataAccessor._nextDataAccessorRow = \
    _genwrap("nextDataAccessorRow", None, DataAccessor, ctypes.c_uint32,
             ctypes.c_int)
DataAccessor._nextDataAccessorColumn = \
    _genwrap("nextDataAccessorColumn", None, DataAccessor, ctypes.c_uint32)
DataAccessor._valid = \
    _genwrap("isDataAccessorValid", ctypes.c_int, DataAccessor)
DataAccessor._rowsize = \
    _genwrap("getDataAccessorRowSize", ctypes.c_uint32, DataAccessor)
DataAccessor._to_pixel = \
    _genwrap("toDataAccessorPixel", None, DataAccessor, ctypes.c_uint32,
             ctypes.c_uint32)

_RASTER_BLOCK_TYPE = None
def _create_raster_block():
    #pylint: disable=W0603, W0621
    global _RASTER_BLOCK_TYPE
    try:
        import numpy
        class RasterBlock(numpy.ndarray):
            #pylint: disable=E1101, W0201, W0212, W0232
            def __new__(cls, raster, args):
                own = ctypes.c_int(0)
                ptr = raster._createDataPointer(raster, args, ctypes.byref(own))
                rows = args.row_end - args.row_start + 1
                cols = args.column_end - args.column_start + 1
                bands = args.band_end - args.band_start + 1
                nfo = DataInfo(raster)
                func = ctypes.pythonapi.PyBuffer_FromMemory
                func.restype = ctypes.py_object
                datalen = rows * cols * bands * nfo.encoding_size
                dbuffer = func(ptr, datalen)
                if nfo.interleave.value == Interleave.BIP:
                    shape = (rows, cols, bands)
                elif nfo.interleave.value == Interleave.BSQ:
                    shape = (bands, rows, cols)
                elif nfo.interleave.value == Interleave.BIL:
                    shape = (rows, bands, cols)
                ntype = nfo.encoding.to_numpy_type()
                self = numpy.ndarray.__new__(cls, shape,
                                             dtype=ntype,
                                             buffer=dbuffer,
                                             offset=0, order='C')
                self._rasterhandle = dbuffer
                self._rasterptr = ptr
                self._ownraster = own
                self.interleave = nfo.interleave
                return self
            def __array_finalize__(self, obj):
                if hasattr(obj, '_rasterhandle'):
                    self._rasterhandle = obj._rasterhandle
                    self._rasterptr = obj._rasterptr
                    self._ownraster = obj._ownraster
                    self.interleave = obj.interleave
                else:
                    self._rasterhandle = None
                    self._rasterptr = None
                    self._ownraster = False
                    self.interleave = None
            def _close(self):
                """Release shared memory.  Only do this 
                when deleting the object.

                """
                if self.base is self._rasterhandle and self._ownraster:
                    tempf = _genwrap("destroyDataPointer", None,
                                     ctypes.c_void_p, errorCheck=False)
                    tempf(self._rasterptr)
                    self._rasterhandle = None
                    self._rasterptr = None
                    self._ownraster = False
                    self.interleave = None
            def __del__(self):
                # We first check if we are the owner of
                # the _rasterptr, rather than
                # a view, so deleting a view does not call _close
                # on the parent _rasterptr
                if self._rasterhandle is self.base:
                    self._close()
        _RASTER_BLOCK_TYPE = RasterBlock
    except ImportError:
        pass

try:
    #pylint: disable=C0103
    #try on first import to define RasterBlock type
    #if numpy can be imported
    import numpy
    _create_raster_block()
    RasterBlock = _RASTER_BLOCK_TYPE
except ImportError:
    pass

class _DataArrayTemp(object):
    def __init__(self, raster, fixed):
        self.raster = raster
        self.fixed = fixed

    def __getitem__(self, key):
        try:
            #pylint: disable=W0612, W0621
            import numpy
            if _RASTER_BLOCK_TYPE is None:
                _create_raster_block()
        except ImportError:
            raise NotImplementedError("numpy is not available")
        args = None
        nfo  = DataInfo(self.raster)
        if self.fixed:
            idx = self.parse_indices(key,
                                     (nfo.bands - 1,
                                      nfo.columns - 1,
                                      nfo.rows - 1))
            args = DataPointerArgs(idx[2][0], idx[2][1],
                                  idx[1][0], idx[1][1],
                                  idx[0][0], idx[0][1],
                                  nfo.interleave)
        elif nfo.interleave.value == Interleave.BIP:
            idx = self.parse_indices(key,
                                     (nfo.rows - 1,
                                      nfo.columns - 1,
                                      nfo.bands - 1))
            args = DataPointerArgs(idx[0][0], idx[0][1],
                                  idx[1][0], idx[1][1],
                                  idx[2][0], idx[2][1],
                                  nfo.interleave)
        elif nfo.interleave.value == Interleave.BSQ:
            idx = self.parse_indices(key,
                                     (nfo.bands - 1,
                                      nfo.rows - 1,
                                      nfo.columns - 1))
            args = DataPointerArgs(idx[1][0], idx[1][1],
                                  idx[2][0], idx[2][1],
                                  idx[0][0], idx[0][1],
                                  nfo.interleave)
        elif nfo.interleave.value == Interleave.BIL:
            idx = self.parse_indices(key,
                                     (nfo.rows - 1,
                                      nfo.bands - 1,
                                      nfo.columns - 1))
            args = DataPointerArgs(idx[0][0], idx[0][1],
                                  idx[2][0], idx[2][1],
                                  idx[1][0], idx[1][1],
                                  nfo.interleave)
        if idx[0][2] != 1 or idx[1][2] != 1 or idx[2][2] != 1:
            raise IndexError("Step factors other than 1 not supported")
        return _RASTER_BLOCK_TYPE(self.raster, args)

    def __setitem__(self, key, data):
        #pylint: disable=W0212, W0612, W0621
        try:
            import numpy
        except ImportError:
            # numpy wrapper will not be available
            raise NotImplementedError("numpy is not available")
        nfo  = DataInfo(self.raster)
        if not isinstance(data, numpy.ndarray):
            raise TypeError("Invalid data type, must be "\
                            "numpy.ndarray or ctypes.c_void_p")
        if nfo.encoding.to_numpy_type() != str(data.dtype):
            raise ValueError("Array has wrong dtype.")

        args = None
        if self.fixed:
            idx = self.parse_indices(key,
                                     (nfo.bands - 1,
                                      nfo.columns - 1,
                                      nfo.rows - 1))
            args = DataPointerArgs(idx[2][0], idx[2][1],
                                  idx[1][0], idx[1][1],
                                  idx[0][0], idx[0][1],
                                  nfo.interleave)
        elif nfo.interleave.value == Interleave.BIP:
            idx = self.parse_indices(key,
                                     (nfo.rows - 1,
                                      nfo.columns - 1,
                                      nfo.bands - 1))
            args = DataPointerArgs(idx[0][0], idx[0][1],
                                  idx[1][0], idx[1][1],
                                  idx[2][0], idx[2][1],
                                  nfo.interleave)
        elif nfo.interleave.value == Interleave.BSQ:
            idx = self.parse_indices(key,
                                     (nfo.bands - 1,
                                      nfo.rows - 1,
                                      nfo.columns - 1))
            args = DataPointerArgs(idx[1][0], idx[1][1],
                                  idx[2][0], idx[2][1],
                                  idx[0][0], idx[0][1],
                                  nfo.interleave)
        elif nfo.interleave.value == Interleave.BIL:
            idx = self.parse_indices(key,
                                     (nfo.rows - 1,
                                      nfo.bands - 1,
                                      nfo.columns - 1))
            args = DataPointerArgs(idx[0][0], idx[0][1],
                                  idx[2][0], idx[2][1],
                                  idx[1][0], idx[1][1],
                                  nfo.interleave)
        if idx[0][2] != 1 or idx[1][2] != 1 or idx[2][2] != 1:
            raise IndexError("Step factors other than 1 not supported")
        required_size = ((args.row_end - args.row_start + 1) *
                         (args.column_end - args.column_start + 1) *
                         (args.band_end - args.band_start + 1))
        if required_size != data.size:
            raise ValueError("Array has %s items, but must " \
                             "have %s items" % (data.size, required_size))

        rawdata = data.ctypes.data_as(ctypes.c_void_p)
        RasterElement._copyDataToRasterElement(self.raster, args, rawdata)

    @staticmethod
    def parse_indices(key, dims):
        key_t = None
        try:
            iter(key)
            key_t = list(key)
        except TypeError:
            key_t = list()
            key_t.append(key)
        if len(key_t) > len(dims):
            raise IndexError("Too many indicies provided, " \
                             "only %s allowed" % (len(dims)))
        ellipsis_index = None
        for index in xrange(len(key_t)):
            if key_t[index] is Ellipsis:
                if ellipsis_index is not None:
                    raise IndexError("Ellipsis (...) can only be used once")
                ellipsis_index = index
            elif not isinstance(key_t[index], slice):
                key_t[index] = slice(key_t[index], key_t[index])
        if ellipsis_index is not None:
            #pylint: disable=W0612
            key_t[ellipsis_index] = slice(0, None, None)
            prepend = []
            if ellipsis_index > 0:
                prepend = key_t[:ellipsis_index]
            append = []
            if ellipsis_index < (len(key_t) - 1):
                append = key_t[ellipsis_index + 1:]
            key_t = (prepend +
                     [slice(0, None, None)
                      for x in xrange(len(dims) - len(key_t) + 1)] +
                     append)
        if len(key_t) < len(dims):
            key_t = key_t[:] + [slice(0, None, None)
                                for x in xrange(len(dims) - len(key_t))]
        key_t = [key_t[index].indices(dims[index])
                 for index in xrange(len(key_t))]

        return key_t

class RasterElement(DataElement):
    "A raster element."
    _createDataPointer = \
        _genwrap("createDataPointer", ctypes.c_void_p, DataElement,
                 ctypes.POINTER(DataPointerArgs),
                 ctypes.POINTER(ctypes.c_int))
    _createDataAccessor = \
        _genwrap("createDataAccessor", DataAccessor, DataElement,
                 ctypes.POINTER(DataAccessorArgs))
    _updateRasterElement = _genwrap("updateRasterElement", None, DataElement)
    _copyDataToRasterElement = \
        _genwrap("copyDataToRasterElement", ctypes.c_int,
                 DataElement, ctypes.POINTER(DataPointerArgs),
                 ctypes.c_void_p)

    def __init__(self, name, element=None):
        """Get a raster element.
        If name is specified, get the named raster.
        If element is specified, use an existing DataElement.

        """
        assert(name is not None or element is not None)
        assert(not (name is not None and element is not None))
        if element is not None:
            handle = element.handle
        else:
            handle = self._getDataElement(name, "RasterElement", int(0)).handle
        DataElement.__init__(self, None, wrapper=handle)
        self.data_info = DataInfo(self)

    @classmethod
    def create2d(cls, name, numpy_array,
                 location=ProcessingLocationPreference.PREFER_RAM,
                 parent=None,
                 bad_values=None):
        #pylint: disable=R0913, R0914, W0621
        try:
            import numpy
        except ImportError:
            raise NotImplementedError("numpy is not available")

        if isinstance(numpy_array, numpy.ndarray):
            if len(numpy_array.shape) != 2:
                raise ValueError("numpy_array argument must " \
                                 "have a len(.shape) of 2")
            encoding = Encoding.from_numpy_type(numpy_array.dtype)
            args = RasterElementArgs(numpy_array.shape[0],
                                     numpy_array.shape[1],
                                     1,
                                     Interleave.BSQ,
                                     encoding,
                                     location)
            if parent is not None:
                #pylint: disable=W0201
                args.parent = parent
            if bad_values is not None:
                args.bad_values = bad_values
            tempf = _genwrap("createRasterElement", DataElement,
                             ctypes.c_char_p, RasterElementArgs)
            elem = tempf(name, args)
            relem = RasterElement(None, element=elem)
            relem.data_array[...] = numpy_array
            return relem
        else:
            raise ValueError("numpy_array argument is not an " \
                             "instance of numpy.ndarray")

    @classmethod
    def create3d(cls, name, numpy_array,
                 interleave=None,
                 location=ProcessingLocationPreference.PREFER_RAM,
                 parent=None,
                 bad_values=None):
        #pylint: disable=R0913, R0914, W0201, W0621
        try:
            import numpy
        except ImportError:
            raise NotImplementedError("numpy is not available")

        if isinstance(numpy_array, numpy.ndarray):
            if len(numpy_array.shape) != 3:
                raise ValueError("numpy_array argument must "\
                                 "have a len(.shape) of 3")
            encoding = Encoding.from_numpy_type(numpy_array.dtype)
            use_interleave = interleave
            if interleave is None and hasattr(numpy_array, "interleave"):
                if isinstance(numpy_array.interleave, Interleave):
                    use_interleave = numpy_array.interleave
            args = RasterElementArgs(interleave=use_interleave,
                                     encoding=encoding,
                                     location=location)
            if args.interleave.value == Interleave.BIP:
                rows = numpy_array.shape[0]
                cols = numpy_array.shape[1]
                bands = numpy_array.shape[2]
            elif args.interleave.value == Interleave.BSQ:
                rows = numpy_array.shape[1]
                cols = numpy_array.shape[2]
                bands = numpy_array.shape[0]
            elif args.interleave.value == Interleave.BIL:
                rows = numpy_array.shape[0]
                cols = numpy_array.shape[2]
                bands = numpy_array.shape[1]
            else:
                raise ValueError("interleave argument must be " \
                                 "of type opticks.Interleave")
            args.rows = rows
            args.columns = cols
            args.bands = bands
            if parent is not None:
                #pylint: disable=W0201
                args.parent = parent
            if bad_values is not None:
                args.bad_values = bad_values
            tempf = _genwrap("createRasterElement", DataElement,
                             ctypes.c_char_p, RasterElementArgs)
            elem = tempf(name, args)
            relem = RasterElement(None, element=elem)
            relem.data_array[...] = numpy_array
            return relem
        else:
            raise ValueError("numpy_array argument is not " \
                             "an instance of numpy.ndarray")

    @classmethod
    def create3d_empty(cls, name, rows, columns, bands,
                       interleave=Interleave.BIP,
                       encoding=Encoding.INT4SBYTES,
                       location=ProcessingLocationPreference.PREFER_RAM,
                       parent=None,
                       bad_values=None):
        #pylint: disable=R0913
        args = RasterElementArgs(rows, columns, bands,
                                 interleave, encoding,
                                 location)
        if parent is not None:
            #pylint: disable=W0201
            args.parent = parent
        if bad_values is not None:
            args.bad_values = bad_values
        tempf = _genwrap("createRasterElement", DataElement,
                         ctypes.c_char_p, RasterElementArgs)
        elem = tempf(name, args)
        return RasterElement(None, element=elem)

    @property
    def info(self):
        return self.data_info

    @property
    def rows(self):
        return self.data_info.rows

    @property
    def columns(self):
        return self.data_info.columns

    @property
    def bands(self):
        return self.data_info.bands

    @property
    def interleave(self):
        return self.data_info.interleave

    @property
    def encoding(self):
        return self.data_info.encoding

    @property
    def encoding_size(self):
        return self.data_info.encoding_size

    def get_data_accessor(self, interleave=None,
                          bband=None, eband=None,
                          bcol=None, ecol=None,
                          brow=None, erow=None,
                          write=False,
                          cbands=None,
                          ccols=None,
                          crows=None):
        "Create a DataAccessor for this raster element."
        #pylint: disable=R0912, R0913, R0914, R0915
        nfo = DataInfo(self)
        if (interleave is None and bband is None and eband is None and
            bcol is None and ecol is None and brow is None and erow is None and
            write == False and cbands is None and ccols is None and
            crows is None):
            acc = self._createDataAccessor(self, None)
            acc._DataAccessor__owns = True
            acc._DataAccessor__encoding = nfo.encoding.to_ctype()
            col_count, writable = nfo.columns, False
            acc.initialize(True, nfo.encoding.to_ctype(), col_count, writable)
            return acc
        if interleave is None:
            interleave = nfo.interleave
        if bband is None:
            bband = 0
        elif bband < 0:
            bband = nfo.bands + bband
        if bcol is None:
            bcol = 0
        elif bcol < 0:
            bcol = nfo.columns + bcol
        if brow is None:
            brow = 0
        elif brow < 0:
            brow = nfo.rows + brow
        if eband is None:
            eband = nfo.bands - 1
        elif eband < 0:
            eband = nfo.bands + eband
        if ecol is None:
            ecol = nfo.columns - 1
        elif ecol < 0:
            ecol = nfo.columns + ecol
        if erow is None:
            erow = nfo.rows - 1
        elif erow < 0:
            erow = nfo.rows + erow
        if bband < 0:
            bband = 0
        if bcol < 0:
            bcol = 0
        if brow < 0:
            brow = 0
        if eband >= nfo.bands:
            eband = nfo.bands - 1
        if ecol >= nfo.columns:
            ecol = nfo.columns - 1
        if erow >= nfo.rows:
            erow = nfo.rows - 1
        if eband < bband:
            eband = bband
        if ecol < bcol:
            ecol = bcol
        if erow < brow:
            erow = brow
        if cbands is None:
            cbands = 0
        if ccols is None:
            ccols = 0
        if crows is None:
            crows = 0
        args = DataAccessorArgs(brow, erow, crows,
                                bcol, ecol, ccols,
                                bband, eband, cbands,
                                interleave, write)
        acc = self._createDataAccessor(self, ctypes.byref(args))
        acc._DataAccessor__owns = True
        acc._DataAccessor__encoding = nfo.encoding.to_ctype()
        acc.initialize(True, nfo.encoding.to_ctype(),
                       args.column_end - args.column_start + 1,
                       args.writable)
        return acc

    def update(self):
        self._updateRasterElement(self)

    def get_data_pointer(self, brow=None, erow=None,
                         bcol=None, ecol=None,
                         bband=None, eband=None,
                         interleave=None):
        """Create a data pointer to an element with optional DataPointerArgs.
        Returns the ctypes data pointer and an ownership variable.
        If the second return value is True, the caller must call
        destroyDataPointer() with the first return value. When done
        with the data, the caller must delete the deleter object (with
        del or by removing that last reference) in order to clean up
        allocated memory. If the memory is shared, the second return
        value will be None.

        """
        #pylint: disable=R0912, R0913, R0914, R0915
        nfo = DataInfo(self)
        if interleave is None:
            interleave = nfo.interleave
        if bband is None:
            bband = 0
        elif bband < 0:
            bband = nfo.bands + bband
        if bcol is None:
            bcol = 0
        elif bcol < 0:
            bcol = nfo.columns + bcol
        if brow is None:
            brow = 0
        elif brow < 0:
            brow = nfo.rows + brow
        if eband is None:
            eband = nfo.bands - 1
        elif eband < 0:
            eband = nfo.bands + eband
        if ecol is None:
            ecol = nfo.columns - 1
        elif ecol < 0:
            ecol = nfo.columns + ecol
        if erow is None:
            erow = nfo.rows - 1
        elif erow < 0:
            erow = nfo.rows + erow
        if bband < 0:
            bband = 0
        if bcol < 0:
            bcol = 0
        if brow < 0:
            brow = 0
        if eband >= nfo.bands:
            eband = nfo.bands - 1
        if ecol >= nfo.columns:
            ecol = nfo.columns - 1
        if erow >= nfo.rows:
            erow = nfo.rows - 1
        if eband < bband:
            eband = bband
        if ecol < bcol:
            ecol = bcol
        if erow < brow:
            erow = brow
        args = DataPointerArgs(brow, erow, bcol, ecol, bband, eband,
                                 interleave)
        own, deleter = ctypes.c_int(0), None
        ptr = self._createDataPointer(self, args, ctypes.byref(own))
        func = ctypes.pythonapi.PyBuffer_FromMemory
        func.restype = ctypes.py_object
        datalen = ((erow - brow + 1) * (ecol - bcol + 1) *
                   (eband - bband + 1) * nfo.encoding_size)
        dbuffer = func(ptr, datalen)
        if own:
            class DeleterObj(object):
                def __init__(self, ptr):
                    self.__ptr = ptr
                def __del__(self):
                    tempf = _genwrap("destroyDataPointer", None,
                                     ctypes.c_void_p, errorCheck=False)
                    tempf(self.__ptr)
            deleter = DeleterObj(ptr)
        return dbuffer, deleter

    @property
    def data_array(self):
        return _DataArrayTemp(self, False)

    @property
    def data_array_f(self):
        return _DataArrayTemp(self, True)

    def set_data_pointer(self, data, brow=None, erow=None,
                         bcol=None, ecol=None,
                         bband=None, eband=None,
                         interleave=None):
        """Copy data to a RasterElement with optional DataPointerArgs.
        Data must be a ctypes.c_void_p. The caller should call
        update() when this is complete to redisplay the data.

        """
        #pylint: disable=R0912, R0913, R0914, R0915
        nfo = DataInfo(self)
        if interleave is None:
            interleave = nfo.interleave
        if bband is None:
            bband = 0
        elif bband < 0:
            bband = nfo.bands + bband
        if bcol is None:
            bcol = 0
        elif bcol < 0:
            bcol = nfo.columns + bcol
        if brow is None:
            brow = 0
        elif brow < 0:
            brow = nfo.rows + brow
        if eband is None:
            eband = nfo.bands - 1
        elif eband < 0:
            eband = nfo.bands + eband
        if ecol is None:
            ecol = nfo.columns - 1
        elif ecol < 0:
            ecol = nfo.columns + ecol
        if erow is None:
            erow = nfo.rows - 1
        elif erow < 0:
            erow = nfo.rows + erow
        if bband < 0:
            bband = 0
        if bcol < 0:
            bcol = 0
        if brow < 0:
            brow = 0
        if eband >= nfo.bands:
            eband = nfo.bands - 1
        if ecol >= nfo.columns:
            ecol = nfo.columns - 1
        if erow >= nfo.rows:
            erow = nfo.rows - 1
        if eband < bband:
            eband = bband
        if ecol < bcol:
            ecol = bcol
        if erow < brow:
            erow = brow
        args = DataPointerArgs(brow, erow, bcol, ecol, bband, eband,
                                 interleave)
        is_read_buffer = ctypes.pythonapi.PyObject_CheckReadBuffer
        data_obj = ctypes.py_object(data)
        if is_read_buffer(data_obj):
            data_void_p = ctypes.c_void_p()
            data_len = ctypes.c_int64() #this should be 32-bit on 32-bit
                                        #systems and 64-bit on 64-bit systems
            get_read_buf = ctypes.pythonapi.PyObject_AsReadBuffer
            if get_read_buf(data_obj, ctypes.byref(data_void_p),
                            ctypes.byref(data_len)) != 0:
                raise TypeError("Cannot get data inside read buffer")
            required_data_size = ((erow - brow + 1) * (ecol - bcol + 1) *
                (eband - bband + 1) * nfo.encoding_size)
            if required_data_size != data_len.value:
                raise ValueError("Buffer provided has %s bytes " \
                                 "but must have %s bytes" \
                                 % (data_len.value, required_data_size))
        else:
            data_void_p = data
        self._copyDataToRasterElement(self, args, data_void_p)

class Signature(DataElement):
    "A signature data type."
    #pylint: disable=R0921
    _getSignatureDataSetCount = \
        _genwrap("getSignatureDataSetCount", ctypes.c_uint32, DataElement)
    _getSignatureDataSetName = \
        _genwrap("getSignatureDataSetName", ctypes.c_uint32,
                 DataElement, ctypes.c_uint32, ctypes.c_char_p,
                 ctypes.c_uint32)
    _getSignatureDataSet = \
        _genwrap("getSignatureDataSet", DataVariant, DataElement,
                 ctypes.c_char_p)
    _setSignatureDataSet = \
        _genwrap("setSignatureDataSet", ctypes.c_int, DataElement,
                 ctypes.c_char_p, DataVariant)

    def __init__(self, name, element=None):
        """Get a signature.
        If name is specified, get the named signature.
        If element is specified, use an existing DataElement.

        """
        assert(name is not None or element is not None)
        assert(not (name is not None and element is not None))
        if element is not None:
            handle = element.handle
        else:
            handle = self._getDataElement(name, "Signature", int(0)).handle
        DataElement.__init__(self, None, wrapper=handle)

    @classmethod
    def create(cls, name):
        found = False
        try:
            cls._getDataElement(name, "Signature", int(0))
            #if above doesn't throw, then element already exists
            found = True
        except SimpleApiError:
            #didn't exist, so we can create
            pass
        if found:
            raise SimpleApiError(SimpleApiError.SIMPLE_EXISTS)
        elem = cls._getDataElement(name, "Signature", int(1))
        return Signature(None, element=elem)

    def keys(self):
        k = []
        for idx in range(self._getSignatureDataSetCount(self)):
            k.append(_stringbuffer_wrap(self._getSignatureDataSetName,
                                        self, idx))
        return k

    def __getitem__(self, key):
        return self._getSignatureDataSet(self, key)

    def __setitem__(self, key, value):
        if not isinstance(value, DataVariant):
            value = DataVariant(value)
        self._setSignatureDataSet(self, key, value)

    def __delitem__(self, key):
        raise NotImplementedError()

class SignatureSet(DataElement):
    "A signature set data type."
    _getSignatureSetCount = \
        _genwrap("getSignatureSetCount", ctypes.c_uint32, DataElement)
    _getSignatureSetSignature = \
        _genwrap("getSignatureSetSignature", DataElement,
                 DataElement, ctypes.c_uint32)

    def __init__(self, name, element=None):
        """Get a signature set.
        If name is specified, get the named signature set.
        If element is specified, use an existing DataElement.

        """
        assert(name is not None or element is not None)
        assert(not (name is not None and element is not None))
        if element is not None:
            handle = element.handle
        else:
            handle = self._getDataElement(name, "SignatureSet", int(0)).handle
        DataElement.__init__(self, None, wrapper=handle)

    @classmethod
    def create(cls, name):
        found = False
        try:
            cls._getDataElement(name, "SignatureSet", int(0))
            #if above doesn't throw, then element already exists
            found = True
        except SimpleApiError:
            #didn't exist, so we can create
            pass
        if found:
            raise SimpleApiError(SimpleApiError.SIMPLE_EXISTS)
        elem = cls._getDataElement(name, "SignatureSet", int(1))
        return SignatureSet(None, element=elem)

    def __len__(self):
        return int(self._getSignatureSetCount(self))

    def __getitem__(self, index):
        if index >= len(self):
            raise IndexError()
        return Signature(element=self._getSignatureSetSignature(self, index))

# important IEEE-754 contant
NAN = 1e30000/1e30000 # overflow to cause Inf then divide to cause NaN

class Layer(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, name=None, typ=None, other=None):
        """Get a Layer by name.
        The name may be a session ID or a layer specification.
        See the Simple API module in the main developer documentation
        for more information on layer specifications. In summary, a
        layer specification is two parts, both optional:
        viewName|layerName where the default view is the active
        view and the default layer depends on a number of factors and
        is detailed in the main developer documentation.
        If typ is None, access any layer type. Otherwise, access only
        layers of the type specified.
        If other is specified the internal handle for that Layer
        will be copied to the new Layer. This is generally an
        internal usage.

        """
        ctypes.Structure.__init__(self)
        if other is not None:
            assert(name is None and typ is None and isinstance(other, Layer))
            self.handle = other.handle
        else:
            tempf = _genwrap("getLayer", Layer, ctypes.c_char_p,
                             ctypes.c_char_p)
            self.handle = tempf(name, typ).handle
        self.__owns = False

    def __del__(self):
        if self.__owns:
            _genwrap("destroyLayer", None, Layer, errorCheck=False)(self)

    def destroy(self, val=True):
        """Mark this layer for destruction. When the layer object
        is garbage collected it will be removed from the view
        and destroyed. If val is False, destruction
        will be cancelled.

        """
        self.__owns = val

    def leafclass(self):
        layer = self
        typ = self.type
        if typ == "RasterLayer":
            layer = RasterLayer(other=layer)
        elif typ == "ThresholdLayer":
            layer = ThresholdLayer(other=layer)
        elif typ == "PseudocolorLayer":
            layer = PseudocolorLayer(other=layer)
        return layer

    @property
    def name(self):
        return _stringbuffer_wrap(self._getLayerName, self)

    @property
    def type(self):
        return _stringbuffer_wrap(self._getLayerType, self)

    @property
    def element(self):
        elem = self._getLayerElement(self)
        return elem.leafclass()

    @property
    def view(self):
        return self._getLayerView(self)

    def get_scale(self):
        x_scale, y_scale = ctypes.c_double(0.0), ctypes.c_double(0.0)
        self._getLayerScaleOffset(self, ctypes.byref(x_scale),
                                  ctypes.byref(y_scale), None, None)
        return x_scale.value, y_scale.value
    def set_scale(self, (x_scale, y_scale)):
        self._setLayerScaleOffset(self, x_scale, y_scale, NAN, NAN)
    scale = property(get_scale, set_scale, doc="The Layer scale factor.")

    def get_offset(self):
        x_offset, y_offset = ctypes.c_double(0.0), ctypes.c_double(0.0)
        self._getLayerScaleOffset(self, None, None,
                                  ctypes.byref(x_offset),
                                  ctypes.byref(y_offset))
        return x_offset.value, y_offset.value
    def set_offset(self, (x_offset, y_offset)):
        self._setLayerScaleOffset(self, NAN, NAN, x_offset, y_offset)
    offset = property(get_offset, set_offset, doc="The Layer offset in pixels.")

    def get_display_index(self):
        return self._getLayerDisplayIndex(self)
    def set_display_index(self, index):
        self._setLayerDisplayIndex(self, index)
    display_index = property(get_display_index,
                             set_display_index,
                             doc="Indicates the ordering in the layer stack.")

    def get_displayed(self):
        return bool(self._isLayerDisplayed(self))
    def set_displayed(self, value):
        if value:
            self._setLayerDisplayed(self, 1)
        else:
            self._setLayerDisplayed(self, 0)
    displayed = property(get_displayed, set_displayed)

    def derive(self, name=None, typ=None):
        """Derive a new layer or copy an existing layer.
        If typ is None, a copy of the layer will be created.
        name is the new layer's name. If name is None,
        the new layer will have the same name as the original layer.
        Returns a new Layer.

        """
        if typ is None:
            typ = self.type
        layer = Layer(other=self._deriveLayer(self, name, typ))
        return layer.leafclass()

    @classmethod
    def convert(cls, layer, typ=None):
        "Convert to a new layer type."
        #pylint: disable=W0212
        print str(cls)
        owns = layer.__owns
        layer.__owns = False
        if typ is None:
            clsname = cls.__name__
            if (clsname == "RasterLayer" or clsname == "ThresholdLayer" or
                clsname == "PseudocolorLayer"):
                typ = clsname
        assert(typ is not None)
        try:
            newlayer = Layer(other=cls._convertLayer(layer, typ))
        except SimpleApiError:
            layer.__owns = owns
            raise
        del layer
        layer = None
        return newlayer.leafclass()

    @property
    def active(self):
        return self._isLayerActive(self)

    def activate(self):
        self._activateLayer(self)

class View(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, name=None, wrapper=None):
        """Get a View by name.
        The name may be a session ID or a view name.

        """
        ctypes.Structure.__init__(self)
        if wrapper is None:
            tempf = _genwrap("getView", View, ctypes.c_char_p, ctypes.c_char_p)
            typ = "SpatialDataView"
            self.handle = tempf(name, typ).handle
        else:
            self.handle = wrapper
        self.__owns = False

    @classmethod
    def create(cls, name, element):
        """Create a new View of with name to display the
        provided RasterElement. If the view exists, an exception
        will be raised.

        """
        typ = "Spatial Data View"
        tempf = _genwrap("createView", View, ctypes.c_char_p,
                         ctypes.c_char_p, DataElement)
        newv = View(wrapper=tempf(name, typ, element).handle)
        return newv

    def __del__(self):
        if self.__owns:
            _genwrap("destroyView", None, View, errorCheck=False)(self)

    def destroy(self, val=True):
        """Mark this view for destruction. When the view object
        is garbage collected it will be destroyed. If val is False,
        destruction will be cancelled.

        """
        self.__owns = val

    def get_name(self):
        return _stringbuffer_wrap(self._getViewName, self)
    def set_name(self, name):
        self._setViewName(self, name)
    name = property(get_name, set_name)

    @property
    def type(self):
        return _stringbuffer_wrap(self._getViewType, self)

    @property
    def primary_element(self):
        return RasterElement(None,
                             element=self._getViewPrimaryRasterElement(self))

    def add_layer(self, element, typ, name=None):
        """Create a new typ layer to display element. The name of the Layer
        will be name. If name is None, the name of the element will be used.

        """
        tempf = _genwrap("createLayer", Layer, View,
                         DataElement, ctypes.c_char_p, ctypes.c_char_p)
        layer = tempf(self, element, typ, name)
        return layer.leafclass()

    def iter_layers(self):
        def do_iter(view):
            get_view_layer = _genwrap("getViewLayer", Layer,
                                      View, ctypes.c_uint32)
            idx = 0
            while True:
                try:
                    layer = get_view_layer(view, idx)
                    yield layer.leafclass()
                except SimpleApiError, err:
                    if err.code == SimpleApiError.SIMPLE_NOT_FOUND:
                        return
                    raise
                finally:
                    idx += 1
        return do_iter(self)

View._getViewName = \
    _genwrap("getViewName", ctypes.c_uint32, View, ctypes.c_char_p,
             ctypes.c_uint32)
View._setViewName = \
    _genwrap("setViewName", ctypes.c_int, View, ctypes.c_char_p)
View._getViewType = \
    _genwrap("getViewType", ctypes.c_uint32, View, ctypes.c_char_p,
             ctypes.c_uint32)
View._getViewPrimaryRasterElement = \
    _genwrap("getViewPrimaryRasterElement", DataElement, View)
Layer._getLayerName = \
    _genwrap("getLayerName", ctypes.c_uint32, Layer, ctypes.c_char_p,
             ctypes.c_uint32)
Layer._getLayerType = \
    _genwrap("getLayerType", ctypes.c_uint32, Layer, ctypes.c_char_p,
             ctypes.c_uint32)
Layer._getLayerElement = _genwrap("getLayerElement", DataElement, Layer)
Layer._getLayerView = _genwrap("getLayerView", View, Layer)
Layer._getLayerScaleOffset = \
    _genwrap("getLayerScaleOffset", ctypes.c_int, Layer,
             ctypes.POINTER(ctypes.c_double),
             ctypes.POINTER(ctypes.c_double),
             ctypes.POINTER(ctypes.c_double),
             ctypes.POINTER(ctypes.c_double))
Layer._setLayerScaleOffset = \
    _genwrap("setLayerScaleOffset", ctypes.c_int, Layer,
             ctypes.c_double, ctypes.c_double, ctypes.c_double,
             ctypes.c_double)
Layer._isLayerDisplayed = _genwrap("isLayerDisplayed", ctypes.c_int, Layer)
Layer._setLayerDisplayed = \
    _genwrap("setLayerDisplayed", ctypes.c_int, Layer, ctypes.c_int)
Layer._getLayerDisplayIndex = \
    _genwrap("getLayerDisplayIndex", ctypes.c_uint32, Layer)
Layer._setLayerDisplayIndex = \
    _genwrap("setLayerDisplayIndex", ctypes.c_int, Layer, ctypes.c_uint32)
Layer._deriveLayer = \
    _genwrap("deriveLayer", Layer, Layer, ctypes.c_char_p,
             ctypes.c_char_p)
Layer._convertLayer = _genwrap("convertLayer", Layer, Layer, ctypes.c_char_p)
Layer._isLayerActive = _genwrap("isLayerActive", ctypes.c_int, Layer)
Layer._activateLayer = _genwrap("activateLayer", ctypes.c_int, Layer)

class PassArea(ctypes.c_uint32):
    "Opticks PassAreaEnum type."
    LOWER = 0
    UPPER = 1
    MIDDLE = 2
    OUTSIDE = 3

    def __repr__(self):
        strname = "Unknown"
        if self.value == self.LOWER:
            strname = "Below 1st threshold"
        elif self.value == self.UPPER:
            strname = "Above 1st threshold"
        elif self.value == self.MIDDLE:
            strname = "Between 1st and 2nd thresholds"
        elif self.value == self.OUTSIDE:
            strname = "Outside 1st and 2nd thresholds"
        return "<PassArea: %s>" % strname

class RegionUnits(ctypes.c_uint32):
    "Opticks RegionUnitsEnum type."
    RAW_VALUE = 0
    PERCENTAGE = 1
    PERCENTILE = 2
    STD_DEV = 3

    def __repr__(self):
        strname = "Unknown"
        if self.value == self.RAW_VALUE:
            strname = "Raw value"
        elif self.value == self.PERCENTAGE:
            strname = "Percentage"
        elif self.value == self.PERCENTILE:
            strname = "Percentile"
        elif self.value == self.STD_DEV:
            strname = "Standard deviation"
        return "<RegionUnits: %s>" % strname

class Stretch(ctypes.c_uint32):
    "Opticks StretchTypeEnum type."
    LINEAR = 0
    LOGARITHMIC = 1
    EXPONENTIAL = 2
    EQUALIZE = 3

    def __repr__(self):
        strname = "Unknown"
        if self.value == self.LINEAR:
            strname = "Linear"
        elif self.value == self.LOGARITHMIC:
            strname = "Logarithmic"
        elif self.value == self.EXPONENTIAL:
            strname = "Exponential"
        elif self.value == self.EQUALIZE:
            strname = "Histogram Equalization"
        return "<Stretch: %s>" % strname

class Color(object):
    "Opticks Color type"

    def __init__(self, value=None, red=0, green=0, blue=0, alpha=255):
        #pylint: disable=R0913
        if value is None:
            self.red = red
            self.green = green
            self.blue = blue
            self.alpha = alpha
        elif isinstance(value, Color):
            # copy constructor
            self.red = value.red
            self.green = value.green
            self.blue = value.blue
            self.alpha = value.alpha
        elif isinstance(value, str):
            if len(value) == 9 and value[0] == '#':
                self.red = int(value[1:3], 16)
                self.green = int(value[3:5], 16)
                self.blue = int(value[5:7], 16)
                self.alpha = int(value[7:9], 16)
            else:
                raise TypeError("Color initialation must be an " \
                                "encoded int, '#RRGGBBAA', " \
                                "'(red, green, blue)', " \
                                "'(red, green, blue, alpha)', " \
                                "or 'red=0, green=0, blue=0, alpha=255'")
        elif isinstance(value, tuple) and (len(value) == 3 or len(value) == 4):
            if len(value) == 3:
                value = value + (alpha, )
            self.red, self.green, self.blue, self.alpha = value
        elif isinstance(value, int) or isinstance(value, long):
            self.red = (value >> 24) & 0xff
            self.green = (value >> 16) & 0xff
            self.blue = (value >> 8) & 0xff
            self.alpha = value & 0xff
        else:
            raise TypeError("Color initialation must be an encoded int, " \
                            "'#RRGGBBAA', '(red, green, blue)', " \
                            "'(red, green, blue, alpha)', or " \
                            "'red=0, green=0, blue=0, alpha=255'")

    def __eq__(self, other):
        return (self.red == other.red and
                self.green == other.green and
                self.blue == other.blue and
                self.alpha == other.alpha)

    @property
    def value(self):
        return ((self.red << 24) | (self.green << 16) |
                (self.blue << 8) | self.alpha)

    def __repr__(self):
        return ('#%02X%02X%02X%02X' %
                (self.red, self.green, self.blue, self.alpha))

class RasterChannel(ctypes.c_uint32):
    "Opticks RasterChannelEnum type."
    GRAY = 0
    RED = 1
    GREEN = 2
    BLUE = 3

    def __repr__(self):
        strname = "Unknown"
        if self.value == self.GRAY:
            strname = "gray/colormap/indexed"
        elif self.value == self.RED:
            strname = "red"
        elif self.value == self.GREEN:
            strname = "green"
        elif self.value == self.BLUE:
            strname = "blue"
        return "<RasterChannel: %s>" % strname

class ComplexComponent(ctypes.c_uint32):
    "Opticks ComplexComponentEnum type."
    MAGNITUDE = 0
    PHASE = 1
    INPHASE = 2
    QUADRATURE = 3

    def __repr__(self):
        strname = "Unknown"
        if self.value == self.MAGNITUDE:
            strname = "magnitude"
        elif self.value == self.PHASE:
            strname = "phase"
        elif self.value == self.INPHASE:
            strname = "in-phase"
        elif self.value == self.QUADRATURE:
            strname = "quadrature"
        return "<ComplexComponent: %s>" % strname

class ThresholdLayer(Layer):
    "A Threshold layer."

    class Info(ctypes.Structure):
        _fields_ = [('first_threshold', ctypes.c_double),
                    ('second_threshold', ctypes.c_double),
                    ('pass_area', PassArea),
                    ('units', RegionUnits)]

        def __repr__(self):
            return ("<ThresholdInfo: %f - %f %r %r>" %
                    (self.first_threshold, self.second_threshold,
                     self.pass_area, self.units))

    def __init__(self, name=None, other=None):
        """Get a Threshold Layer by name.
        See Layer documentation for information on values for name.
        If other is specified the internal handle for that Layer will
        be copied to the new Layer. The typ value for the Layer
        contructor will be 'ThresholdLayer'.
        Other may be a Layer object which will be cast to a ThresholdLayer.

        """
        if other is not None:
            if not isinstance(other, Layer) or other.type != 'ThresholdLayer':
                raise TypeError("Layer is not a ThresholdLayer.")
            Layer.__init__(self, other=other)
        else:
            Layer.__init__(self, name=name, typ='ThresholdLayer')

    @classmethod
    def create(cls, name, element, view=None):
        if view is None:
            view = View()
        tempf = _genwrap("createLayer", Layer, View,
                         RasterElement, ctypes.c_char_p, ctypes.c_char_p)
        layer = tempf(view, element, "ThresholdLayer", name)
        return layer.leafclass()

    @classmethod
    def create_from(cls, name, layer):
        return layer.derive(name, "ThresholdLayer")

    def get_info(self):
        info = ThresholdLayer.Info()
        tempf = _genwrap('getThresholdLayerInfo', ctypes.c_int,
                         Layer, ctypes.POINTER(ThresholdLayer.Info))
        tempf(self, ctypes.byref(info))
        return info
    def set_info(self, info):
        assert(isinstance(info, ThresholdLayer.Info))
        tempf = _genwrap('setThresholdLayerInfo', ctypes.c_int,
                         Layer, ctypes.POINTER(ThresholdLayer.Info))
        tempf(self, ctypes.byref(info))
    info = property(get_info, set_info, doc="Threshold parameters.")

    def get_thresholds(self):
        info = self.info
        return info.first_threshold, info.second_threshold
    def set_thresholds(self, (first, second)):
        info = self.info
        info.first_threshold, info.second_threshold = first, second
        self.info = info
    thresholds = property(get_thresholds,
                          set_thresholds,
                          doc="First and second thresholds")

    def get_pass_area(self):
        return self.info.pass_area
    def set_pass_area(self, value):
        info = self.info
        info.pass_area = value
        self.info = info
    pass_area = property(get_pass_area, set_pass_area, doc="Pass area enum")

    def get_units(self):
        return self.info.units
    def set_units(self, value):
        info = self.info
        info.units = value
        self.info = info
    units = property(get_units, set_units, doc="Region units enum")

class PseudocolorClass(object):
    "A pseudocolor class."

    _getPseudocolorClassName = \
        _genwrap("getPseudocolorClassName", ctypes.c_uint32,
                 Layer, ctypes.c_int32, ctypes.c_char_p, ctypes.c_uint32)
    _getPseudocolorClassValue = \
        _genwrap("getPseudocolorClassValue", ctypes.c_int32,
                 Layer, ctypes.c_int32)
    _getPseudocolorClassColor = \
        _genwrap("getPseudocolorClassColor", ctypes.c_uint32,
                 Layer, ctypes.c_int32)
    _isPseudocolorClassDisplayed = \
        _genwrap("isPseudocolorClassDisplayed", ctypes.c_int, Layer,
                 ctypes.c_int32)
    _setPseudocolorClassName = \
        _genwrap("setPseudocolorClassName", ctypes.c_int, Layer,
                 ctypes.c_int32, ctypes.c_char_p)
    _setPseudocolorClassValue = \
        _genwrap("setPseudocolorClassValue", ctypes.c_int, Layer,
                 ctypes.c_int32, ctypes.c_int32)
    _setPseudocolorClassColor = \
        _genwrap("setPseudocolorClassColor", ctypes.c_int, Layer,
                 ctypes.c_int32, ctypes.c_uint32)
    _setPseudocolorClassDisplayed = \
        _genwrap("setPseudocolorClassDisplayed", ctypes.c_int,
                 Layer, ctypes.c_int32, ctypes.c_int)

    def __init__(self, layer, class_id):
        self.__layer, self.__id = layer, class_id

    def __repr__(self):
        if self.displayed:
            return ("<PseudocolorClass '%s' %i displayed as %s>" %
                    (self.name, self.value, self.color))
        return ("<PseudocolorClass '%s' %i hidden with color %s>" %
                (self.name, self.value, self.color))

    def get_name(self):
        return _stringbuffer_wrap(self._getPseudocolorClassName,
                                  self.__layer, self.__id)
    def set_name(self, name):
        self._setPseudocolorClassName(self.__layer, self.__id, name)
    name = property(get_name, set_name, doc="The pseudocolor class name.")

    def get_value(self):
        return self._getPseudocolorClassValue(self.__layer, self.__id)
    def set_value(self, value):
        self._setPseudocolorClassValue(self.__layer, self.__id, value)
    value = property(get_value, set_value, doc="The pseudocolor class value.")

    def get_color(self):
        return Color(self._getPseudocolorClassColor(self.__layer, self.__id))
    def set_color(self, color):
        if not isinstance(color, Color):
            color = Color(color)
        self._setPseudocolorClassColor(self.__layer, self.__id, color.value)
    color = property(get_color, set_color, doc="The pseudocolor class color.")

    def get_displayed(self):
        return bool(self._isPseudocolorClassDisplayed(self.__layer, self.__id))
    def set_displayed(self, value):
        self._setPseudocolorClassDisplayed(self.__layer, self.__id, value)
    displayed = property(get_displayed,
                         set_displayed,
                         doc="Is the pseudocolor class displayed?")

class PseudocolorLayer(Layer):
    "A Pseudocolor layer."

    _getPseudocolorClassCount = \
        _genwrap("getPseudocolorClassCount", ctypes.c_uint32, Layer)
    _getPseudocolorClassId = \
        _genwrap("getPseudocolorClassId", ctypes.c_int32, Layer,
                 ctypes.c_uint32)
    _addPseudocolorClass = \
        _genwrap("addPseudocolorClass", ctypes.c_int32, Layer,
                 ctypes.c_char_p, ctypes.POINTER(ctypes.c_int32),
                 ctypes.POINTER(ctypes.c_uint32),
                 ctypes.POINTER(ctypes.c_int))

    def __init__(self, name=None, other=None):
        """Get a Pseudocolor Layer by name.
        See Layer documentation for information on values for name.
        If other is specified the internal handle for that Layer
        will be copied to the new Layer. The typ value for the Layer
        contructor will be 'PseudocolorLayer'.
        Other may be a Layer object which will be cast to a PseudocolorLayer.

        """
        if other is not None:
            if not isinstance(other, Layer) or other.type != 'PseudocolorLayer':
                raise TypeError("Layer is not a PseudocolorLayer.")
            Layer.__init__(self, other=other)
        else:
            Layer.__init__(self, name=name, typ='PseudocolorLayer')

    @classmethod
    def create(cls, name, element, view=None):
        if view is None:
            view = View()
        tempf = _genwrap("createLayer", Layer, View,
                         RasterElement, ctypes.c_char_p, ctypes.c_char_p)
        layer = tempf(view, element, "PseudocolorLayer", name)
        return layer.leafclass()

    @classmethod
    def create_from(cls, name, layer):
        return layer.derive(name, "PseudocolorLayer")

    def __len__(self):
        return self._getPseudocolorClassCount(self)

    def __getitem__(self, index):
        return PseudocolorClass(self, self._getPseudocolorClassId(self, index))

    def __iter__(self):
        def do_iter(layer, cnt):
            for index in xrange(cnt):
                yield layer[index]
        return do_iter(self, len(self))

    def add_class(self, name=None, value=None, color=None, displayed=None):
        """Add a new class.
        If name, value, color, and displayed are not None, the class
        is initialized to those values. If any of name, value, color,
        or displayed is None, an uninitialized class is created.

        """
        if (name is not None and value is not None and
            color is not None and displayed is not None):
            if not isinstance(value, ctypes.c_int32):
                value = ctypes.c_int32(value)
            if not isinstance(color, Color):
                color = Color(color)
            color = ctypes.c_uint32(color.value)
            if displayed:
                displayed = ctypes.c_int(1)
            else:
                displayed = ctypes.c_int(0)
            temph = self._addPseudocolorClass(self, name,
                                              ctypes.byref(value),
                                              ctypes.byref(color),
                                              ctypes.byref(displayed))
            return PseudocolorClass(self, temph)
        temph = self._addPseudocolorClass(self, None,
                                          None, None, None)
        return PseudocolorClass(self, temph)

class RasterLayerStretchInfo(ctypes.Structure):
    _fields_ = [('lower', ctypes.c_double),
                ('upper', ctypes.c_double),
                ('stretch', Stretch),
                ('units', RegionUnits)]

    def __repr__(self):
        return ("<RasterLayerStretchInfo: %f-%f, type %s, units %s>" %
               (self.lower, self.upper, self.stretch, self.units))

class RasterStatistics(ctypes.Structure):
    #pylint: disable=W0201
    _fields_ = [('min', ctypes.c_double),
                ('max', ctypes.c_double),
                ('mean', ctypes.c_double),
                ('std_dev', ctypes.c_double),
                ('_histogramCenters', ctypes.POINTER(ctypes.c_double)),
                ('_histogramCounts', ctypes.POINTER(ctypes.c_uint)),
                ('_percentiles', ctypes.POINTER(ctypes.c_double)),
                ('resolution', ctypes.c_uint32)]
    @property
    def histogram_centers(self):
        #pylint: disable=E0203
        if hasattr(self, "_stored_centers"):
            return self._stored_centers
        self._stored_centers = self._histogramCenters[:256]
        return self._stored_centers

    @property
    def histogram_counts(self):
        #pylint: disable=E0203
        if hasattr(self, "_stored_counts"):
            return self._stored_counts
        self._stored_counts = self._histogramCounts[:256]
        return self._stored_counts

    @property
    def percentiles(self):
        #pylint: disable=E0203
        if hasattr(self, "_stored_percentiles"):
            return self._stored_percentiles
        self._stored_percentiles = self._percentiles[:1001]
        return self._stored_percentiles

    def __repr__(self):
        return "<RasterStatistics: %i resolution>" % self.resolution

class RasterLayer(Layer):
    "A Raster layer."

    _getRasterLayerStretchInfo = \
        _genwrap("getRasterLayerStretchInfo", ctypes.c_int, Layer,
                 RasterChannel, ctypes.POINTER(RasterLayerStretchInfo))
    _setRasterLayerStretchInfo = \
        _genwrap("setRasterLayerStretchInfo", ctypes.c_int, Layer,
                 RasterChannel, ctypes.POINTER(RasterLayerStretchInfo))
    _getRasterLayerComplexComponent = \
        _genwrap("getRasterLayerComplexComponent", ComplexComponent, Layer)
    _setRasterLayerComplexComponent = \
        _genwrap("setRasterLayerComplexComponent", ctypes.c_int,
                 Layer, ComplexComponent)
    _getRasterLayerColormapName = \
        _genwrap("getRasterLayerColormapName", ctypes.c_uint32, Layer,
                 ctypes.c_char_p, ctypes.c_uint32)
    _setRasterLayerColormapName = \
        _genwrap("setRasterLayerColormapName", ctypes.c_int, Layer,
                 ctypes.c_char_p)
    _getRasterLayerColormapValues = \
        _genwrap("getRasterLayerColormapValues", ctypes.c_int, Layer,
                 ctypes.POINTER(ctypes.c_uint32))
    _setRasterLayerColormapValues = \
        _genwrap("setRasterLayerColormapValues", ctypes.c_int, Layer,
                 ctypes.c_char_p, ctypes.POINTER(ctypes.c_uint32))
    _getRasterLayerGpuEnabled = \
        _genwrap("getRasterLayerGpuEnabled", ctypes.c_int, Layer)
    _setRasterLayerGpuEnabled = \
        _genwrap("setRasterLayerGpuEnabled", ctypes.c_int, Layer, ctypes.c_int)
    _getRasterLayerFilterCount = \
        _genwrap("getRasterLayerFilterCount", ctypes.c_uint32, Layer,
                 ctypes.c_int)
    _getRasterLayerFilterName = \
        _genwrap("getRasterLayerFilterName", ctypes.c_uint32, Layer,
                 ctypes.c_uint32, ctypes.c_int, ctypes.c_char_p,
                 ctypes.c_uint32)
    _setRasterLayerFilters = \
        _genwrap("setRasterLayerFilters", ctypes.c_int, Layer,
                 ctypes.c_uint32, ctypes.POINTER(ctypes.c_char_p))
    _resetRasterLayerFilter = \
        _genwrap("resetRasterLayerFilter", ctypes.c_int, Layer,
                 ctypes.c_char_p)
    _setRasterLayerFilterFrozen = \
        _genwrap("setRasterLayerFilterFrozen", ctypes.c_int, Layer,
                 ctypes.c_char_p, ctypes.c_int)
    _isRasterLayerRgbDisplayed = \
        _genwrap("isRasterLayerRgbDisplayed", ctypes.c_int, Layer)
    _setRasterLayerRgbDisplayed = \
        _genwrap("setRasterLayerRgbDisplayed", ctypes.c_int, Layer,
                 ctypes.c_int)
    _getRasterLayerDisplayedBand = \
        _genwrap("getRasterLayerDisplayedBand", ctypes.c_uint32,
                 Layer, RasterChannel, ctypes.POINTER(ctypes.c_void_p))
    _setRasterLayerDisplayedBand = \
        _genwrap("setRasterLayerDisplayedBand", ctypes.c_int,
                 Layer, RasterChannel, ctypes.c_uint32, DataElement)
    _getRasterLayerStatistics = \
        _genwrap("getRasterLayerStatistics", ctypes.c_int,
                 Layer, RasterChannel, ComplexComponent,
                 ctypes.POINTER(RasterStatistics))

    def __init__(self, name=None, other=None):
        """Get a Raster Layer by name.
        See Layer documentation for information on values for name.
        If other is specified the internal handle for that Layer
        will be copied to the new Layer.
        The typ value for the Layer contructor will be 'RasterLayer'.
        Other may be a Layer object which will be cast to a RasterLayer.

        """
        if other is not None:
            if not isinstance(other, Layer) or other.type != 'RasterLayer':
                raise TypeError("Layer is not a RasterLayer.")
            Layer.__init__(self, other=other)
        else:
            Layer.__init__(self, name=name, typ='RasterLayer')

    @classmethod
    def create(cls, name, element, view=None):
        if view is None:
            view = View()
        tempf = _genwrap("createLayer", Layer, View,
                         RasterElement, ctypes.c_char_p, ctypes.c_char_p)
        layer = tempf(view, element, "RasterLayer", name)
        return layer.leafclass()

    @classmethod
    def create_from(cls, name, layer):
        return layer.derive(name, "RasterLayer")

    def get_stretch(self, channel):
        nfo = RasterLayerStretchInfo()
        self._getRasterLayerStretchInfo(self, channel, ctypes.byref(nfo))
        return nfo
    def set_stretch(self, channel, nfo):
        self._setRasterLayerStretchInfo(self, channel, ctypes.byref(nfo))

    def get_stretch_gray_type(self):
        nfo = self.get_stretch(RasterChannel.GRAY)
        return nfo.stretch
    def set_stretch_gray_type(self, value):
        nfo = self.get_stretch(RasterChannel.GRAY)
        nfo.stretch = value
        self.set_stretch(RasterChannel.GRAY, nfo)
    stretch_gray_type = property(get_stretch_gray_type, set_stretch_gray_type)

    def get_stretch_rgb_type(self):
        nfo = self.get_stretch(RasterChannel.RED)
        return nfo.stretch
    def set_stretch_rgb_type(self, value):
        #pylint: disable=W0201
        nfo = self.get_stretch(RasterChannel.RED)
        nfo.stretch = value
        self.set_stretch(RasterChannel.RED, nfo)
    stretch_rgb_type = property(get_stretch_rgb_type, set_stretch_rgb_type)

    def get_stretch_gray(self):
        nfo = self.get_stretch(RasterChannel.GRAY)
        return (nfo.lower, nfo.upper)
    def set_stretch_gray(self, (lower, upper)):
        nfo = self.get_stretch(RasterChannel.GRAY)
        if lower is not None:
            nfo.lower = lower
        if upper is not None:
            nfo.upper = upper
        self.set_stretch(RasterChannel.GRAY, nfo)
    stretch_gray = property(get_stretch_gray, set_stretch_gray)

    def get_stretch_gray_units(self):
        nfo = self.get_stretch(RasterChannel.GRAY)
        return nfo.units
    def set_stretch_gray_units(self, value):
        nfo = self.get_stretch(RasterChannel.GRAY)
        nfo.units = value
        self.set_stretch(RasterChannel.GRAY, nfo)
    stretch_gray_units = property(get_stretch_gray_units,
                                  set_stretch_gray_units)

    def get_stretch_red(self):
        nfo = self.get_stretch(RasterChannel.RED)
        return (nfo.lower, nfo.upper)
    def set_stretch_red(self, (lower, upper)):
        nfo = self.get_stretch(RasterChannel.RED)
        if lower is not None:
            nfo.lower = lower
        if upper is not None:
            nfo.upper = upper
        self.set_stretch(RasterChannel.RED, nfo)
    stretch_red = property(get_stretch_red, set_stretch_red)

    def get_stretch_red_units(self):
        nfo = self.get_stretch(RasterChannel.RED)
        return nfo.units
    def set_stretch_red_units(self, value):
        nfo = self.get_stretch(RasterChannel.RED)
        nfo.units = value
        self.set_stretch(RasterChannel.RED, nfo)
    stretch_red_units = property(get_stretch_red_units, set_stretch_red_units)

    def get_stretch_green(self):
        nfo = self.get_stretch(RasterChannel.GREEN)
        return (nfo.lower, nfo.upper)
    def set_stretch_green(self, (lower, upper)):
        nfo = self.get_stretch(RasterChannel.GREEN)
        if lower is not None:
            nfo.lower = lower
        if upper is not None:
            nfo.upper = upper
        self.set_stretch(RasterChannel.GREEN, nfo)
    stretch_green = property(get_stretch_green, set_stretch_green)

    def get_stretch_green_units(self):
        nfo = self.get_stretch(RasterChannel.GREEN)
        return nfo.units
    def set_stretch_green_units(self, value):
        nfo = self.get_stretch(RasterChannel.GREEN)
        nfo.units = value
        self.set_stretch(RasterChannel.GREEN, nfo)
    stretch_green_units = property(get_stretch_green_units,
                                   set_stretch_green_units)

    def get_stretch_blue(self):
        nfo = self.get_stretch(RasterChannel.BLUE)
        return (nfo.lower, nfo.upper)
    def set_stretch_blue(self, (lower, upper)):
        #pylint: disable=W0201
        nfo = self.get_stretch(RasterChannel.BLUE)
        if lower is not None:
            nfo.lower = lower
        if upper is not None:
            nfo.upper = upper
        self.set_stretch(RasterChannel.BLUE, nfo)
    stretch_blue = property(get_stretch_blue, set_stretch_blue)

    def get_stretch_blue_units(self):
        nfo = self.get_stretch(RasterChannel.BLUE)
        return nfo.units
    def set_stretch_blue_units(self, value):
        #pylint: disable=W0201
        nfo = self.get_stretch(RasterChannel.BLUE)
        nfo.units = value
        self.set_stretch(RasterChannel.BLUE, nfo)
    stretch_blue_units = property(get_stretch_blue_units,
                                  set_stretch_blue_units)

    def get_complex_component(self):
        return self._getRasterLayerComplexComponent(self)
    def set_complex_component(self, value):
        self._setRasterLayerComplexComponent(self, value)
    complex_component = property(get_complex_component,
                                 set_complex_component,
                                 doc="Complex component displayed.")

    def get_colormap_name(self):
        return _stringbuffer_wrap(self._getRasterLayerColormapName, self)
    def set_colormap_name(self, name):
        self._setRasterLayerColormapName(self, name)
    colormap_name = property(get_colormap_name,
                             set_colormap_name,
                             doc="Internal name or filename of the colormap.")

    def get_colormap(self):
        cmap = (ctypes.c_uint32 * 256)()
        self._getRasterLayerColormapValues(self, cmap)
        return map(Color, cmap)
    def set_colormap(self, value, name=None):
        """Set a new colormap. Value is a sequence of 256
        colors. name is an optional name to associate
        with the colormap.

        """
        if len(value) != 256:
            raise ValueError("Colormap must be a sequence of 256 colors.")
        cmap = (ctypes.c_uint32 * 256)()
        cmap[:] = map(lambda x: Color(x).value, value)
        self._setRasterLayerColormapValues(self, name, cmap)
    colormap = property(get_colormap,
                        set_colormap,
                        doc="""Colormap table which is applied
                            when in grayscale/colormap/indexed
                            display mode.""")

    def get_gpu_enabled(self):
        return bool(self._getRasterLayerGpuEnabled(self))
    def set_gpu_enabled(self, value):
        self._setRasterLayerGpuEnabled(self, value)
    gpu_enabled = property(get_gpu_enabled,
                           set_gpu_enabled,
                           doc="Is the GPU rendering this layer?")

    def get_rgb_displayed(self):
        return bool(self._isRasterLayerRgbDisplayed(self))
    def set_rgb_displayed(self, value):
        self._setRasterLayerRgbDisplayed(self, value)
    rgb_displayed = property(get_rgb_displayed, set_rgb_displayed)

    def get_displayed_band(self, channel):
        rval = ctypes.c_void_p(0)
        bandnum = self._getRasterLayerDisplayedBand(self, channel,
                                                    ctypes.byref(rval))
        if not rval:
            element = None
        else:
            data_element = DataElement.cast(rval,
                                            "RasterElement")
            element = RasterElement(None, data_element)
        return (bandnum, element)

    def set_displayed_band(self, channel, band, element=None):
        if element is None:
            relement = self.get_displayed_band(channel)[1]
            if relement is not None:
                self._setRasterLayerDisplayedBand(self, channel, band, relement)
        else:
            self._setRasterLayerDisplayedBand(self, channel, band, element)

    def set_rgb_bands(self, red=None, green=None, blue=None):
        self.rgb_displayed = True
        if red is not None:
            self.set_displayed_band(RasterChannel.RED, red, self.element)
        if green is not None:
            self.set_displayed_band(RasterChannel.GREEN, green, self.element)
        if blue is not None:
            self.set_displayed_band(RasterChannel.BLUE, blue, self.element)

    def set_gray_band(self, gray):
        self.rgb_displayed = False
        self.set_displayed_band(RasterChannel.GRAY, gray, self.element)

    def get_statistics(self, channel, component=ComplexComponent.MAGNITUDE):
        stat = RasterStatistics()
        self._getRasterLayerStatistics(self, channel, component, stat)
        return stat

    @property
    def filters(self):
        rval = []
        for index in range(self._getRasterLayerFilterCount(self, 0)):
            rval.append(_stringbuffer_wrap(self._getRasterLayerFilterName,
                                           self, index, 0))
        return rval

    def get_enabled_filters(self):
        rval = []
        for index in range(self._getRasterLayerFilterCount(self, 1)):
            rval.append(_stringbuffer_wrap(self._getRasterLayerFilterName,
                                           self, index, 1))
        return rval
    def set_enabled_filters(self, value):
        value = list(value)
        count = len(value)
        filters = (ctypes.c_char_p * count)()
        filters[:] = value
        self._setRasterLayerFilters(self, count, filters)
    enabled_filters = property(get_enabled_filters,
                               set_enabled_filters,
                               doc="Currently enabled GPU filters.")

    def reset_filter(self, filter_name):
        """Reset a feedback filter. If filter is not a feedback
        filter, do nothing.

        """
        self._resetRasterLayerFilter(self, filter_name)

    def freeze_filter(self, filter_name, freeze=True):
        """Freeze of unfreeze a feedback filter. If filter
        is not a feedback filter, do nothing.

        """
        self._setRasterLayerFilterFrozen(self, filter_name, int(freeze))

class AnimationState(ctypes.c_uint32):
    "Opticks AnimationState type."
    STOP = 0
    PLAY_FORWARD = 1
    PLAY_BACKWARD = 2
    PAUSE_FORWARD = 3
    PAUSE_BACKWARD = 4

    def __repr__(self):
        if self.value == self.STOP:
            return "<AnimationState: stopped>"
        elif self.value == self.PLAY_FORWARD:
            return "<AnimationState: playing forward>"
        elif self.value == self.PLAY_BACKWARD:
            return "<AnimationState: playing backward>"
        elif self.value == self.PAUSE_FORWARD:
            return "<AnimationState: paused, will resume forward>"
        elif self.value == self.PAUSE_BACKWARD:
            return "<AnimationState: paused, will resume backward>"
        return "<AnimationState: unknown value>"

class AnimationCycle(ctypes.c_uint32):
    "Opticks AnimationCycle type."
    PLAY_ONCE = 0
    REPEAT = 1
    BOUNCE = 2

    def __repr__(self):
        if self.value == self.PLAY_ONCE:
            return "<AnimationCycle: play once>"
        elif self.value == self.REPEAT:
            return "<AnimationCycle: repeat>"
        elif self.value == self.BOUNCE:
            return "<AnimationCycle: bounce>"
        return "<AnimationCycle: unknown value>"

animation_callback_t = ctypes.CFUNCTYPE(None, ctypes.c_char_p,
                                        ctypes.c_char_p, ctypes.c_uint32,
                                        ctypes.c_double, ctypes.c_void_p)

class Animation(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, name=None, wrapper=None):
        """Get an animation by name. If name is none, get the active animation

        """
        ctypes.Structure.__init__(self)
        self.__owns = False
        if wrapper is None:
            tempf = _genwrap("getAnimationController", Animation,
                             ctypes.c_char_p)
            self.handle = tempf(name).handle
        else:
            self.handle = wrapper

    @classmethod
    def create(cls, name, time_based=True):
        """Create an animation, time_based will
        determine if the animation is time based of frame based.
        If the animation already exists, SimpleApi exception
        will be raised.

        """
        tempf = _genwrap("createAnimationController", Animation,
                          ctypes.c_char_p, ctypes.c_int)
        newa = Animation(wrapper=tempf(name, time_based).handle)
        return newa

    def __del__(self):
        if self.__owns:
            self._destroyAnimationController(self)

    def destroy(self, val=True):
        """Mark this animation for destruction. When the animation object
        is garbage collected it will be destroyed. If val is False,
        destruction will be cancelled.

        """
        self.__owns = val

    def get_state(self):
        return self._getAnimationControllerState(self)
    def set_state(self, value):
        if not isinstance(value, AnimationState):
            value = AnimationState(value)
        self._setAnimationControllerState(self, value)
    state = property(get_state, set_state,
                     doc="Playback state of the animation.")

    def get_cycle(self):
        return self._getAnimationControllerCycle(self)
    def set_cycle(self, value):
        if not isinstance(value, AnimationCycle):
            value = AnimationCycle(value)
        self._setAnimationControllerCycle(self, value)
    cycle = property(get_cycle, set_cycle, doc="Cycle mode of the animation.")

    def get_can_drop_frames(self):
        return bool(self._canAnimationControllerDropFrames(self))
    def set_can_drop_frames(self, value):
        self._setAnimationControllerCanDropFrames(self, value)
    can_drop_frames = property(get_can_drop_frames,
                               set_can_drop_frames,
                               doc="""Allow the controller to drop
                               frames if necessary to maintain
                               the frame rate.""")

    def get_interval_multiplier(self):
        return self._getAnimationControllerIntervalMultiplier(self)
    def set_interval_multiplier(self, value):
        self._setAnimationControllerIntervalMultiplier(self, value)
    interval_multiplier = property(get_interval_multiplier,
                                   set_interval_multiplier,
                                   doc="Adjust the speed of playback.")

    def activate(self):
        "Make this animation active in the animation toolbar."
        self._activateAnimationController(self)

    def attach(self, raster):
        """Attach a raster element to an animation. Raster must be a
        raster layer.

        """
        self._attachRasterLayerToAnimationController(self, raster)

    def callback(self, name, callback_func, frame_count, frame_times=None,
                 user_data=None):
        """Attach a callback_func to an animation.
        If callback_func is a Python callable, it will be wrapped
        with animation_callback_t. name is the name for the new
        attachment. frame_count is the number of frames. Each
        time a frame is `displayed' callback_func will be executed.
        If the animation is time based, frame_times can be a
        list of real values indicating playback times. The
        list must be of length equal to frame_count. If
        frame_times is None, times will be generated for 1fps playback.
        user_data will be passed as is to the callback function.

        """
        #pylint: disable=R0913
        typ = (ctypes.c_double * frame_count)
        if frame_times is not None and not isinstance(frame_times, typ):
            if len(frame_times) != frame_count:
                raise TypeError("`frame_times' must be" \
                                "None or a list of length %i" % frame_count)
            tmp = typ()
            for idx in xrange(frame_count):
                tmp[idx] = frame_times[idx]
            frame_times = tmp
        if not isinstance(callback_func, animation_callback_t):
            callback_func = animation_callback_t(callback_func)
        hndl = ctypes.c_void_p(
            self._attachCallbackToAnimationController(self, name,
                                                      callback_func,
                                                      user_data, frame_count,
                                                      frame_times))
        class DeleterObj(object):
            def __init__(self, cntrl, name, hndl, cb_func):
                self.__cntrl = cntrl
                self.__name = name
                self.__hndl = hndl
                self.__cb_func = cb_func
            def __del__(self):
                destroy_attachment = \
                    _genwrap("destroyAnimationControllerAttachment", None,
                             Animation, ctypes.c_char_p, ctypes.c_void_p,
                             errorCheck=False)
                destroy_attachment(self.__cntrl, self.__name, self.__hndl)
                del self.__cb_func
        return DeleterObj(self, name, hndl, callback_func)

    def play(self):
        self._playAnimationController(self)

    def pause(self):
        self._pauseAnimationController(self)

    def stop(self):
        self._stopAnimationController(self)

Animation._destroyAnimationController = \
    _genwrap("destroyAnimationController", None, Animation, errorCheck=False)
Animation._activateAnimationController = \
    _genwrap("activateAnimationController", ctypes.c_int, Animation)
Animation._getAnimationControllerState = \
    _genwrap("getAnimationControllerState", AnimationState, Animation)
Animation._setAnimationControllerState = \
    _genwrap("setAnimationControllerState", ctypes.c_int, Animation,
             AnimationState)
Animation._playAnimationController = \
    _genwrap("playAnimationController", ctypes.c_int, Animation)
Animation._pauseAnimationController = \
    _genwrap("pauseAnimationController", ctypes.c_int, Animation)
Animation._stopAnimationController = \
    _genwrap("stopAnimationController", ctypes.c_int, Animation)
Animation._getAnimationControllerCycle = \
    _genwrap("getAnimationControllerCycle", AnimationCycle, Animation)
Animation._setAnimationControllerCycle = \
    _genwrap("setAnimationControllerCycle", ctypes.c_int, Animation,
             AnimationCycle)
Animation._canAnimationControllerDropFrames = \
    _genwrap("canAnimationControllerDropFrames", ctypes.c_int, Animation)
Animation._setAnimationControllerCanDropFrames = \
    _genwrap("setAnimationControllerCanDropFrames", ctypes.c_int, Animation,
             ctypes.c_int)
Animation._getAnimationControllerIntervalMultiplier = \
    _genwrap("getAnimationControllerIntervalMultiplier", ctypes.c_double,
             Animation)
Animation._setAnimationControllerIntervalMultiplier = \
    _genwrap("setAnimationControllerIntervalMultiplier", ctypes.c_int,
             Animation, ctypes.c_double)
Animation._attachRasterLayerToAnimationController = \
    _genwrap("attachRasterLayerToAnimationController", ctypes.c_int,
             Animation, Layer)
Animation._attachCallbackToAnimationController = \
    _genwrap("attachCallbackToAnimationController", ctypes.c_void_p,
             Animation, ctypes.c_char_p, animation_callback_t,
             ctypes.c_void_p, ctypes.c_uint32,
             ctypes.POINTER(ctypes.c_double))

class Gcp(ctypes.Structure):
    _fields_ = [("column", ctypes.c_double),
                ("row", ctypes.c_double),
                ("__reserved1", ctypes.c_double),
                ("latitude", ctypes.c_double),
                ("longitude", ctypes.c_double),
                ("__reserved2", ctypes.c_double),
                ("rms_error_latitude", ctypes.c_double),
                ("rms_error_longitude", ctypes.c_double),
                ("__reserved3", ctypes.c_double)]

    def __repr__(self):
        return "<GCP Point (%5.2f, %5.2f)->(%3.8f,%3.8f) err: (%.8f,%.8f)>" % (
               self.column, self.row,
               self.latitude, self.longitude,
               self.rms_error_latitude, self.rms_error_longitude)

    def __eq__(self, other):
        return (self.column == other.column and
                self.row == other.row and
                self.latitude == other.latitude and
                self.longitude == other.longitude)

def get_gcp_points(gcp_list=None):
    "Get the list of GCP points and return them as a python list-like object"
    cnt = _get_gcp_count(gcp_list)
    lst = (Gcp * cnt)()
    _get_gcp_points(gcp_list, ctypes.cast(lst, ctypes.POINTER(Gcp)))
    return lst

def set_gcp_points(gcp_list=None, points=None):
    "Set the list of GCP points from a python list-like objects"
    if points is None:
        points = []
    cnt = len(points)
    typ = (Gcp * cnt)
    if type(points) != type:
        tmp = typ()
        for idx in range(cnt):
            tmp[idx] = points[idx]
        points = tmp
    _set_gcp_points(gcp_list, cnt, ctypes.cast(points, ctypes.POINTER(Gcp)))
    return cnt

_get_gcp_count = _genwrap("getGcpCount", ctypes.c_uint32, DataElement)
_get_gcp_point = _genwrap("getGcpPoint", Gcp, DataElement, ctypes.c_uint32)
_get_gcp_points = _genwrap("getGcpPoints", ctypes.c_uint32, DataElement,
                           ctypes.POINTER(Gcp))
_set_gcp_points = _genwrap("setGcpPoints", ctypes.c_uint32, DataElement,
                           ctypes.c_uint32, ctypes.POINTER(Gcp))

class GcpList(DataElement):
    def __init__(self, name, element=None):
        assert(name is not None or element is not None)
        assert(not (name is not None and element is not None))
        if element is not None:
            handle = element.handle
        else:
            handle = self._getDataElement(name, "GcpList", int(0)).handle
        DataElement.__init__(self, None, wrapper=handle)

    @classmethod
    def create(cls, name):
        found = False
        try:
            cls._getDataElement(name, "GcpList", int(0))
            #if above doesn't throw, then element already exists
            found = True
        except SimpleApiError:
            #didn't exist, so we can create
            pass
        if found:
            raise SimpleApiError(SimpleApiError.SIMPLE_EXISTS)
        elem = cls._getDataElement(name, "GcpList", int(1))
        return GcpList(None, element=elem)

    def get_gcps(self):
        cnt = _get_gcp_count(self)
        lst = (Gcp * cnt)()
        _get_gcp_points(self, ctypes.cast(lst, ctypes.POINTER(Gcp)))
        return lst

    def set_gcps(self, points):
        if points is None:
            points = []
        cnt = len(points)
        typ = (Gcp * cnt)
        if type(points) != type:
            tmp = typ()
            for idx in range(cnt):
                tmp[idx] = points[idx]
            points = tmp
        _set_gcp_points(self, cnt, ctypes.cast(points, ctypes.POINTER(Gcp)))

    points = property(get_gcps, set_gcps)
