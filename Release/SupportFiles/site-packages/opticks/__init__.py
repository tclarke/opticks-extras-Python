# Initialize the connection to Opticks.
import _opticks
import sys
import ctypes
import UserDict

__copyright__ = """ The information in this file is
 Copyright(c) 2009 Ball Aerospace & Technologies Corporation
 and is subject to the terms and conditions of the
 GNU Lesser General Public License Version 2.1
 The license text is available from
 http://www.gnu.org/licenses/lgpl.html"""
__doc__ = """Welcome to the Opticks Python scripting engine.

Please note that certain functionality is not available in the interpreter window, most
notably the raw_input() function. This prevents the proper functioning of help(), license(),
and similar functions although help(object) will work.

"""

class SimpleApiError(_opticks.error):
   SIMPLE_NO_ERROR = 0
   SIMPLE_WRONG_TYPE = 1
   SIMPLE_NOT_FOUND = 2
   SIMPLE_BAD_PARAMS = 3
   SIMPLE_BUFFER_SIZE = 4
   SIMPLE_NO_MEM = 5
   SIMPLE_EXISTS = 6
   SIMPLE_WRONG_VIEW_TYPE = 7
   SIMPLE_OTHER_FAILURE = -1

   """Python exception wrapper for a Simple API error.
    The 'code' member contains the numeric error code.
    The 'message' member contains the user readable error message.
    The 'result' member contains the return result from the original function call."""
   def __init__(self, code, result=None):
      _opticks.error.__init__(self, code, self._getErrorString(code))
      self.code = code
      self.message = self._getErrorString(code)
      self.result = result

def _simpleErrorCheck(result, func, args):
   "This errcheck function queries the last error state and raises an exception if an error occured"
   err = _getLastError()
   if err != SimpleApiError.SIMPLE_NO_ERROR:
      raise SimpleApiError(err, result)
   return args

try:
   if sys.platform == 'linux2':
      __api = ctypes.CDLL("libSimpleApiLib.so")
   else:
      __api = ctypes.CDLL("SimpleApiLib")
   __api.setHandle(ctypes.pythonapi.PyCObject_AsVoidPtr(ctypes.py_object(_opticks.handle())))
   def _genwrap(name, *args, **kargs):
       """Create a wrapper function for an API function.
          First arg is the name of the C function.
          Second arg is the return type (a ctypes type or None for void).
          Remaining args are the ctypes types for the function arguments.
          The 'errorCheck' keyword is a bool indicating if checks should be made
          for Simple API errors. These errors will be turned into a SimpleApiError exception.
          The default is to include error checking."""
       prototype = apply(ctypes.CFUNCTYPE, args)
       func = prototype((name, __api))
       errorCheck = kargs.get('errorCheck', True)
       if errorCheck:
          func.errcheck = _simpleErrorCheck
       return func
except:
    print "ERROR: The SimpleApiLib dynamic library could not be located.  The opticks module WILL NOT FUNCTION PROPERLY."
    def _genwrap(name, *args, **kargs):
        def foo(*args, **kargs):
           raise RuntimeError("Must be run from within Opticks application")
        return foo

def getVersionInfo():
   "Return a tuple containing (Opticks version, Python PlugIn Version) as strings."
   over = _stringBufferWrap(_genwrap("getOpticksVersion", ctypes.c_uint32, ctypes.c_char_p, ctypes.c_uint32))
   pver = _opticks.pythonVersion()
   return over,pver

def _stringBufferWrap(func, *args, **kargs):
   """This function calls a 'ctypes.c_uint32 func(ctypes.c_char_p, ctypes.c_uin32)' function and
      returns a python string. Pass in the python function (usually created with '_genwrap()').
      The minimal buffer size will be calculated before retrieving the string.
      The 'defaultBufferSize' keyword allows specification of an initial buffer size.
      This may result in a single function call instead of two. The default is to always calculate the minimum buffer size.
      If remaining args are present, they will be passed to 'func' before the buffer argument."""
   defaultBufferSize = kargs.get('defaultBufferSize', 0)
   buf = ctypes.create_string_buffer(defaultBufferSize)
   tmpargs = args + (buf,ctypes.sizeof(buf))
   sz = apply(func, tmpargs)
   if sz > ctypes.sizeof(buf):
      ctypes.resize(buf, sz)
      tmpargs = args + (buf,ctypes.sizeof(buf))
      apply(func, tmpargs)
   return ctypes.string_at(buf)

_getLastError = _genwrap("getLastError", ctypes.c_int, errorCheck=False)
_setLastError = _genwrap("setLastError", None, ctypes.c_int, errorCheck=False)
SimpleApiError._getErrorString = _genwrap("getErrorString", ctypes.c_char_p, ctypes.c_int, errorCheck=False)

def _void_pToNative(typename, value):
   typ = None
   isvector = False
   if typename.startswith("vector<"):
      typename = typename[7:-1]
      isvector = True
   if typename == "char": typ = ctypes.c_byte
   elif typename == "unsigned char": typ = ctypes.c_ubyte
   elif typename == "short": typ = ctypes.c_short
   elif typename == "unsigned short": typ = ctypes.c_ushort
   elif typename == "int": typ = ctypes.c_int
   elif typename == "unsigned int": typ = ctypes.c_uint
   elif typename == "long": typ = ctypes.c_long
   elif typename == "unsigned long": typ = ctypes.c_ulong
   elif typename == "Int64" or typename == "int64": typ = ctypes.c_longlong
   elif typename == "UInt64" or typename == "uint64": typ = ctypes.c_ulonglong
   elif typename == "float": typ = ctypes.c_float
   elif typename == "double": typ = ctypes.c_double
   else: return ctypes.cast(value, ctypes.c_void_p)
   if isvector:
      rval = ctypes.c_void_p(0)
      sz = _vectorToArray(value, "vector<%s>" % typename, ctypes.byref(rval))
      sz /= ctypes.sizeof(typ)
      typ = typ * sz
      return ctypes.cast(rval, ctypes.POINTER(typ)).contents
   return ctypes.cast(value, ctypes.POINTER(typ)).contents.value

def _prepForSet(value, typ):
   if isinstance(value, (DataVariant, ctypes.c_void_p)):
      return value
   elif isinstance(value, DataElement):
      rval = value.castDataElement(typ)
      if rval == 0:
         return None
      return ctypes.c_void_p(rval)
   elif typ == "char":
      return ctypes.cast(ctypes.pointer(ctypes.c_byte(value)), ctypes.c_void_p)
   elif typ == "short":
      return ctypes.cast(ctypes.pointer(ctypes.c_short(value)), ctypes.c_void_p)
   elif typ == "int":
      return ctypes.cast(ctypes.pointer(ctypes.c_int(value)), ctypes.c_void_p)
   elif typ == "long":
      return ctypes.cast(ctypes.pointer(ctypes.c_long(value)), ctypes.c_void_p)
   elif typ == "Int64":
      return ctypes.cast(ctypes.pointer(ctypes.c_longlong(value)), ctypes.c_void_p)
   elif typ == "unsigned char":
      return ctypes.cast(ctypes.pointer(ctypes.c_ubyte(value)), ctypes.c_void_p)
   elif typ == "unsigned short":
      return ctypes.cast(ctypes.pointer(ctypes.c_ushort(value)), ctypes.c_void_p)
   elif typ == "unsigned int":
      return ctypes.cast(ctypes.pointer(ctypes.c_uint(value)), ctypes.c_void_p)
   elif typ == "unsigned long":
      return ctypes.cast(ctypes.pointer(ctypes.c_ulong(value)), ctypes.c_void_p)
   elif typ == "UInt64":
      return ctypes.cast(ctypes.pointer(ctypes.c_ulonglong(value)), ctypes.c_void_p)
   elif typ == "float":
      return ctypes.cast(ctypes.pointer(ctypes.c_float(value)), ctypes.c_void_p)
   elif typ == "double":
      return ctypes.cast(ctypes.pointer(ctypes.c_double(value)), ctypes.c_void_p)
   else: # try an XML string conversion
      return _createDataVariantFromString(typ, str(value), 1)
   return None

class DataElement(ctypes.Structure, object):
   "An Opticks data element handle."
   _fields_ = [("handle", ctypes.c_void_p)]
   __owns = False

   def __init__(self, name=None, create=False, subtypeAsVoid=None, typ=None):
      """Get a DataElement.
         If name is passed, the DataElement with that name is accessed.
         If subtypeAsVoid and typ are passed, the subtype specificed in typ is dynamic_cast to
         a DataElement.
         If create is True and typ is specified, an attempt is made to create the element if it does not exist."""
      assert((name is not None and subtypeAsVoid is None) or (name is None and subtypeAsVoid is not None))
      if name is not None:
         self.handle = _genwrap("getDataElement", DataElement, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int)(name, typ, int(create)).handle
      else:
         self.handle = _genwrap("castToDataElement", DataElement, ctypes.c_void_p, ctypes.c_char_p)(subtypeAsVoid, typ).handle
      self.__owns = False

   def __del__(self):
      if self.__owns:
         _genwrap("destroyDataElement", None, DataElement, errorCheck=False)(self)

   def destroy(self, val=True):
      self.__owns = val

   @property
   def name(self):
      return _stringBufferWrap(self._getDataElementName, self)

   @property
   def type(self):
      return _stringBufferWrap(self._getDataElementType, self)

   @property
   def filename(self):
      return _stringBufferWrap(self._getDataElementFilename, self)

   @property
   def metadata(self):
      return DynamicObject(self)

   @property
   def children(self):
      class ChildList(object):
         def __init__(self, element):
            self.element = element

         def __len__(self):
            return self.element._getDataElementChildCount(self.element)

         def __getitem__(self, index):
            if index >= len(self):
               raise IndexError
            return self.element._getDataElementChild(self.element, index)
      return ChildList(self)

   def castDataElement(self, typ):
      return self._castDataElement(self, typ)

   def copyClassification(self, element):
      return self._copyClassification(element, self)

DataElement._castDataElement = _genwrap("castDataElement", ctypes.c_void_p, DataElement, ctypes.c_char_p)
DataElement._getDataElementName = _genwrap("getDataElementName", ctypes.c_uint32, DataElement, ctypes.c_char_p, ctypes.c_uint32)
DataElement._getDataElementType = _genwrap("getDataElementType", ctypes.c_uint32, DataElement, ctypes.c_char_p, ctypes.c_uint32)
DataElement._getDataElementFilename = _genwrap("getDataElementFilename", ctypes.c_uint32, DataElement, ctypes.c_char_p, ctypes.c_uint32)
DataElement._getDataElementChildCount = _genwrap("getDataElementChildCount", ctypes.c_uint32, DataElement)
DataElement._getDataElementChild = _genwrap("getDataElementChild", DataElement, DataElement, ctypes.c_uint32)
DataElement._copyClassification = _genwrap("copyClassification", None, DataElement, DataElement)

class DataVariant(ctypes.Structure):
   _fields_ = [("handle", ctypes.c_void_p)]
   __owns = False

   def __init__(self, value=None, vtype=None, xml=True):
      if isinstance(value, DataVariant):
         self.handle, self.__owns = value.handle, False
         return
      self.__owns = True
      import types
      if vtype is not None and not isinstance(value, ctypes.c_void_p):
         self.handle = _createDataVariantFromString(str(vtype), str(value), xml).handle
         return
      if vtype is None and value is not None:
         vtype = None
         if type(value) == types.StringType:
            self.handle = _createDataVariantFromString("string", str(value), 1).handle
            return
         elif type(value) == types.IntType or type(value) == types.LongType:
            if value < 0:
               if value > -(2**(ctypes.sizeof(ctypes.c_byte)*8)/2):
                  vtype, value = "char", ctypes.pointer(ctypes.c_byte(value))
               elif value > -(2**(ctypes.sizeof(ctypes.c_short)*8)/2):
                  vtype, value = "short", ctypes.pointer(ctypes.c_short(value))
               elif value > -(2**(ctypes.sizeof(ctypes.c_int)*8)/2):
                  vtype, value = "int", ctypes.pointer(ctypes.c_int(value))
               elif value > -(2**(ctypes.sizeof(ctypes.c_long)*8)/2):
                  vtype, value = "long", ctypes.pointer(ctypes.c_long(value))
               elif value > -(2**(ctypes.sizeof(ctypes.c_longlong)*8)/2):
                  vtype, value = "Int64", ctypes.pointer(ctypes.c_longlong(value))
            else:
               if value < 2**(ctypes.sizeof(ctypes.c_ubyte)*8):
                  vtype, value = "unsigned char", ctypes.pointer(ctypes.c_ubyte(value))
               elif value < 2**(ctypes.sizeof(ctypes.c_ushort)*8):
                  vtype, value = "unsigned short", ctypes.pointer(ctypes.c_ushort(value))
               elif value < 2**(ctypes.sizeof(ctypes.c_uint)*8):
                  vtype, value = "unsigned int", ctypes.pointer(ctypes.c_uint(value))
               elif value < 2**(ctypes.sizeof(ctypes.c_ulong)*8):
                  vtype, value = "unsigned long", ctypes.pointer(ctypes.c_ulong(value))
               elif value < 2**(ctypes.sizeof(ctypes.c_ulonglong)*8):
                  vtype, value = "UInt64", ctypes.pointer(ctypes.c_ulonglong(value))
         elif type(value) == types.FloatType:
            vtype, value = "float", ctypes.pointer(ctypes.c_float(value))
         else:
            raise _opticks.error("Can't automatically convert %s." % str(type(value)))
      self.handle = self._createDataVariant(vtype, value).handle

   def __del__(self):
      if self.__owns:
         self._freeDataVariant(self)

   def __repr__(self):
      if not self.valid:
         return "<DataVariant: invalid>"
      return "<DataVariant: '%s' type: '%s'>" % (self.xml, self.dvtype)

   @property
   def display(self):
      if not self.valid:
         return None
      return _stringBufferWrap(self._getDataVariantValueString, self, 0)

   @property
   def xml(self):
      if not self.valid:
         return None
      return _stringBufferWrap(self._getDataVariantValueString, self, 1)

   @property
   def valid(self):
      return bool(self._isDataVariantValid(self))

   @property
   def dvtype(self):
      if not self.valid:
         return ""
      buf = ctypes.create_string_buffer(32)
      self._getDataVariantTypeName(self, buf, 32)
      return ctypes.string_at(buf)

   @property
   def value(self):
      if self.dvtype == "string": # special case..can't handle std::string
         return self.xml
      return _void_pToNative(self.dvtype, self._getDataVariantValue(self))

class PlugInArgList(ctypes.Structure):
   _fields_ = [("handle", ctypes.c_void_p)]
   __owns = False

   def __del__(self):
      if self.__owns:
         self._freePlugInArgList(self)

   def __repr__(self):
      return "PlugInArgList(%i)" % self.handle.value

   def __len__(self):
      return self._getPlugInArgCount(self)

   def __getitem__(self, key):
      from types import IntType
      if type(key) == IntType:
         return self._getPlugInArgByIndex(self, key)
      return self._getPlugInArgByName(self, key)

   def keys(self):
      rval = []
      for idx in range(len(self)):
         rval.append(_stringBufferWrap(PlugInArg._getPlugInArgName, self._getPlugInArgByIndex(self, idx)))
      return rval

class PlugInArg(ctypes.Structure):
   _fields_ = [("handle", ctypes.c_void_p)]
   __owns = False

   def __repr__(self):
      return "PlugInArg(%i)" % self.handle

   @property
   def name(self):
      return _stringBufferWrap(self._getPlugInArgName, self)

   @property
   def type(self):
      return _stringBufferWrap(self._getPlugInArgTypeName, self)

   @property
   def description(self):
      return _stringBufferWrap(self._getPlugInArgDescription, self)

   def isDefaultSet(self):
      return bool(self._isPlugInArgDefaultSet(self))

   def isActualSet(self):
      return bool(self._isPlugInArgActualSet(self))

   @property
   def value(self):
      return _void_pToNative(self.type, self._getPlugInArgValue(self))

   def getdefault(self):
      if not self.isDefaultSet():
         raise _opticks.error("Default value is not set.")
      return _void_pToNative(self.type, self._getPlugInArgDefaultValue(self))

   def setdefault(self, value):
      value = _prepForSet(value, self.type)
      if isinstance(value, DataVariant):
         self._setPlugInArgDefaultValueFromDataVariant(self, value)
      elif isinstance(value, ctypes.c_void_p):
         self._setPlugInArgDefaultValueFromVoid(self, value)
      else:
         raise _opticks.error("Unable to store value.")

   # this can be changed to use .setter when we supporting only python >= 2.6
   default = property(getdefault, setdefault)

   def getactual(self):
      if not self.isActualSet():
         raise _opticks.error("Actual value is not set.")
      return _void_pToNative(self.type, self._getPlugInArgActualValue(self))

   def setactual(self, value):
      value = _prepForSet(value, self.type)
      if isinstance(value, DataVariant):
         self._setPlugInArgActualValueFromDataVariant(self, value)
      elif isinstance(value, ctypes.c_void_p):
         self._setPlugInArgActualValueFromVoid(self, value)
      else:
         raise _opticks.error("Unable to store value.")

   # this can be changed to use .setter when we supporting only python >= 2.6
   actual = property(getactual, setactual)

class WizardNode(ctypes.Structure):
   _fields_ = [("handle", ctypes.c_void_p)]

   @property
   def name(self):
      return _stringBufferWrap(self._getWizardNodeName, self)

   @property
   def type(self):
      return _stringBufferWrap(self._getWizardNodeType, self)

   def getvalue(self):
      value = _void_pToNative(self.type, self._getWizardNodeValue(self))
      if isinstance(value, ctypes.c_void_p):
         dv = DataVariant(value, self.type)
         if dv.valid:
            value = dv
      return value

   def setvalue(self, value):
      value = _prepForSet(value, self.type)
      if isinstance(value, DataVariant):
         self._setWizardNodeValue(self, self._getDataVariantValue(value))
      elif isinstance(value, ctypes.c_void_p):
         self._setWizardNodeValue(self, value)
      else:
         raise _opticks.error("Unable to store value.")

   value = property(getvalue, setvalue)

   def __repr__(self):
      return "<WizardNode object: '%s' of type: '%s'>" % (self.name, self.type)

_createDataVariantFromString = _genwrap("createDataVariantFromString", DataVariant, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int)
_vectorToArray = _genwrap("vectorToArray", ctypes.c_uint32, ctypes.c_void_p, ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p))
DataVariant._createDataVariant = _genwrap("createDataVariant", DataVariant, ctypes.c_char_p, ctypes.c_void_p)
DataVariant._freeDataVariant = _genwrap("freeDataVariant", None, DataVariant)
DataVariant._isDataVariantValid = _genwrap("isDataVariantValid", ctypes.c_int, DataVariant)
DataVariant._getDataVariantTypeName = _genwrap("getDataVariantTypeName", ctypes.c_uint32, DataVariant, ctypes.c_char_p, ctypes.c_uint32)
DataVariant._getDataVariantValue = _genwrap("getDataVariantValue", ctypes.c_void_p, DataVariant)
DataVariant._getDataVariantValueString = _genwrap("getDataVariantValueString", ctypes.c_uint32, DataVariant, ctypes.c_int, ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._getPlugInArgName = _genwrap("getPlugInArgName", ctypes.c_uint32, PlugInArg, ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._getPlugInArgTypeName = _genwrap("getPlugInArgTypeName", ctypes.c_uint32, PlugInArg, ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._getPlugInArgDescription = _genwrap("getPlugInArgDescription", ctypes.c_uint32, PlugInArg, ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._isPlugInArgDefaultSet = _genwrap("isPlugInArgDefaultSet", ctypes.c_int, PlugInArg)
PlugInArg._isPlugInArgActualSet = _genwrap("isPlugInArgActualSet", ctypes.c_int, PlugInArg)
PlugInArg._getPlugInArgValue = _genwrap("getPlugInArgValue", ctypes.c_void_p, PlugInArg)
PlugInArg._getPlugInArgDefaultValue = _genwrap("getPlugInArgDefaultValue", ctypes.c_void_p, PlugInArg)
PlugInArg._getPlugInArgActualValue = _genwrap("getPlugInArgActualValue", ctypes.c_void_p, PlugInArg)
PlugInArg._setPlugInArgDefaultValueFromVoid = _genwrap("setPlugInArgDefaultValueFromVoid", None, PlugInArg, ctypes.c_void_p)
PlugInArg._setPlugInArgDefaultValueFromDataVariant = _genwrap("setPlugInArgDefaultValueFromDataVariant", None, PlugInArg, DataVariant)
PlugInArg._setPlugInArgActualValueFromVoid = _genwrap("setPlugInArgActualValueFromVoid", None, PlugInArg, ctypes.c_void_p)
PlugInArg._setPlugInArgActualValueFromDataVariant = _genwrap("setPlugInArgActualValueFromDataVariant", None, PlugInArg, DataVariant)
PlugInArgList._freePlugInArgList = _genwrap("freePlugInArgList", None, PlugInArgList)
PlugInArgList._getPlugInArgCount = _genwrap("getPlugInArgCount", ctypes.c_uint32, PlugInArgList)
PlugInArgList._getPlugInArgByName = _genwrap("getPlugInArgByName", PlugInArg, PlugInArgList, ctypes.c_char_p)
PlugInArgList._getPlugInArgByIndex = _genwrap("getPlugInArgByIndex", PlugInArg, PlugInArgList, ctypes.c_uint32)
WizardNode._getWizardNodeName = _genwrap("getWizardNodeName", ctypes.c_uint32, WizardNode, ctypes.c_char_p, ctypes.c_uint32)
WizardNode._getWizardNodeType = _genwrap("getWizardNodeType", ctypes.c_uint32, WizardNode, ctypes.c_char_p, ctypes.c_uint32)
WizardNode._getWizardNodeValue = _genwrap("getWizardNodeValue", ctypes.c_void_p, WizardNode)
WizardNode._setWizardNodeValue = _genwrap("setWizardNodeValue", ctypes.c_int, WizardNode, ctypes.c_void_p)

class PlugIn(ctypes.Structure):
   _fields_ = [("handle", ctypes.c_void_p)]
   __owns = False

   def __init__(self, name, batch=True):
      self.handle, self.__owns = self._createPlugIn(name, batch).handle, True

   def __del__(self):
      if self.__owns:
         self._freePlugIn(self)

   @property
   def inArgList(self):
      return self._getPlugInInputArgList(self)

   @property
   def outArgList(self):
      return self._getPlugInOutputArgList(self)

   def __call__(self):
      return bool(self._executePlugIn(self))

class Wizard(ctypes.Structure):
   _fields_ = [("handle", ctypes.c_void_p)]

   class WizardNodeList(object):
      def __init__(self, wizard, inputList):
         assert(wizard is not None)
         self.__wizard, self.__inputList = wizard, inputList

      def __len__(self):
         if self.__inputList:
            return self._getWizardInputNodeCount(self.__wizard)
         return self._getWizardOutputNodeCount(self.__wizard)

      def __getitem__(self, key):
         from types import IntType
         if type(key) == IntType:
            if self.__inputList:
               return self._getWizardInputNodeByIndex(self.__wizard, key)
            return self._getWizardOutputNodeByIndex(self.__wizard, key)
         if self.__inputList:
            return self._getWizardInputNodeByName(self.__wizard, str(key))
         return self._getWizardOutputNodeByName(self.__wizard, str(key))

      def iter(self):
         return self.iterkeys()

      def itervalues(self):
         def doiter(wizard, cnt, inputList):
            for idx in xrange(cnt):
               if inputList:
                  yield self._getWizardInputNodeByIndex(wizard, idx)
               else:
                  yield self._getWizardInputNodeByIndex(wizard, idx)
         return doiter(self.__wizard, len(self), self.__inputList)

      def iterkeys(self):
         def doiter(wizard, cnt, inputList):
            for idx in xrange(cnt):
               n = None
               if inputList:
                  n = self._getWizardInputNodeByIndex(wizard, idx)
               else:
                  n = self._getWizardInputNodeByIndex(wizard, idx)
               yield n.name
         return doiter(self.__wizard, len(self), self.__inputList)

   def __init__(self, filename):
      self.handle, self.__owns = self._loadWizard(filename).handle, True

   def __del__(self):
      if self.__owns:
         self._freeWizard(self)

   @property
   def input(self):
      return Wizard.WizardNodeList(self, True)

   @property
   def output(self):
      return Wizard.WizardNodeList(self, False)

   def __call__(self):
      return bool(self._executeWizard(self))

   @property
   def name(self):
      return _stringBufferWrap(self._getWizardName, self)

PlugIn._createPlugIn = _genwrap("createPlugIn", PlugIn, ctypes.c_char_p, ctypes.c_int)
PlugIn._freePlugIn = _genwrap("freePlugIn", None, PlugIn, errorCheck=False)
PlugIn._getPlugInInputArgList = _genwrap("getPlugInInputArgList", PlugInArgList, PlugIn)
PlugIn._getPlugInOutputArgList = _genwrap("getPlugInOutputArgList", PlugInArgList, PlugIn)
PlugIn._executePlugIn = _genwrap("executePlugIn", ctypes.c_int, PlugIn)
Wizard._loadWizard = _genwrap("loadWizard", Wizard, ctypes.c_char_p)
Wizard._freeWizard = _genwrap("freeWizard", None, Wizard, errorCheck=False)
Wizard._getWizardName = _genwrap("getWizardName", ctypes.c_uint32, Wizard, ctypes.c_char_p, ctypes.c_uint32)
Wizard.WizardNodeList._getWizardInputNodeCount = _genwrap("getWizardInputNodeCount", ctypes.c_uint32, Wizard)
Wizard.WizardNodeList._getWizardOutputNodeCount = _genwrap("getWizardOutputNodeCount", ctypes.c_uint32, Wizard)
Wizard.WizardNodeList._getWizardInputNodeByIndex = _genwrap("getWizardInputNodeByIndex", WizardNode, Wizard, ctypes.c_uint32)
Wizard.WizardNodeList._getWizardOutputNodeByIndex = _genwrap("getWizardOutputNodeByIndex", WizardNode, Wizard, ctypes.c_uint32)
Wizard.WizardNodeList._getWizardInputNodeByName = _genwrap("getWizardInputNodeByName", WizardNode, Wizard, ctypes.c_char_p)
Wizard.WizardNodeList._getWizardOutputNodeByName = _genwrap("getWizardOutputNodeByName", WizardNode, Wizard, ctypes.c_char_p)
Wizard._executeWizard = _genwrap("executeWizard", ctypes.c_int, Wizard)

class DynamicObject(ctypes.Structure):
   _fields_ = [("handle", ctypes.c_void_p)]
   __owns = False

   def __init__(self, element=None, wrapper=None):
      if element is None and wrapper is None:
         self.handle, self.__owns = self._createDynamicObject().handle, True
      elif wrapper is None:
         self.handle, self.__owns = self._getDataElementMetadata(element).handle, False
      else:
         self.handle, self.__owns = wrapper, False

   def __del__(self):
      if self.__owns:
         self._freeDynamicObject(self)

   def clear(self):
      self._clearMetadata(self)

   def __len__(self):
      return self._getMetadataAttributeCount(self)

   def __getitem__(self, key):
      val = DataVariant(self._getMetadataAttributeByPath(self, key))
      if not val.valid:
         raise KeyError("'DynamicObject' has no attribute '%s'" % key)
      elif val.dvtype == 'DynamicObject':
         val = DynamicObject(wrapper=ctypes.cast(val.value, ctypes.c_void_p))
      return val

   def __setitem__(self, key, value):
      if isinstance(value, DynamicObject):
         value = DataVariant(ctypes.cast(self.handle, ctypes.c_void_p), "DynamicObject")
      elif not isinstance(value, DataVariant):
         value = DataVariant(value)
      if not value.valid:
         raise ValueError("Invalid 'DataVariant' value.")
      self._setMetadataAttributeByPath(self, key, value)

   def __delitem__(self, key):
      try:
         self._removeMetadataAttributeByPath(self, key)
      except:
         return object.__delitem__(self, key)

   def __getattr__(self, name):
      if name == '__members__':
         rval = []
         for idx in range(len(self)):
            rval.append(_stringBufferWrap(self._getMetadataAttributeName, self, idx))
         return rval
      val = DataVariant(self._getMetadataAttribute(self, name))
      if not val.valid:
         raise AttributeError("'DynamicObject' has no attribute '%s'" % name)
      elif val.dvtype == 'DynamicObject':
         val = DynamicObject(wrapper=ctypes.cast(val.value, ctypes.c_void_p))
      return val

   def __setattr__(self, name, value):
      if name.startswith('_') or name == "handle":
         return object.__setattr__(self, name, value)
      return self.__setitem__(name, value)

   def __delattr__(self, name):
      try:
         self._removeMetadataAttribute(self, name)
      except:
         return object.__delattr__(self, name)

   def __iter__(self):
      return self.iterkeys()

   def iterkeys(self):
      def doiter(meta, cnt):
         for idx in xrange(cnt):
            yield _stringBufferWrap(self._getMetadataAttributeName, meta, idx)
      return doiter(self, len(self))

   def __reversed__(self):
      def doiter(meta, cnt):
         for idx in xrange(cnt-1, -1, -1):
            yield _stringBufferWrap(self._getMetadataAttributeName, meta, idx)
      return doiter(self, len(self))

   def __str__(self):
      return "<DynamicObject with %i attribute(s)>" % len(self)

   def __repr__(self):
      return "DynamicObject(wrapper=DynamicObject(%i))" % addressof(self)

class ConfigurationSettings(object):
   def __init__(self):
      self.__defaults = None

   def __getitem__(self, key):
      return _genwrap("getConfigurationSetting", DataVariant, ctypes.c_char_p)(key)

   def __setitem__(self, key, value):
      if not isinstance(value, DataVariant):
         value = DataVariant(value)
      _genwrap("setConfigurationSetting", ctypes.c_int, ctypes.c_char_p, DataVariant)(key, value)

   def addToDefaults(self, key):
      """Add the specified configuration setting to the defaults list which is
         maintained as a member object until serialized or cleared."""
      if self.__defaults is None:
         self.__defaults = DynamicObject()
      _genwrap("copyConfigurationSetting", ctypes.c_int, ctypes.c_char_p, DynamicObject)(key, self.__defaults)

   def serializeDefaults(self, filename):
      if self.__defaults is None:
         raise ValueError("No configuration settings in defaults.")
      _genwrap("serializeConfigurationSettingDefaults", ctypes.c_int, ctypes.c_char_p, DynamicObject)(filename, self.__defaults)
      self.clearDefaults()

   def clearDefaults(self):
      self.__defaults = None

DynamicObject._createDynamicObject = _genwrap("createDynamicObject", DynamicObject)
DynamicObject._freeDynamicObject = _genwrap("freeDynamicObject", None, DynamicObject, errorCheck=False)
DynamicObject._getDataElementMetadata = _genwrap("getDataElementMetadata", DynamicObject, DataElement)
DynamicObject._getMetadataAttributeCount = _genwrap("getMetadataAttributeCount", ctypes.c_uint32, DynamicObject)
DynamicObject._getMetadataAttributeName = _genwrap("getMetadataAttributeName", ctypes.c_uint32, DynamicObject, ctypes.c_uint32, ctypes.c_char_p, ctypes.c_uint32)
DynamicObject._getMetadataAttribute = _genwrap("getMetadataAttribute", DataVariant, DynamicObject, ctypes.c_char_p)
DynamicObject._getMetadataAttributeByPath = _genwrap("getMetadataAttributeByPath", DataVariant, DynamicObject, ctypes.c_char_p)
DynamicObject._setMetadataAttribute = _genwrap("setMetadataAttribute", None, DynamicObject, ctypes.c_char_p, DataVariant)
DynamicObject._setMetadataAttributeByPath = _genwrap("setMetadataAttributeByPath", None, DynamicObject, ctypes.c_char_p, DataVariant)
DynamicObject._removeMetadataAttribute = _genwrap("removeMetadataAttribute", None, DynamicObject, ctypes.c_char_p)
DynamicObject._removeMetadataAttributeByPath = _genwrap("removeMetadataAttributeByPath", None, DynamicObject, ctypes.c_char_p)
DynamicObject._clearMetadata  = _genwrap("clearMetadata", None, DynamicObject)

class c_intcomplex32(ctypes.Structure):
   "Integer complex with 16-bit real and 16-bit imaginary elements."
   _fields_ = [("real", ctypes.c_int16), ("imag", ctypes.c_int16)]

class c_floatcomplex64(ctypes.Structure):
   "Floating point complex with 32-bit real and 32-bit imaginary elements."
   _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]

class EncodingType(ctypes.c_uint32):
   "Opticks data encoding type."
   INT1SBYTE = 0
   INT1UBYTE = 1
   INT2SBYTES = 2
   INT2UBYTES = 3
   INT4SCOMPLEX = 4
   INT4SBYTES = 5
   INT4UBYTES = 6
   FLT4BYTES = 7
   FLT8COMPLEX = 8
   FLT8BYTES = 9

   def __repr__(self):
      if self.value == self.INT1SBYTE: strname = "INT1SBYTE"
      elif self.value == self.INT1UBYTE: strname = "INT1UBYTE"
      elif self.value == self.INT2SBYTES: strname = "INT2SBYTES"
      elif self.value == self.INT2UBYTES: strname = "INT2UBYTES"
      elif self.value == self.INT4SBYTES: strname = "INT4SBYTES"
      elif self.value == self.INT4UBYTES: strname = "INT4UBYTES"
      elif self.value == self.INT4SCOMPLEX: strname = "INT4SCOMPLEX"
      elif self.value == self.FLT4BYTES: strname = "FLT4BYTES"
      elif self.value == self.FLT8BYTES: strname = "FLT8BYTES"
      elif self.value == self.FLT8COMPLEX: strname = "FLT8COMPLEX"
      else: strname = "Unknown"
      return "<EncodingType: %s>" % strname

   def toCtype(self):
      "Return an appropriate ctypes data type for this encoding type."
      if self.value == self.INT1SBYTE: return ctypes.POINTER(ctypes.c_int8)
      elif self.value == self.INT1UBYTE: return ctypes.POINTER(ctypes.c_uint8)
      elif self.value == self.INT2SBYTES: return ctypes.POINTER(ctypes.c_int16)
      elif self.value == self.INT2UBYTES: return ctypes.POINTER(ctypes.c_uint16)
      elif self.value == self.INT4SBYTES: return ctypes.POINTER(ctypes.c_int32)
      elif self.value == self.INT4UBYTES: return ctypes.POINTER(ctypes.c_uint32)
      elif self.value == self.INT4SCOMPLEX: return ctypes.POINTER(c_intcomplex32)
      elif self.value == self.FLT4BYTES: return ctypes.POINTER(ctypes.c_float)
      elif self.value == self.FLT8BYTES: return ctypes.POINTER(ctypes.c_double)
      elif self.value == self.FLT8COMPLEX: return ctypes.POINTER(c_floatcomplex64)
      else: return ctypes.c_void_p

   def toNumpyType(self):
      "Return an appropriate numpy dtype for this encoding type."
      if self.value == self.INT1SBYTE: return "int8"
      elif self.value == self.INT1UBYTE: return "uint8"
      elif self.value == self.INT2SBYTES: return "int16"
      elif self.value == self.INT2UBYTES: return "uint16"
      elif self.value == self.INT4SBYTES: return "int32"
      elif self.value == self.INT4UBYTES: return "uint32"
      elif self.value == self.INT4SCOMPLEX: return "i2i2"
      elif self.value == self.FLT4BYTES: return "float32"
      elif self.value == self.FLT8BYTES: return "float64"
      elif self.value == self.FLT8COMPLEX: return "complex64"
      else: return "void"

   def fromNumpyType(self, typestr):
      "Return an appropriate numpy dtype for this encoding type."
      if typestr == "int8": return self.INT1SBYTE
      elif typestr == "uint8": return self.INT1UBYTE
      elif typestr == "int16": return self.INT2SBYTES
      elif typestr == "uint16": return self.INT2UBYTES
      elif typestr == "int32": return self.INT4SBYTES
      elif typestr == "uint32": return self.INT4UBYTES
      elif typestr == "float32": return self.FLT4BYTES
      elif typestr == "float64": return self.FLT8BYTES
      elif typestr == "complex64": return self.FLT8COMPLEX
      else: raise TypeError("'%s' can't be represented in Opticks." % typstr)

class InterleaveFormat(ctypes.c_uint32):
   "Opticks data interleave format."
   BSQ = 0
   BIP = 1
   BIL = 2

   def __repr__(self):
      if self.value == self.BSQ: return "<InterleaveFormat: BSQ>"
      elif self.value == self.BIP: return "<InterleaveFormat: BIP>"
      elif self.value == self.BIL: return "<InterleaveFormat: BIL>"
      return "<InterleaveFormat: Unknown"

class ProcessingLocationPreference(ctypes.c_uint32):
   "Processing location hint for creation of raster elements."
   PREFER_RAM = 0
   RAM = 1
   ONDISK = 2

   def __repr__(self):
      if self.value == self.ONDISK: return "<ProcessingLocationPreference: on-disk only>"
      elif self.value == self.RAM: return "<ProcessingLocationPreference: in memory only>"
      elif self.value == self.PREFER_RAM: return "<ProcessingLocationPreference: prefer in memory>"
      return "<InterleaveFormat: Unknown"

class DataInfo(ctypes.Structure):
   "Information about a raster element."
   _fields_ = [("numRows", ctypes.c_uint32),
               ("numColumns", ctypes.c_uint32),
               ("numBands", ctypes.c_uint32),
               ("interleaveFormat", InterleaveFormat),
               ("encodingType", EncodingType),
               ("encodingTypeSize", ctypes.c_uint32),
               ("numBadValues", ctypes.c_uint32),
               ("pBadValues", ctypes.POINTER(ctypes.c_int32))]

   def __init__(self, *args):
      pass # don't call the base class __init__

   def __new__(cls, dataElement=None):
      createDataInfo = _genwrap("createDataInfo", ctypes.POINTER(DataInfo), DataElement)
      rval = createDataInfo(dataElement).contents
      if rval:
         rval.__coreOwns = True
      return rval

   def __del__(self):
      if self.__coreOwns:
         _genwrap("destroyDataInfo", None, ctypes.POINTER(DataInfo), errorCheck=False)(self)

   def __repr__(self):
      return "<DataInfo: %i,%i,%i %s %s>" % (self.numRows,self.numColumns,self.numBands,self.interleaveFormat,self.encodingType)

   def getBadValues(self):
      rval = []
      for idx in range(self.numBadValues):
         rval.append(self.pBadValues[idx])
      return rval

   def setBadValues(self, val):
      assert(isinstance(val, list))
      self.numBadValues = len(val)
      self.pBadValues = ctypes.cast(ctypes.POINTER(ctypes.c_int32), (ctypes.c_int32 * self.numBadValues))
      for idx in range(self.numBadValues):
         self.pBadValues[idx] = ctypes.c_int32(val[idx])

   badValues = property(getBadValues, setBadValues)

class RasterElementArgs(ctypes.Structure):
   "Argument structure for creation of a new raster element."
   _fields_ = [("numRows", ctypes.c_uint32),
               ("numColumns", ctypes.c_uint32),
               ("numBands", ctypes.c_uint32),
               ("interleaveFormat", InterleaveFormat),
               ("encodingType", EncodingType),
               ("location", ProcessingLocationPreference),
               ("parent", DataElement),
               ("numBadValues", ctypes.c_uint32),
               ("pBadValues", ctypes.POINTER(ctypes.c_int32))]

   def __repr__(self):
      return "<RasterElementArgs: %i,%i,%i %s %s %s>" % (self.numRows,self.numColumns,self.numBands,self.interleaveFormat,self.encodingType,self.location)

   def fromNumpyArray(self, ar):
      """This will fill in details from a numpy array. Before calling this function
         you must set 'interleaveFormat' appropriately."""
      try:
         import numpy
         if len(ar.shape) == 3:
            if self.interleaveFormat.value == InterleaveFormat.BSQ:
               self.numBands, self.numRows, self.numColumns = ar.shape
            elif self.interleaveFormat.value == InterleaveFormat.BIL:
               self.numRows, self.numBands, self.numColumns = ar.shape
            elif self.interleaveFormat.value == InterleaveFormat.BIP:
               self.numRows, self.numColumns, self.numBands = ar.shape
         elif len(ar.shape) == 2:
            self.numBands = 1
            self.numRows, self.numColumns = ar.shape
         else:
            raise ValueError("Array must be 2-d or 3-d")
         self.encodingType = self.encodingType.fromNumpyType(ar.dtype.name)
      except ImportError:
         # numpy not available
         raise NotImplementedError("numpy is not available")

   def getBadValues(self):
      rval = []
      for idx in range(self.numBadValues):
         rval.append(self.pBadValues[idx])
      return rval

   def setBadValues(self, val):
      assert(isinstance(val, list))
      self.numBadValues = len(val)
      self.pBadValues = ctypes.cast((ctypes.c_int32 * self.numBadValues)(), ctypes.POINTER(ctypes.c_int32))
      for idx in range(self.numBadValues):
         self.pBadValues[idx] = ctypes.c_int32(val[idx])

   badValues = property(getBadValues, setBadValues)

class DataPointerArgs(ctypes.Structure):
   "Argument structure for creation of a new data pointer."
   _fields_ = [("rowStart", ctypes.c_uint32),
               ("rowEnd", ctypes.c_uint32),
               ("columnStart", ctypes.c_uint32),
               ("columnEnd", ctypes.c_uint32),
               ("bandStart", ctypes.c_uint32),
               ("bandEnd", ctypes.c_uint32),
               ("interleaveFormat", InterleaveFormat)]

   def __repr__(self):
      return "<DataPointerArgs: %i-%i, %i-%i, %i-%i, %s>" % (self.rowStart,self.rowEnd,self.columnStart,self.columnEnd,self.bandStart,self.bandEnd,self.interleaveFormat)

class DataAccessorArgs(ctypes.Structure):
   "Argument structure for creation of a new data accessor."
   _fields_ = [("rowStart", ctypes.c_uint32),
               ("rowEnd", ctypes.c_uint32),
               ("concurrentRows", ctypes.c_uint32),
               ("columnStart", ctypes.c_uint32),
               ("columnEnd", ctypes.c_uint32),
               ("concurrentColumns", ctypes.c_uint32),
               ("bandStart", ctypes.c_uint32),
               ("bandEnd", ctypes.c_uint32),
               ("concurrentBands", ctypes.c_uint32),
               ("interleaveFormat", InterleaveFormat),
               ("writable", ctypes.c_uint32)]

   def __repr__(self):
      return "<DataAccessorArgs: %i-%i, %i-%i, %i-%i, %s>" % (self.rowStart,self.rowEnd,self.columnStart,self.columnEnd,self.bandStart,self.bandEnd,self.interleaveFormat)

class AoiIterator(ctypes.Structure):
   "An iterator over an AOI."
   _fields_ = [("handle", ctypes.c_void_p)]
   __owns = False

   def __init__(self, element = None, raster = None, boundingBox = None):
      """Create a new AOI iteraor over a specified raster element or bounding box.
         Pass in either a raster element or a 4-tuple (x1, y1, x2, y2) bounding box.
         If element is None, iterate over the entire raster or boundingBox."""
      assert(raster is not None or boundingBox is not None)
      assert(not (raster is not None and boundingBox is not None))

      try:
         if raster is not None:
            if element is None:
               self.handle = _genwrap("createAoiIteratorOverRaster", AoiIterator, ctypes.c_void_p, DataElement)(element, raster).handle
            else:
               self.handle = _genwrap("createAoiIteratorOverRaster", AoiIterator, DataElement, DataElement)(element, raster).handle
         else:
            if element is None:
               self.handle = _genwrap("createAoiIteratorOverBoundingBox", AoiIterator, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32)(element, boundingBox[0], boundingBox[1], boundingBox[2], boundingBox[3]).handle
            else:
               self.handle = _genwrap("createAoiIteratorOverBoundingBox", AoiIterator, DataElement, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32)(element, boundingBox[0], boundingBox[1], boundingBox[2], boundingBox[3]).handle
         self.__last = False
      except SimpleApiError,e:
         if e.code == SimpleApiError.SIMPLE_NOT_FOUND:
            self.__last = False
      self.__first,self.__owns = True,True

   def __del__(self):
      if self.__owns:
         _genwrap("freeAoiIterator", None, AoiIterator)(self)

   def __iter__(self):
      return self

   def next(self):
      if not self.__first and not self.__last:
         if self._nextAoiIterator(self) == 0:
            self.__last = True
      if self.__last:
         raise StopIteration()
      self.__first = False
      x, y = ctypes.c_int32(-1), ctypes.c_int32(-1)
      self._getAoiIteratorLocation(self, ctypes.byref(x), ctypes.byref(y))
      return x.value, y.value
AoiIterator._nextAoiIterator = _genwrap("nextAoiIterator", ctypes.c_int, AoiIterator)
AoiIterator._getAoiIteratorLocation = _genwrap("getAoiIteratorLocation", ctypes.c_int, AoiIterator, ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32))

class AOI(DataElement):
   "An AOI with support for iteration and random access."
   _getAoiValue = _genwrap("getAoiValue", ctypes.c_int, DataElement, ctypes.c_int32, ctypes.c_int32)
   _setAoiValue = _genwrap("setAoiValue", ctypes.c_int, DataElement, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_int)
   _getAoiMinimalBoundingBox = _genwrap("getAoiMinimalBoundingBox", ctypes.c_int, DataElement, ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32))

   def __init__(self, name=None, create=False, element=None):
      """Get an AOI.
         If name is specified, get the named AOI.
         If the named AOI does not exist an attempt will be made to create it if create is True.
         If element is specified, use an existing DataElement."""
      assert(name is not None or element is not None)
      assert(not (name is not None and element is not None))
      if element is not None:
         self.handle = element.handle
      else:
         DataElement.__init__(self, name, create=create, typ="AoiElement")

   def __getitem__(self, (x, y)):
      return bool(self._getAoiValue(self, x, y))

   def __setitem__(self, (x, y), value):
      self._setAoiValue(self, x, y, int(value))

   @property
   def minimalBoundingBox(self):
      x1, y1, x2, y2 = ctypes.c_int32(0), ctypes.c_int32(0), ctypes.c_int32(0), ctypes.c_int32(0)
      self._getAoiMinimalBoundingBox(self, ctypes.byref(x1), ctypes.byref(y1), ctypes.byref(x2), ctypes.byref(y2))
      return x1.value,y1.value,x2.value,y2.value

   def __iter__(self):
      return apply(self.iterbounding, self.minimalBoundingBox)

   def iterraster(self, rasterElement):
      "Create an iterator over an AOI bounded by the extents of a RasterElement."
      return AoiIterator(self, raster = rasterElement)

   def iterbounding(self, x1, y1, x2, y2):
      "Create an iterator over an AOI bounded by the specified pixel coordinates."
      return AoiIterator(self, boundingBox = (x1, y1, x2, y2))

class DataAccessor(ctypes.Structure):
   "Wrapper for an Opticks data accessor. This is the most flexible data access method but is also the most complex."
   _fields_ = [("handle", ctypes.c_void_p)]

   def __del__(self):
      if self.__owns:
         _genwrap("destroyDataAccessor", None, DataAccessor, errorCheck=False)(self)

   def initialize(self, *args):
      "Not user callable...this is used by RasterElement.getDataAccessor"
      # args = owns, encoding, colcount, writable
      self.__owns, self.__encoding, self.__colCount, self.__writable = args

   def getRow(self):
      "Get a ctypes pointer to the current row."
      return ctypes.cast(ctypes.c_void_p(self._getDataAccessorRow(self)), self.__encoding)

   def nextRow(self, count = 1, resetColumn = True):
      "Advance the data accessor count number of rows. If reset column is True, the data accessor will point to the original start column of the new row."
      self._nextDataAccessorRow(self, count, resetColumn)

   def getColumn(self):
      "Get a ctypes pointer to the current column."
      return ctypes.cast(ctypes.c_void_p(self._getDataAccessorColumn(self)), self.__encoding)

   def nextColumn(self, count = 1):
      "Advance the data accessor count number of columns."
      self._nextDataAccessorColumn(self, count)

   def __getitem__(self, (row, column)):
      "Access the data point at a specific (row, column)."
      self.toPixel(row, column)
      if not self.valid:
         raise _opticks.error("Location (%i, %i) is invalid." % (row, column))
      return self.getColumn().contents.value

   def __setitem__(self, (row, column), value):
      if not self.__writable:
         raise _opticks.error("Accessor is read-only")
      self.toPixel(row, column)
      if not self.valid:
         raise _opticks.error("Location (%i, %i) is invalid." % (row, column))
      self.getColumn()[0] = value

   def toPixel(self, row, column):
      self._toPixel(self, row, column)

   def iterrows(self, incr = 1):
      "Create an iterator across rows which accesses the entire row each iteration."
      def doiter(acc, inc):
         while acc.valid:
            yield acc.getRow()
            acc.nextRow(incr)
      return doiter(self, incr)

   def itercolumns(self, incr = 1):
      "Create an iteractor across columns in the current row."
      def doiter(acc, colCount, inc):
         for idx in xrange(colCount):
            yield acc.getColumn()
            acc.nextColumn(incr)
      return doiter(self, self.__colCount, incr)

   @property
   def valid(self):
      return self._valid(self)

   @property
   def rowsize(self):
      return self._rowsize(self)

DataAccessor._getDataAccessorRow = _genwrap("getDataAccessorRow", ctypes.c_void_p, DataAccessor)
DataAccessor._getDataAccessorColumn = _genwrap("getDataAccessorColumn", ctypes.c_void_p, DataAccessor)
DataAccessor._nextDataAccessorRow = _genwrap("nextDataAccessorRow", None, DataAccessor, ctypes.c_uint32, ctypes.c_int)
DataAccessor._nextDataAccessorColumn = _genwrap("nextDataAccessorColumn", None, DataAccessor, ctypes.c_uint32)
DataAccessor._valid = _genwrap("isDataAccessorValid", ctypes.c_int, DataAccessor)
DataAccessor._rowsize = _genwrap("getDataAccessorRowSize", ctypes.c_uint32, DataAccessor)
DataAccessor._toPixel = _genwrap("toDataAccessorPixel", None, DataAccessor, ctypes.c_uint32, ctypes.c_uint32)

class RasterElement(DataElement):
   "A raster element."
   _createDataPointer = _genwrap("createDataPointer", ctypes.c_void_p, DataElement, ctypes.POINTER(DataPointerArgs), ctypes.POINTER(ctypes.c_int))
   _createDataAccessor = _genwrap("createDataAccessor", DataAccessor, DataElement, ctypes.POINTER(DataAccessorArgs))
   _updateRasterElement = _genwrap("updateRasterElement", None, DataElement)
   _copyDataToRasterElement = _genwrap("copyDataToRasterElement", ctypes.c_int, DataElement, ctypes.POINTER(DataPointerArgs), ctypes.c_void_p)

   def __init__(self, name=None, args=None, rawData=None, element=None):
      """Get a raster element.
         If name is specified, get the named raster.
         If name and args are specified, create a new raster.
         If element is specified, use an existing DataElement.
         If rawData is not None, a new RasterElement will be created and rawData
         be copied to the new RasterElement using copyData() or copyArray(). args
         must be specified with rawData. Most of the args fields can be derived
         with RasterElementArgs.fromNumpyArray()."""
      assert(name is not None or element is not None)
      assert(not (name is not None and element is not None))
      if element is not None:
         self.handle = element.handle
      elif args is None and rawData is None:
         super(RasterElement, self).__init__(name)
      else:
         self.handle = _genwrap("createRasterElement", DataElement, ctypes.c_char_p, RasterElementArgs)(name, args).handle
         if rawData is not None:
            try:
               import numpy
               if isinstance(rawData, numpy.ndarray):
                  self.copyArray(rawData)
                  return
            except ImportError:
               pass
            self.copyData(rawData)

   @property
   def info(self):
      return DataInfo(self)

   def getDataAccessor(self, args = None):
      "Create a DataAccessor for this raster element."
      nfo = DataInfo(self)
      colCount = None
      assert(args is None or isinstance(args, DataAccessorArgs))
      if args is None:
         acc = self._createDataAccessor(self, None)
      else:
         acc = self._createDataAccessor(self, ctypes.byref(args))
      acc._DataAccessor__owns, acc._DataAccessor__encoding = True, nfo.encodingType.toCtype()
      if args is None:
         colcount, writable = nfo.numColumns, False
      else:
         colcount, writable = args.columnEnd - args.columnStart + 1, args.writable
      acc.initialize(True, nfo.encodingType.toCtype(), colcount, writable)
      return acc

   def update(self):
      self._updateRasterElement(self)

   def getDataPointer(self, args=None):
      """Create a data pointer to an element with optional DataPointerArgs.
         Returns the ctypes data pointer and an ownership variable. If the second return
         value is True, the caller must call destroyDataPointer() with the first return
         value. When done with the data, the caller must delete the deleter object (with
         del or by removing that last reference) in order to clean up allocated memory.
         If the memory is shared, the second return value will be None."""
      own, deleter = ctypes.c_int(0), None
      ptr = self._createDataPointer(self, args, ctypes.byref(own))
      if own:
         class deleterobj(object):
            def __init__(self, p):
               self.__ptr = p
            def __del__(self):
               _genwrap("destroyDataPointer", None, ctypes.c_void_p, errorCheck=False)(self.__ptr)
         deleter = deleterobj(ptr)
      return ptr,deleter

   def getDataPointerArray(self, args=None):
      """Create a data pointer to an element with optional DataPointerArgs.
         Returns a numpy array and a deleter object. When done with the data, the
         caller must delete the deleter object (with del or by removing the last reference)
         in order to clean up allocated memory. If the memory is shared, the second return
         value will be None."""
      try:
         import numpy
         ptr,deleter = self.getDataPointer(args)
         nfo = DataInfo(self)
         rows,cols,bands = nfo.numRows, nfo.numColumns, nfo.numBands
         if args is not None:
            rows,cols,bands = (args.rowEnd - args.rowStart + 1), (args.columnEnd - args.columnStart + 1), (args.bandEnd - args.bandStart + 1)
         func = ctypes.pythonapi.PyBuffer_FromMemory
         func.restype = ctypes.py_object
         datalen = rows * cols * bands * nfo.encodingTypeSize
         buffer = func(ptr, datalen)
         ar = numpy.frombuffer(buffer, dtype=nfo.encodingType.toNumpyType())
         if nfo.interleaveFormat.value == InterleaveFormat.BIP:
            ar.shape = (rows, cols, bands)
         elif nfo.interleaveFormat.value == InterleaveFormat.BSQ:
            ar.shape = (bands, rows, cols)
         elif nfo.interleaveFormat.value == InterleaveFormat.BIL:
            ar.shape = (rows, bands, cols)
         return ar,deleter
      except ImportError:
         # numpy wrapper will not be available
         raise NotImplementedError("numpy is not available")

   def copyData(self, data, args=None):
      """Copy data to a RasterElement with optional DataPointerArgs.
         Data must be a ctypes.c_void_p. The caller should call update() when this is
         complete to redisplay the data."""
      self._copyDataToRasterElement(self, args, data)

   def copyArray(self, data, args=None):
      """Copy data to a RasterElement with optional DataPointerArgs.
         Data must be a numpy.ndarray. The caller should call update() when this
         is complete to redisplay the data.
         The array info will be checked against args or if args is None, it will
         be populated with appropriate info."""
      try:
         import numpy
         if not isinstance(data, numpy.ndarray):
            raise TypeError("Invalid data type, must be numpy.ndarray or ctypes.c_void_p")
         nfo = DataInfo(self)
         if args is None:
            args = DataPointerArgs()
            args.interleaveFormat = nfo.interleaveFormat
            if len(data.shape) == 2:
               args.rowEnd,args.columnEnd = map(lambda x: x - 1, data.shape)
               args.bandEnd = 0
            elif len(data.shape) == 3:
               if args.interleaveFormat.value == InterleaveFormat.BSQ:
                  args.bandEnd,args.rowEnd,args.columnEnd = map(lambda x: x - 1, data.shape)
               elif args.interleaveFormat.value == InterleaveFormat.BIL:
                  args.rowEnd,args.bandEnd,args.columnEnd = map(lambda x: x - 1, data.shape)
               elif args.interleaveFormat.value == InterleaveFormat.BIP:
                  args.rowEnd,args.columnEnd,args.bandEnd = map(lambda x: x - 1, data.shape)
            else:
               raise ValueError("Data must be 2 or 3 dimensional.")
         if args.rowEnd - args.rowStart + 1 > nfo.numRows:
            raise ValueError("Array has too many rows.")
         elif args.columnEnd - args.columnStart + 1 > nfo.numColumns:
            raise ValueError("Array has too many columns.")
         elif args.bandEnd - args.bandStart + 1 > nfo.numBands:
            raise ValueError("Array has too many bands.")
         if nfo.encodingType.toNumpyType() != str(data.dtype):
            raise ValueError("Array has wrong dtype.")

         if (args.rowEnd - args.rowStart + 1) == nfo.numRows and (args.columnEnd - args.columnStart + 1) == nfo.numColumns and (args.bandEnd - args.bandStart + 1) == nfo.numBands:
            args = None
         rawdata = data.ctypes.data_as(ctypes.c_void_p)
         self.copyData(rawdata, args)
      except ImportError:
         # numpy wrapper will not be available
         raise NotImplementedError("numpy is not available")

class Signature(DataElement, UserDict.DictMixin):
   "A signature data type."
   _getSignatureDataSetCount = _genwrap("getSignatureDataSetCount", ctypes.c_uint32, DataElement)
   _getSignatureDataSetName = _genwrap("getSignatureDataSetName", ctypes.c_uint32, DataElement, ctypes.c_uint32, ctypes.c_char_p, ctypes.c_uint32)
   _getSignatureDataSet = _genwrap("getSignatureDataSet", DataVariant, DataElement, ctypes.c_char_p)
   _setSignatureDataSet = _genwrap("setSignatureDataSet", ctypes.c_int, DataElement, ctypes.c_char_p, DataVariant)

   def __init__(self, name=None, create=False, element=None):
      """Get a signature.
         If name is specified, get the named signature.
         If the signature does not exist and create is True, attempt to create the signature.
         If element is specified, use an existing DataElement."""
      assert(name is not None or element is not None)
      assert(not (name is not None and element is not None))
      if element is not None:
         self.handle = element.handle
      else:
         DataElement.__init__(self, name, create=create, typ="Signature")

   def keys(self):
      k = []
      for idx in range(self._getSignatureDataSetCount(self)):
         k.append(_stringBufferWrap(self._getSignatureDataSetName, self, idx))
      return k

   def __getitem__(self, key):
      return self._getSignatureDataSet(self, key)

   def __setitem__(self, key, value):
      if not isinstance(value, DataVariant):
         value = DataVariant(value)
      self._setSignatureDataSet(self, key, value)

   def __delitem__(self, key):
      raise NotImplementedError()

class SignatureSet(DataElement):
   "A signature set data type."
   _getSignatureSetCount = _genwrap("getSignatureSetCount", ctypes.c_uint32, DataElement)
   _getSignatureSetSignature = _genwrap("getSignatureSetSignature", DataElement, DataElement, ctypes.c_uint32)

   def __init__(self, name=None, create=False, element=None):
      """Get a signature set.
         If name is specified, get the named signature set.
         If the signature set does not exist and create is True, attempt to create the signature set.
         If element is specified, use an existing DataElement."""
      assert(name is not None or element is not None)
      assert(not (name is not None and element is not None))
      if element is not None:
         self.handle = element.handle
      else:
         DataElement.__init__(self, name, create=create, typ="SignatureSet")

   def __len__(self):
      return int(self._getSignatureSetCount(self))

   def __getitem__(self, index):
      if index >= len(self):
         raise IndexError()
      return Signature(element=self._getSignatureSetSignature(self, index))

# important IEEE-754 contant
NaN = 1e30000/1e30000 # overflow to cause Inf then divide to cause NaN

class Layer(ctypes.Structure):
   _fields_ = [("handle", ctypes.c_void_p)]
   __owns = False

   def __init__(self, name=None, typ=None, other=None):
      """Get a Layer by name.
         The name may be a session ID or a layer specification. See the Simple API
         module in the main developer documentation for more information on layer
         specifications. In summary, a layer specification is two parts, both optional:
         viewName|layerName where the default view is the active view and the default
         layer depends on a number of factors and is detailed in the main developer
         documentation.
         If typ is None, access any layer type. Otherwise, access only layers of the
         type specified.
         If other is specified the internal handle for that Layer will be copied to the new Layer.
         This is generally an internal usage.
         """
      if other is not None:
         assert(name is None and typ is None and isinstance(other, Layer))
         self.handle = other.handle
      else:
         self.handle = _genwrap("getLayer", Layer, ctypes.c_char_p, ctypes.c_char_p)(name, typ).handle
      self.__owns = False

   def __del__(self):
      if self.__owns:
         _genwrap("destroyLayer", None, Layer, errorCheck=False)(self)

   def destroy(self, val=True):
      """Mark this layer for destruction. When the layer object is garbage collected
         it will be removed from the view and destroyed. If val is False, destruction
         will be cancelled."""
      self.__owns = val

   @property
   def name(self):
      return _stringBufferWrap(self._getLayerName, self)

   @property
   def type(self):
      return _stringBufferWrap(self._getLayerType, self)

   @property
   def element(self):
      return self._getLayerElement(self)

   @property
   def view(self):
      return self._getLayerView(self)

   def getscale(self):
      x, y = ctypes.c_double(0.0), ctypes.c_double(0.0)
      self._getLayerScaleOffset(self, ctypes.byref(x), ctypes.byref(y), None, None)
      return x.value, y.value
   def setscale(self, (x, y)):
      self._setLayerScaleOffset(self, x, y, NaN, NaN)
   scale = property(getscale, setscale, doc="The Layer scale factor.")

   def getoffset(self):
      x, y = ctypes.c_double(0.0), ctypes.c_double(0.0)
      self._getLayerScaleOffset(self, None, None, ctypes.byref(x), ctypes.byref(y))
      return x.value, y.value
   def setoffset(self, (x, y)):
      self._setLayerScaleOffset(self, NaN, NaN, x, y)
   offset = property(getoffset, setoffset, doc="The Layer offset in pixels.")

   def getdisplayindex(self):
      return self._getLayerDisplayIndex(self)
   def setdisplayindex(self, index):
      self._setLayerDisplayIndex(self, index)
   displayindex = property(getdisplayindex, setdisplayindex, doc="Indicates the ordering in the layer stack.")

   @property
   def displayed(self):
      return bool(self._isLayerDisplayed(self))

   def show(self):
      self._setLayerDisplayed(self, 1);

   def hide(self):
      self._setLayerDisplayed(self, 0);

   def derive(self, name=None, typ=None):
      """Derive a new layer or copy an existing layer.
         If typ is None, a copy of the layer will be created.
         name is the new layer's name. If name is None, the new layer will have the same name as the original layer.
         Returns a new Layer."""
      if typ is None:
         typ = self.type
      return Layer(other=self._deriveLayer(self, name, typ))

   def convert(self, typ):
      "Convert to a new layer type."
      self.handle = self._convertLayer(self, typ).handle

   @property
   def active(self):
      return self._isLayerActive(self)

   def activate(self):
      self._activateLayer(self)

class View(ctypes.Structure):
   _fields_ = [("handle", ctypes.c_void_p)]
   __owns = False

   def __init__(self, name=None, typ=None, element=None, create=False):
      """Get a View by name.
         The name may be a session ID or a view name.
         If typ is None, access any view type. Otherwise, access only views of the
         type specified.

         If create is True, create a new View of typ with name. If the new view
         requires a DataElement (currently SpatialDataView) then element should
         contain the DataElement. If create is True and the View exists, an exception
         will be raised.
         If create is True and element is not None, typ is assumed to be
         SpatialDataView.
         """
      if create:
         if typ is None and element is not None:
            typ = "Spatial Data View"
         self.handle = _genwrap("createView", View, ctypes.c_char_p, ctypes.c_char_p, DataElement)(name, typ, element).handle
      else:
         self.handle = _genwrap("getView", View, ctypes.c_char_p, ctypes.c_char_p)(name, typ).handle
      self.__owns = False

   def __del__(self):
      if self.__owns:
         _genwrap("destroyView", None, View, errorCheck=False)(self)

   def destroy(self, val=True):
      """Mark this view for destruction. When the view object is garbage collected
         it will be destroyed. If val is False, destruction will be cancelled."""
      self.__owns = val

   def getname(self):
      return _stringBufferWrap(self._getViewName, self)
   def setname(self, name):
      self._setViewName(self, name)
   name = property(getname, setname)

   @property
   def type(self):
      return _stringBufferWrap(self._getViewType, self)

   @property
   def primaryRasterElement(self):
      return RasterElement(element=self._getViewPrimaryRasterElement(self))

   def createLayer(self, element, typ, name=None):
      """Create a new typ layer to display element. The name of the Layer
         will be name. If name is None, the name of the element will be used."""
      return _genwrap("createLayer", Layer, View, DataElement, ctypes.c_char_p, ctypes.c_char_p)(self, element, typ, name)

   def iterlayers(self):
      def doiter(view):
         getViewLayer = _genwrap("getViewLayer", Layer, View, ctypes.c_uint32)
         idx = 0
         while True:
            try:
               yield getViewLayer(view, idx)
            except SimpleApiError, err:
               if err.code == SimpleApiError.SIMPLE_NOT_FOUND:
                  return
               raise
            finally:
               idx += 1
      return doiter(self)

View._getViewName = _genwrap("getViewName", ctypes.c_uint32, View, ctypes.c_char_p, ctypes.c_uint32)
View._setViewName = _genwrap("setViewName", ctypes.c_int, View, ctypes.c_char_p)
View._getViewType = _genwrap("getViewType", ctypes.c_uint32, View, ctypes.c_char_p, ctypes.c_uint32)
View._getViewPrimaryRasterElement = _genwrap("getViewPrimaryRasterElement", DataElement, View)
Layer._getLayerName = _genwrap("getLayerName", ctypes.c_uint32, Layer, ctypes.c_char_p, ctypes.c_uint32)
Layer._getLayerType = _genwrap("getLayerType", ctypes.c_uint32, Layer, ctypes.c_char_p, ctypes.c_uint32)
Layer._getLayerElement = _genwrap("getLayerElement", DataElement, Layer)
Layer._getLayerView = _genwrap("getLayerView", View, Layer)
Layer._getLayerScaleOffset = _genwrap("getLayerScaleOffset", ctypes.c_int, Layer, ctypes.POINTER(ctypes.c_double), ctypes.POINTER(ctypes.c_double), ctypes.POINTER(ctypes.c_double), ctypes.POINTER(ctypes.c_double))
Layer._setLayerScaleOffset = _genwrap("setLayerScaleOffset", ctypes.c_int, Layer, ctypes.c_double, ctypes.c_double, ctypes.c_double, ctypes.c_double)
Layer._isLayerDisplayed = _genwrap("isLayerDisplayed", ctypes.c_int, Layer)
Layer._setLayerDisplayed = _genwrap("setLayerDisplayed", ctypes.c_int, Layer, ctypes.c_int)
Layer._getLayerDisplayIndex = _genwrap("getLayerDisplayIndex", ctypes.c_uint32, Layer)
Layer._setLayerDisplayIndex = _genwrap("setLayerDisplayIndex", ctypes.c_int, Layer, ctypes.c_uint32)
Layer._deriveLayer = _genwrap("deriveLayer", Layer, Layer, ctypes.c_char_p, ctypes.c_char_p)
Layer._convertLayer = _genwrap("convertLayer", Layer, Layer, ctypes.c_char_p)
Layer._isLayerActive = _genwrap("isLayerActive", ctypes.c_int, Layer)
Layer._activateLayer = _genwrap("activateLayer", ctypes.c_int, Layer)

class PassArea(ctypes.c_uint32):
   "Opticks PassAreaEnum type."
   LOWER = 0
   UPPER = 1
   MIDDLE = 2
   OUTSIDE = 3

   def __repr__(self):
      strname = "Unknown"
      if self.value == self.LOWER: strname = "Below 1st threshold"
      elif self.value == self.UPPER: strname = "Above 1st threshold"
      elif self.value == self.MIDDLE: strname = "Between 1st and 2nd thresholds"
      elif self.value == self.OUTSIDE: strname = "Outside 1st and 2nd thresholds"
      return "<PassArea: %s>" % strname

class RegionUnits(ctypes.c_uint32):
   "Opticks RegionUnitsEnum type."
   RAW_VALUE = 0
   PERCENTAGE = 1
   PERCENTILE = 2
   STD_DEV = 3

   def __repr__(self):
      strname = "Unknown"
      if self.value == self.RAW_VALUE: strname = "Raw value"
      elif self.value == self.PERCENTAGE: strname = "Percentage"
      elif self.value == self.PERCENTILE: strname = "Percentile"
      elif self.value == self.STD_DEV: strname = "Standard deviation"
      return "<RegionUnits: %s>" % strname

class StretchType(ctypes.c_uint32):
   "Opticks StretchTypeEnum type."
   LINEAR = 0
   LOGARITHMIC = 1
   EXPONENTIAL = 2
   EQUALIZE = 3

   def __repr__(self):
      strname = "Unknown"
      if self.value == self.LINEAR: strname = "Linear"
      elif self.value == self.LOGARITHMIC: strname = "Logarithmic"
      elif self.value == self.EXPONENTIAL: strname = "Exponential"
      elif self.value == self.EQUALIZE: strname = "Histogram Equalization"
      return "<StretchType: %s>" % strname

class Color(object):
   "Opticks Color type"

   def __init__(self, value=None, red=0, green=0, blue=0, alpha=255):
      if value is None:
         self.red, self.green, self.blue, self.alpha = red, green, blue, alpha
      elif isinstance(value, Color):
         # copy constructor
         self.red, self.green, self.blue, self.alpha = value.red, value.green, value.blue, value.alpha
      elif isinstance(value, str):
         if len(value) == 9 and value[0] == '#':
            from string import atoi
            self.red, self.green, self.blue, self.alpha = atoi(value[1:3], 16), atoi(value[3:5], 16), atoi(value[5:7], 16), atoi(value[7:9], 16)
         else:
            raise TypeError("Color initialation must be an encoded int, '#RRGGBBAA', '(red, green, blue)', '(red, green, blue, alpha)', or 'red=0, green=0, blue=0, alpha=255'")
      elif isinstance(value, tuple) and (len(value) == 3 or len(value) == 4):
         if len(value) == 3: value = value + (alpha, )
         self.red, self.green, self.blue, self.alpha = value
      elif isinstance(value, int) or isinstance(value, long):
         self.red, self.green, self.blue, self.alpha = (value >> 24) & 0xff, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff
      else:
         raise TypeError("Color initialation must be an encoded int, '#RRGGBBAA', '(red, green, blue)', '(red, green, blue, alpha)', or 'red=0, green=0, blue=0, alpha=255'")

   def __eq__(self, other):
      return self.red == other.red and self.green == other.green and self.blue == other.blue and self.alpha == other.alpha

   @property
   def value(self):
      return (self.red << 24) | (self.green << 16) | (self.blue << 8) | self.alpha

   def __repr__(self):
      return '#%02X%02X%02X%02X' % (self.red, self.green, self.blue, self.alpha)

class RasterChannel(ctypes.c_uint32):
   "Opticks RasterChannelEnum type."
   GRAY = 0
   RED = 1
   GREEN = 2
   BLUE = 3

   def __repr__(self):
      strname = "Unknown"
      if self.value == self.GRAY: strname = "gray/colormap/indexed"
      elif self.value == self.RED: strname = "red"
      elif self.value == self.GREEN: strname = "green"
      elif self.value == self.BLUE: strname = "blue"
      return "<RasterChannel: %s>" % strname

class ComplexComponent(ctypes.c_uint32):
   "Opticks ComplexComponentEnum type."
   MAGNITUDE = 0
   PHASE = 1
   INPHASE = 2
   QUADRATURE = 3

   def __repr__(self):
      strname = "Unknown"
      if self.value == self.MAGNITUDE: strname = "magnitude"
      elif self.value == self.PHASE: strname = "phase"
      elif self.value == self.INPHASE: strname = "in-phase"
      elif self.value == self.QUADRATURE: strname = "quadrature"
      return "<ComplexComponent: %s>" % strname

class ThresholdLayer(Layer):
   "A Threshold layer."

   class Info(ctypes.Structure):
      _fields_ = [('firstThreshold', ctypes.c_double),
                  ('secondThreshold', ctypes.c_double),
                  ('passArea', PassArea),
                  ('regionUnits', RegionUnits)]

      def __repr__(self):
         return "<ThresholdInfo: %f - %f %r %r>" % (self.firstThreshold, self.secondThreshold, self.passArea, self.regionUnits)

   def __init__(self, name=None, other=None):
      """Get a Threshold Layer by name.
         See Layer documentation for information on values for name.
         If other is specified the internal handle for that Layer will be copied to the new Layer.
         The typ value for the Layer contructor will be 'ThresholdLayer'.
         Other may be a Layer object which will be cast to a ThresholdLayer.
         """
      if other is not None:
         if not isinstance(other, Layer) or other.type != 'ThresholdLayer':
            raise TypeError("Layer is not a ThresholdLayer.")
         Layer.__init__(self, other=other)
      else:
         Layer.__init__(self, name=name, typ='ThresholdLayer')

   def getinfo(self):
      info = ThresholdLayer.Info()
      _genwrap('getThresholdLayerInfo', ctypes.c_int, Layer, ctypes.POINTER(ThresholdLayer.Info))(self, ctypes.byref(info))
      return info
   def setinfo(self, info):
      assert(isinstance(info, ThresholdLayer.Info))
      _genwrap('setThresholdLayerInfo', ctypes.c_int, Layer, ctypes.POINTER(ThresholdLayer.Info))(self, ctypes.byref(info))
   info = property(getinfo, setinfo, doc="Threshold parameters.")

   def getthresholds(self):
      info = self.info
      return info.firstThreshold, info.secondThreshold
   def setthresholds(self, (first, second)):
      info = self.info
      info.firstThreshold, info.secondThreshold = first, second
      self.info = info
   thresholds = property(getthresholds, setthresholds, doc="First and second thresholds")

   def getpassarea(self):
      return self.info.passArea
   def setpassarea(self, value):
      info = self.info
      info.passArea = value
      self.info = info
   passarea = property(getpassarea, setpassarea, doc="Pass area enum")

   def getregionunits(self):
      return self.info.regionUnits
   def setregionunits(self, value):
      info = self.info
      info.regionUnits = value
      self.info = info
   regionunits = property(getregionunits, setregionunits, doc="Region units enum")

class PseudocolorClass(object):
   "A pseudocolor class."

   _getPseudocolorClassName = _genwrap("getPseudocolorClassName", ctypes.c_uint32, Layer, ctypes.c_int32, ctypes.c_char_p, ctypes.c_uint32)
   _getPseudocolorClassValue = _genwrap("getPseudocolorClassValue", ctypes.c_int32, Layer, ctypes.c_int32)
   _getPseudocolorClassColor = _genwrap("getPseudocolorClassColor", ctypes.c_uint32, Layer, ctypes.c_int32)
   _isPseudocolorClassDisplayed = _genwrap("isPseudocolorClassDisplayed", ctypes.c_int, Layer, ctypes.c_int32)
   _setPseudocolorClassName = _genwrap("setPseudocolorClassName", ctypes.c_int, Layer, ctypes.c_int32, ctypes.c_char_p)
   _setPseudocolorClassValue = _genwrap("setPseudocolorClassValue", ctypes.c_int, Layer, ctypes.c_int32, ctypes.c_int32)
   _setPseudocolorClassColor = _genwrap("setPseudocolorClassColor", ctypes.c_int, Layer, ctypes.c_int32, ctypes.c_uint32)
   _setPseudocolorClassDisplayed = _genwrap("setPseudocolorClassDisplayed", ctypes.c_int, Layer, ctypes.c_int32, ctypes.c_int)

   def __init__(self, layer, id):
      self.__layer, self.__id = layer, id

   def __repr__(self):
      if self.displayed:
         return "<PseudocolorClass '%s' %i displayed as %s>" % (self.name, self.value, self.color)
      return "<PseudocolorClass '%s' %i hidden with color %s>" % (self.name, self.value, self.color)

   def getname(self):
      return _stringBufferWrap(self._getPseudocolorClassName, self.__layer, self.__id)
   def setname(self, name):
      self._setPseudocolorClassName(self.__layer, self.__id, name)
   name = property(getname, setname, doc="The pseudocolor class name.")

   def getvalue(self):
      return self._getPseudocolorClassValue(self.__layer, self.__id)
   def setvalue(self, value):
      self._setPseudocolorClassValue(self.__layer, self.__id, value)
   value = property(getvalue, setvalue, doc="The pseudocolor class value.")

   def getcolor(self):
      return Color(self._getPseudocolorClassColor(self.__layer, self.__id))
   def setcolor(self, color):
      if not isinstance(color, Color):
         color = PseudocolorClass.Color(color)
      self._setPseudocolorClassColor(self.__layer, self.__id, color.value)
   color = property(getcolor, setcolor, doc="The pseudocolor class color.")

   def getdisplayed(self):
      return bool(self._isPseudocolorClassDisplayed(self.__layer, self.__id))
   def setdisplayed(self, value):
      self._setPseudocolorClassDisplayed(self.__layer, self.__id, value)
   displayed = property(getdisplayed, setdisplayed, doc="Is the pseudocolor class displayed?")

class PseudocolorLayer(Layer):
   "A Pseudocolor layer."

   _getPseudocolorClassCount = _genwrap("getPseudocolorClassCount", ctypes.c_uint32, Layer)
   _getPseudocolorClassId = _genwrap("getPseudocolorClassId", ctypes.c_int32, Layer, ctypes.c_uint32)
   _addPseudocolorClass = _genwrap("addPseudocolorClass", ctypes.c_int32, Layer, ctypes.c_char_p, ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_int))

   def __init__(self, name=None, other=None):
      """Get a Pseudocolor Layer by name.
         See Layer documentation for information on values for name.
         If other is specified the internal handle for that Layer will be copied to the new Layer.
         The typ value for the Layer contructor will be 'PseudocolorLayer'.
         Other may be a Layer object which will be cast to a PseudocolorLayer.
         """
      if other is not None:
         if not isinstance(other, Layer) or other.type != 'PseudocolorLayer':
            raise TypeError("Layer is not a PseudocolorLayer.")
         Layer.__init__(self, other=other)
      else:
         Layer.__init__(self, name=name, typ='PseudocolorLayer')

   def __len__(self):
      return self._getPseudocolorClassCount(self)

   def __getitem__(self, index):
      return PseudocolorClass(self, self._getPseudocolorClassId(self, index))

   def __iter__(self):
      def doiter(layer, cnt):
         for index in xrange(cnt):
            yield layer[index]
      return doiter(self, len(self))

   def addClass(self, name=None, value=None, color=None, displayed=None):
      """Add a new class.
         If name, value, color, and displayed are not None, the class is initialized to those values.
         If any of name, value, color, or displayed is None, an uninitialized class is created."""
      if name is not None and value is not None and color is not None and displayed is not None:
         if not isinstance(value, ctypes.c_int32): value = ctypes.c_int32(value)
         if not isinstance(color, Color): color = Color(color)
         color = ctypes.c_uint32(color.value)
         if displayed: displayed = ctypes.c_int(1)
         else: displayed = ctypes.c_int(0)
         return PseudocolorClass(self, self._addPseudocolorClass(self, name, ctypes.byref(value), ctypes.byref(color), ctypes.byref(displayed)))
      return PseudocolorClass(self, self._addPseudocolorClass(self, None, None, None, None))

class RasterLayerStretchInfo(ctypes.Structure):
   _fields_ = [('lowerStretch', ctypes.c_double),
               ('upperStretch', ctypes.c_double),
               ('stretchType', StretchType),
               ('stretchUnits', RegionUnits)]

   def __repr__(self):
      return "<RasterLayerStretchInfo: %f-%f, type %s, units %s>" % (self.lowerStretch, self.upperStretch, self.stretchType, self.stretchUnits)

class RasterStatistics(ctypes.Structure):
   _fields_ = [('min', ctypes.c_double),
               ('max', ctypes.c_double),
               ('mean', ctypes.c_double),
               ('stddev', ctypes.c_double),
               ('_histogramCenters', ctypes.POINTER(ctypes.c_double)),
               ('_histogramCounts', ctypes.POINTER(ctypes.c_uint)),
               ('_percentiles', ctypes.POINTER(ctypes.c_double)),
               ('resolution', ctypes.c_uint32)]
   @property
   def histogramCenters(self):
      if hasattr(self, "_storedCenters"):
         return self._storedCenters
      self._storedCenters = self._histogramCenters[:256]
      return self._storedCenters

   @property
   def histogramCounts(self):
      if hasattr(self, "_storedCounts"):
         return self._storedCounts
      self._storedCounts = self._histogramCounts[:256]
      return self._storedCounts

   @property
   def percentiles(self):
      if hasattr(self, "_storedPercentiles"):
         return self._storedPercentiles
      self._storedPercentiles = self._percentiles[:1001]
      return self._storedPercentiles

   def __repr__(self):
      return "<RasterStatistics: %i resolution>" % self.resolution

class RasterLayer(Layer):
   "A Raster layer."

   _getRasterLayerStretchInfo = _genwrap("getRasterLayerStretchInfo", ctypes.c_int, Layer, RasterChannel, ctypes.POINTER(RasterLayerStretchInfo))
   _setRasterLayerStretchInfo = _genwrap("setRasterLayerStretchInfo", ctypes.c_int, Layer, RasterChannel, ctypes.POINTER(RasterLayerStretchInfo))
   _getRasterLayerComplexComponent = _genwrap("getRasterLayerComplexComponent", ComplexComponent, Layer)
   _setRasterLayerComplexComponent = _genwrap("setRasterLayerComplexComponent", ctypes.c_int, Layer, ComplexComponent)
   _getRasterLayerColormapName = _genwrap("getRasterLayerColormapName", ctypes.c_uint32, Layer, ctypes.c_char_p, ctypes.c_uint32)
   _setRasterLayerColormapName = _genwrap("setRasterLayerColormapName", ctypes.c_int, Layer, ctypes.c_char_p)
   _getRasterLayerColormapValues = _genwrap("getRasterLayerColormapValues", ctypes.c_int, Layer, ctypes.POINTER(ctypes.c_uint32))
   _setRasterLayerColormapValues = _genwrap("setRasterLayerColormapValues", ctypes.c_int, Layer, ctypes.c_char_p, ctypes.POINTER(ctypes.c_uint32))
   _getRasterLayerGpuEnabled = _genwrap("getRasterLayerGpuEnabled", ctypes.c_int, Layer);
   _setRasterLayerGpuEnabled = _genwrap("setRasterLayerGpuEnabled", ctypes.c_int, Layer, ctypes.c_int);
   _getRasterLayerFilterCount = _genwrap("getRasterLayerFilterCount", ctypes.c_uint32, Layer, ctypes.c_int)
   _getRasterLayerFilterName = _genwrap("getRasterLayerFilterName", ctypes.c_uint32, Layer, ctypes.c_uint32, ctypes.c_int, ctypes.c_char_p, ctypes.c_uint32)
   _setRasterLayerFilters = _genwrap("setRasterLayerFilters", ctypes.c_int, Layer, ctypes.c_uint32, ctypes.POINTER(ctypes.c_char_p))
   _resetRasterLayerFilter = _genwrap("resetRasterLayerFilter", ctypes.c_int, Layer, ctypes.c_char_p)
   _setRasterLayerFilterFrozen = _genwrap("setRasterLayerFilterFrozen", ctypes.c_int, Layer, ctypes.c_char_p, ctypes.c_int)
   _isRasterLayerRgbDisplayed = _genwrap("isRasterLayerRgbDisplayed", ctypes.c_int, Layer);
   _setRasterLayerRgbDisplayed = _genwrap("setRasterLayerRgbDisplayed", ctypes.c_int, Layer, ctypes.c_int);
   _getRasterLayerDisplayedBand = _genwrap("getRasterLayerDisplayedBand", ctypes.c_uint32, Layer, RasterChannel, ctypes.POINTER(ctypes.c_void_p));
   _setRasterLayerDisplayedBand = _genwrap("setRasterLayerDisplayedBand", ctypes.c_int, Layer, RasterChannel, ctypes.c_uint32, DataElement);
   _getRasterLayerStatistics = _genwrap("getRasterLayerStatistics", ctypes.c_int, Layer, RasterChannel, ComplexComponent, ctypes.POINTER(RasterStatistics));

   def __init__(self, name=None, other=None):
      """Get a Raster Layer by name.
         See Layer documentation for information on values for name.
         If other is specified the internal handle for that Layer will be copied to the new Layer.
         The typ value for the Layer contructor will be 'RasterLayer'.
         Other may be a Layer object which will be cast to a RasterLayer.
         """
      if other is not None:
         if not isinstance(other, Layer) or other.type != 'RasterLayer':
            raise TypeError("Layer is not a RasterLayer.")
         Layer.__init__(self, other=other)
      else:
         Layer.__init__(self, name=name, typ='RasterLayer')

   def getstretch(self, channel):
      nfo = RasterLayerStretchInfo()
      self._getRasterLayerStretchInfo(self, channel, ctypes.byref(nfo))
      return nfo

   def setstretch(self, channel, nfo):
      self._setRasterLayerStretchInfo(self, channel, ctypes.byref(nfo))

   def getcomplexcomponent(self):
      return self._getRasterLayerComplexComponent(self)
   def setcomplexcomponent(self, value):
      self._setRasterLayerComplexComponent(self, value)
   complexcomponent = property(getcomplexcomponent, setcomplexcomponent, doc="Complex component displayed.")

   def getcolormapname(self):
      return _stringBufferWrap(self._getRasterLayerColormapName, self)
   def setcolormapname(self, name):
      self._setRasterLayerColormapName(self, name)
   colormapname = property(getcolormapname, setcolormapname, doc="Internal name or filename of the colormap.")

   def getcolormap(self):
      cmap = (ctypes.c_uint32 * 256)()
      self._getRasterLayerColormapValues(self, cmap)
      return map(Color, cmap)
   def setcolormap(self, value, name=None):
      "Set a new colormap. Value is a sequence of 256 colors. name is an optional name to associate with the colormap."
      if len(value) != 256:
         raise ValueError("Colormap must be a sequence of 256 colors.")
      cmap = (ctypes.c_uint32 * 256)()
      cmap[:] = map(lambda x: Color(x).value, value)
      self._setRasterLayerColormapValues(self, name, cmap)
   colormap = property(getcolormap, setcolormap, doc="Colormap table which is applied when in grayscale/colormap/indexed display mode.")

   def getgpuenabled(self):
      return bool(self._getRasterLayerGpuEnabled(self))
   def setgpuenabled(self, value):
      self._setRasterLayerGpuEnabled(self, value)
   gpuenabled = property(getgpuenabled, setgpuenabled, doc="Is the GPU rendering this layer?")

   def getrgbdisplayed(self):
      return bool(self._isRasterLayerRgbDisplayed(self))
   def setrgbdisplayed(self, value):
      self._setRasterLayerRgbDisplayed(self, value)
   rgbdisplayed = property(getrgbdisplayed, setrgbdisplayed)

   def getdisplayedband(self, channel):
      rval = ctypes.c_void_p(0)
      bandnum = self._getRasterLayerDisplayedBand(self, channel, ctypes.byref(rval))
      if not rval:
         re = None
      else:
         de = DataElement(subtypeAsVoid=rval, typ="RasterElement")
         re = RasterElement(element=de)
      return (bandnum, re)

   def setdisplayedband(self, channel, band, element=None):
      if element is None:
         (num, re) = self.getdisplayedband(channel)
         if re is not None:
            self._setRasterLayerDisplayedBand(self, channel, band, re)
      else:
         self._setRasterLayerDisplayedBand(self, channel, band, element)

   def setrgbbands(self, red=None, green=None, blue=None):
      self.setrgbdisplayed(True)
      if red is not None:
         self.setdisplayedband(RasterChannel.RED, red, self.element)
      if green is not None:
         self.setdisplayedband(RasterChannel.GREEN, green, self.element)
      if blue is not None:
         self.setdisplayedband(RasterChannel.BLUE, blue, self.element)

   def setgrayband(self, gray):
      self.setrgbdisplayed(False)
      self.setdisplayedband(RasterChannel.GRAY, gray, self.element)

   def getstatistics(self, channel, component=ComplexComponent.MAGNITUDE):
      stat = RasterStatistics()
      self._getRasterLayerStatistics(self, channel, component, stat)
      return stat

   @property
   def filters(self):
      rval = []
      for index in range(self._getRasterLayerFilterCount(self, 0)):
         rval.append(_stringBufferWrap(self._getRasterLayerFilterName, self, index, 0))
      return rval

   def getenabledfilters(self):
      rval = []
      for index in range(self._getRasterLayerFilterCount(self, 1)):
         rval.append(_stringBufferWrap(self._getRasterLayerFilterName, self, index, 1))
      return rval
   def setenabledfilters(self, value):
      value = list(value)
      count = len(value)
      filters = (ctypes.c_char_p * count)()
      filters[:] = value
      self._setRasterLayerFilters(self, count, filters)
   enabledfilters = property(getenabledfilters, setenabledfilters, doc="Currently enabled GPU filters.")

   def resetFilter(self, filter):
      "Reset a feedback filter. If filter is not a feedback filter, do nothing."
      self._resetRasterLayerFilter(self, filter)

   def freezeFilter(self, filter, freeze=True):
      "Freeze of unfreeze a feedback filter. If filter is not a feedback filter, do nothing."
      self._setRasterLayerFilterFrozen(self, filter, int(freeze))

class AnimationState(ctypes.c_uint32):
   "Opticks AnimationState type."
   STOP = 0
   PLAY_FORWARD = 1
   PLAY_BACKWARD = 2
   PAUSE_FORWARD = 3
   PAUSE_BACKWARD = 4

   def __repr__(self):
      if self.value == self.STOP: return "<AnimationState: stopped>"
      elif self.value == self.PLAY_FORWARD: return "<AnimationState: playing forward>"
      elif self.value == self.PLAY_BACKWARD: return "<AnimationState: playing backward>"
      elif self.value == self.PAUSE_FORWARD: return "<AnimationState: paused, will resume forward>"
      elif self.value == self.PAUSE_BACKWARD: return "<AnimationState: paused, will resume backward>"
      return "<AnimationState: unknown value>"

class AnimationCycle(ctypes.c_uint32):
   "Opticks AnimationCycle type."
   PLAY_ONCE = 0
   REPEAT = 1
   BOUNCE = 2

   def __repr__(self):
      if self.value == self.PLAY_ONCE: return "<AnimationCycle: play once>"
      elif self.value == self.REPEAT: return "<AnimationCycle: repeat>"
      elif self.value == self.BOUNCE: return "<AnimationCycle: bounce>"
      return "<AnimationCycle: unknown value>"

animation_callback_t = ctypes.CFUNCTYPE(None, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_uint32, ctypes.c_double, ctypes.c_void_p)

class Animation(ctypes.Structure):
   _fields_ = [("handle", ctypes.c_void_p)]
   __owns = False

   def __init__(self, name=None, create=False, timeBased=True):
      """Get an animation by name. If name is none, get the active animation
         If create is True and the animation
         does not exist, it will be created. If created, timeBased will
         determine if the animation is time based of frame based."""
      self.__owns = False
      try:
         self.handle = _genwrap("getAnimationController", Animation, ctypes.c_char_p)(name).handle
      except SimpleApiError, e:
         if not create:
            raise
         self.handle = _genwrap("createAnimationController", Animation, ctypes.c_char_p, ctypes.c_int)(name, timeBased).handle

   def __del__(self):
      if self.__owns:
         self._destroyAnimationController(self)

   def destroy(self, val=True):
      """Mark this animation for destruction. When the animation object is garbage
         collected it will be destroyed. If val is False, destruction will be cancelled."""
      self.__owns = val

   def getstate(self):
      return self._getAnimationControllerState(self)
   def setstate(self, value):
      if not isinstance(value, AnimationState):
         value = AnimationState(value)
      self._setAnimationControllerState(self, value)
   state = property(getstate, setstate, doc="Playback state of the animation.")

   def getcycle(self):
      return self._getAnimationControllerCycle(self)
   def setcycle(self, value):
      if not isinstance(value, AnimationCycle):
         value = AnimationCycle(value)
      self._setAnimationControllerCycle(self, value)
   cycle = property(getcycle, setcycle, doc="Cycle mode of the animation.")

   def getcandropframes(self):
      return bool(self._canAnimationControllerDropFrames(self))
   def setcandropframes(self, value):
      self._setAnimationControllerCanDropFrames(self, value)
   candropframes = property(getcandropframes, setcandropframes, doc="""Allow the controller to drop
frames if necessary to maintain the frame rate.""")

   def getintervalmultiplier(self):
      return self._getAnimationControllerIntervalMultiplier(self)
   def setintervalmultiplier(self, value):
      self._setAnimationControllerIntervalMultiplier(self, value)
   intervalmultiplier = property(getintervalmultiplier, setintervalmultiplier, doc="Adjust the speed of playback.")

   def activate(self):
      "Make this animation active in the animation toolbar."
      self._activateAnimationController(self)

   def attach(self, raster):
      "Attach a raster element to an animation. Raster must be a raster layer."
      self._attachRasterLayerToAnimationController(self, raster)

   def callback(self, name, callbackFunc, frameCount, frameTimes=None, userData=None):
      """Attach a callbackFunc to an animation.
         If callbackFunc is a Python callable, it will be wrapped with animation_callback_t.
         name is the name for the new attachment.
         frameCount is the number of frames. Each time a frame is `displayed' callbackFunc
         will be executed.
         If the animation is time based, frameTimes can be a list of real values indicating
         playback times. The list must be of length equal to frameCount. If frameTimes is None,
         times will be generated for 1fps playback.
         userData will be passed as is to the callback function."""
      typ = (ctypes.c_double * frameCount)
      if frameTimes is not None and not isinstance(frameTimes, typ):
         if len(frameTimes) != frameCount:
            raise TypeError("`frameTimes' must be None or a list of length %i" % frameCount)
         tmp = typ()
         for idx in xrange(frameCount):
            tmp[idx] = frameTimes[idx]
         frameTimes = tmp
      if not isinstance(callbackFunc, animation_callback_t):
         callbackFunc = animation_callback_t(callbackFunc)
      hndl = ctypes.c_void_p(self._attachCallbackToAnimationController(self, name, callbackFunc, userData, frameCount, frameTimes))
      class deleterobj(object):
         def __init__(self, cntrl, name, hndl, cbFunc):
            self.__cntrl, self.__name, self.__hndl, self.__cbFunc = cntrl, name, hndl, cbFunc
         def __del__(self):
            w = _genwrap("destroyAnimationControllerAttachment", None, Animation, ctypes.c_char_p, ctypes.c_void_p, errorCheck=False)
            w(self.__cntrl, self.__name, self.__hndl)
            del self.__cbFunc
      return deleterobj(self, name, hndl, callbackFunc)

   def play(self):
      self._playAnimationController(self)

   def pause(self):
      self._pauseAnimationController(self)

   def stop(self):
      self._stopAnimationController(self)

Animation._destroyAnimationController = _genwrap("destroyAnimationController", None, Animation, errorCheck=False)
Animation._activateAnimationController = _genwrap("activateAnimationController", ctypes.c_int, Animation)
Animation._getAnimationControllerState = _genwrap("getAnimationControllerState", AnimationState, Animation)
Animation._setAnimationControllerState = _genwrap("setAnimationControllerState", ctypes.c_int, Animation, AnimationState)
Animation._playAnimationController = _genwrap("playAnimationController", ctypes.c_int, Animation)
Animation._pauseAnimationController = _genwrap("pauseAnimationController", ctypes.c_int, Animation)
Animation._stopAnimationController = _genwrap("stopAnimationController", ctypes.c_int, Animation)
Animation._getAnimationControllerCycle = _genwrap("getAnimationControllerCycle", AnimationCycle, Animation)
Animation._setAnimationControllerCycle = _genwrap("setAnimationControllerCycle", ctypes.c_int, Animation, AnimationCycle)
Animation._canAnimationControllerDropFrames = _genwrap("canAnimationControllerDropFrames", ctypes.c_int, Animation)
Animation._setAnimationControllerCanDropFrames = _genwrap("setAnimationControllerCanDropFrames", ctypes.c_int, Animation, ctypes.c_int)
Animation._getAnimationControllerIntervalMultiplier = _genwrap("getAnimationControllerIntervalMultiplier", ctypes.c_double, Animation)
Animation._setAnimationControllerIntervalMultiplier = _genwrap("setAnimationControllerIntervalMultiplier", ctypes.c_int, Animation, ctypes.c_double)
Animation._attachRasterLayerToAnimationController = _genwrap("attachRasterLayerToAnimationController", ctypes.c_int, Animation, Layer)
Animation._attachCallbackToAnimationController = _genwrap("attachCallbackToAnimationController", ctypes.c_void_p, Animation, ctypes.c_char_p, animation_callback_t, ctypes.c_void_p, ctypes.c_uint32, ctypes.POINTER(ctypes.c_double))

class Gcp(ctypes.Structure):
   _fields_ = [("pixelX", ctypes.c_double),
               ("pixelY", ctypes.c_double),
               ("__reserved1", ctypes.c_double),
               ("latitude", ctypes.c_double),
               ("longitude", ctypes.c_double),
               ("__reserved2", ctypes.c_double),
               ("rmsErrorLatitude", ctypes.c_double),
               ("rmsErrorLongitude", ctypes.c_double),
               ("__reserved3", ctypes.c_double)]

   def __repr__(self):
      return "<GCP Point (%5.2f, %5.2f)->(%3.8f,%3.8f) err: (%.8f,%.8f)>" % (
                               self.pixelX, self.pixelY,
                               self.latitude, self.longitude,
                               self.rmsErrorLatitude, self.rmsErrorLongitude)

   def __eq__(self, other):
      return self.pixelX == other.pixelX and self.pixelY == other.pixelY and self.latitude == other.latitude and self.longitude == other.longitude

def getGcpPoints(gcpList=None):
   "Get the list of GCP points and return them as a python list-like object"
   cnt = _getGcpCount(gcpList)
   lst = (Gcp * cnt)()
   _getGcpPoints(gcpList, ctypes.cast(lst, ctypes.POINTER(Gcp)))
   return lst

def setGcpPoints(gcpList=None, points=[]):
   "Set the list of GCP points from a python list-like objects"
   cnt = len(points)
   typ = (Gcp * cnt)
   if type(points) != type:
      tmp = typ()
      for idx in range(cnt):
         tmp[idx] = points[idx]
      points = tmp
   _setGcpPoints(gcpList, cnt, ctypes.cast(points, ctypes.POINTER(Gcp)))
   return cnt

_getGcpCount = _genwrap("getGcpCount", ctypes.c_uint32, DataElement)
_getGcpPoint = _genwrap("getGcpPoint", Gcp, DataElement, ctypes.c_uint32)
_getGcpPoints = _genwrap("getGcpPoints", ctypes.c_uint32, DataElement, ctypes.POINTER(Gcp))
_setGcpPoints = _genwrap("setGcpPoints", ctypes.c_uint32, DataElement, ctypes.c_uint32, ctypes.POINTER(Gcp))

