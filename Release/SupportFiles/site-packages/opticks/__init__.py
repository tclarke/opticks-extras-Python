"""Welcome to the Opticks Python scripting engine.

Please note that certain functionality is not available in the interpreter
window, most notably the raw_input() function. This prevents the
proper functioning of help(), license(),
and similar functions although help(object) will work.

"""
# Initialize the connection to Opticks.
import _opticks
import sys
import ctypes

__copyright__ = """The information in this file is
 Copyright(c) 2009 Ball Aerospace & Technologies Corporation
 and is subject to the terms and conditions of the
 GNU Lesser General Public License Version 2.1
 The license text is available from
 http://www.gnu.org/licenses/lgpl.html"""

class OpticksError(Exception):
    pass

class SimpleApiError(OpticksError):
    """Python exception wrapper for a Simple API error.
    The 'code' member contains the numeric error code.
    The 'message' member contains the user readable error message.
    The 'result' member contains the return result from the original
    function call.

    """

    SIMPLE_NO_ERROR = 0
    SIMPLE_WRONG_TYPE = 1
    SIMPLE_NOT_FOUND = 2
    SIMPLE_BAD_PARAMS = 3
    SIMPLE_BUFFER_SIZE = 4
    SIMPLE_NO_MEM = 5
    SIMPLE_EXISTS = 6
    SIMPLE_WRONG_VIEW_TYPE = 7
    SIMPLE_OTHER_FAILURE = -1

    def __init__(self, code, result=None):
        OpticksError.__init__(self, code, self._getErrorString(code))
        self.code = code
        self.message = self._getErrorString(code)
        self.result = result

def _simple_error_check(result, func, args):
    """This errcheck function queries the last error state
    and raises an exception if an error occured

    """
    #pylint: disable=W0212,W0613
    err = SimpleApiError._get_last_error()
    if err != SimpleApiError.SIMPLE_NO_ERROR:
        raise SimpleApiError(err, result)
    return args


try:
    if sys.platform == 'linux2':
        __API = ctypes.CDLL("libSimpleApiLib.so")
    else:
        __API = ctypes.CDLL("SimpleApiLib")
    pyobj = ctypes.py_object(_opticks.handle())
    __API.setHandle(ctypes.pythonapi.PyCObject_AsVoidPtr(pyobj))
    def _genwrap(name, *args, **kargs):
        """Create a wrapper function for an API function.
        First arg is the name of the C function.
        Second arg is the return type (a ctypes type or None for void).
        Remaining args are the ctypes types for the function arguments.
        The 'errorCheck' keyword is a bool indicating if checks should be
        made for Simple API errors. These errors will be turned into
        a SimpleApiError exception. The default is to include
        error checking.

        """
        prototype = apply(ctypes.CFUNCTYPE, args)
        func = prototype((name, __API))
        error_check = kargs.get('errorCheck', True)
        if error_check:
            func.errcheck = _simple_error_check
        return func
except EnvironmentError:
    print "ERROR: The SimpleApiLib dynamic library could not be located. "\
          "The opticks module WILL NOT FUNCTION PROPERLY."
    def _genwrap(name, *args, **kargs):
        #pylint: disable=W0613
        def dummy_placeholder(*args, **kargs):
            raise RuntimeError("Must be run from within Opticks application")
        return dummy_placeholder

def version_info():
    """Return a tuple containing (Opticks version, Python PlugIn Version)
    as strings.

    """
    tempf = _genwrap("getOpticksVersion", ctypes.c_uint32,
                     ctypes.c_char_p, ctypes.c_uint32)
    over = _stringbuffer_wrap(tempf)
    pver = _opticks.pythonVersion()
    return over, pver

def _stringbuffer_wrap(func, *args, **kargs):
    """This function calls a
    'ctypes.c_uint32 func(ctypes.c_char_p, ctypes.c_uin32)' function and
    returns a python string. Pass in the python function
    (usually created with '_genwrap()'). The minimal buffer size will
    be calculated before retrieving the string. The 'defaultBufferSize'
    keyword allows specification of an initial buffer size. This may
    result in a single function call instead of two. The default is to
    always calculate the minimum buffer size. If remaining args are
    present, they will be passed to 'func' before the buffer argument.

    """
    default_buffersize = kargs.get('defaultBufferSize', 0)
    buf = ctypes.create_string_buffer(default_buffersize)
    tmpargs = args + (buf, ctypes.sizeof(buf))
    size = apply(func, tmpargs)
    if size > ctypes.sizeof(buf):
        ctypes.resize(buf, size)
        tmpargs = args + (buf, ctypes.sizeof(buf))
        apply(func, tmpargs)
    return ctypes.string_at(buf)

SimpleApiError._get_last_error = \
    _genwrap("getLastError", ctypes.c_int, errorCheck=False)
SimpleApiError._set_last_error = \
    _genwrap("setLastError", None, ctypes.c_int, errorCheck=False)
SimpleApiError._getErrorString = \
    _genwrap("getErrorString", ctypes.c_char_p, ctypes.c_int, errorCheck=False)

def _void_p_to_native(typename, value):
    #pylint: disable=W0212
    typ = None
    isvector = False
    if typename.startswith("vector<"):
        typename = typename[7:-1]
        isvector = True
    if typename == "char":
        typ = ctypes.c_byte
    elif typename == "unsigned char":
        typ = ctypes.c_ubyte
    elif typename == "short":
        typ = ctypes.c_short
    elif typename == "unsigned short":
        typ = ctypes.c_ushort
    elif typename == "int":
        typ = ctypes.c_int
    elif typename == "unsigned int":
        typ = ctypes.c_uint
    elif typename == "long":
        typ = ctypes.c_long
    elif typename == "unsigned long":
        typ = ctypes.c_ulong
    elif typename == "Int64" or typename == "int64":
        typ = ctypes.c_longlong
    elif typename == "UInt64" or typename == "uint64":
        typ = ctypes.c_ulonglong
    elif typename == "float":
        typ = ctypes.c_float
    elif typename == "double":
        typ = ctypes.c_double
    else:
        return ctypes.cast(value, ctypes.c_void_p)
    if isvector:
        rval = ctypes.c_void_p(0)
        size = DataVariant._vectorToArray(value, "vector<%s>" % typename,
                                          ctypes.byref(rval))
        size /= ctypes.sizeof(typ)
        typ = typ * size
        return ctypes.cast(rval, ctypes.POINTER(typ)).contents
    return ctypes.cast(value, ctypes.POINTER(typ)).contents.value

def _prep_for_set(value, typ):
    #pylint: disable=W0212
    retval = None
    if isinstance(value, (DataVariant, ctypes.c_void_p)):
        retval = value
    elif isinstance(value, DataElement):
        rval = value.cast_data_element(typ)
        if rval != 0:
            retval = ctypes.c_void_p(rval)
    elif typ == "char":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_byte(value)),
                             ctypes.c_void_p)
    elif typ == "short":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_short(value)),
                             ctypes.c_void_p)
    elif typ == "int":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_int(value)),
                             ctypes.c_void_p)
    elif typ == "long":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_long(value)),
                             ctypes.c_void_p)
    elif typ == "Int64":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_longlong(value)),
                             ctypes.c_void_p)
    elif typ == "unsigned char":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_ubyte(value)),
                             ctypes.c_void_p)
    elif typ == "unsigned short":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_ushort(value)),
                             ctypes.c_void_p)
    elif typ == "unsigned int":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_uint(value)),
                             ctypes.c_void_p)
    elif typ == "unsigned long":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_ulong(value)),
                             ctypes.c_void_p)
    elif typ == "UInt64":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_ulonglong(value)),
                             ctypes.c_void_p)
    elif typ == "float":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_float(value)),
                             ctypes.c_void_p)
    elif typ == "double":
        retval = ctypes.cast(ctypes.pointer(ctypes.c_double(value)),
                             ctypes.c_void_p)
    else: # try an XML string conversion
        retval = DataVariant._createDataVariantFromString(typ, str(value), 1)
    return retval

class DataElement(ctypes.Structure, object):
    "An Opticks data element handle."
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, name=None, create=False, subtype_as_void=None, typ=None):
        """Get a DataElement.
        If name is passed, the DataElement with that name is accessed.
        If subtype_as_void and typ are passed, the subtype specificed
        in typ is dynamic_cast to a DataElement.
        If create is True and typ is specified, an attempt is made
        to create the element if it does not exist.

        """
        ctypes.Structure.__init__(self)
        assert((name is not None and subtype_as_void is None) or \
               (name is None and subtype_as_void is not None))
        if name is not None:
            tempf = _genwrap("getDataElement", DataElement,
                             ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int)
            self.handle = tempf(name, typ, int(create)).handle
        else:
            tempf = _genwrap("castToDataElement", DataElement,
                             ctypes.c_void_p, ctypes.c_char_p)
            self.handle = tempf(subtype_as_void, typ).handle
        self.__owns = False

    def __del__(self):
        if self.__owns:
            tempf = _genwrap("destroyDataElement", None, DataElement,
                             errorCheck=False)
            tempf(self)

    def destroy(self, val=True):
        self.__owns = val

    @property
    def name(self):
        return _stringbuffer_wrap(self._getDataElementName, self)

    @property
    def type(self):
        return _stringbuffer_wrap(self._getDataElementType, self)

    @property
    def filename(self):
        return _stringbuffer_wrap(self._getDataElementFilename, self)

    @property
    def metadata(self):
        return DynamicObject(self)

    @property
    def children(self):
        class ChildList(object):
            #pylint: disable=W0212
            def __init__(self, element):
                self.element = element

            def __len__(self):
                return self.element._getDataElementChildCount(self.element)

            def __getitem__(self, index):
                if index >= len(self):
                    raise IndexError
                return self.element._getDataElementChild(self.element, index)
        return ChildList(self)

    def cast_data_element(self, typ):
        return self._cast_data_element(self, typ)

    def copy_classification(self, element):
        return self._copy_classification(element, self)

DataElement._cast_data_element = \
    _genwrap("castDataElement", ctypes.c_void_p, DataElement, ctypes.c_char_p)
DataElement._getDataElementName = \
    _genwrap("getDataElementName", ctypes.c_uint32, DataElement,
             ctypes.c_char_p, ctypes.c_uint32)
DataElement._getDataElementType = \
    _genwrap("getDataElementType", ctypes.c_uint32, DataElement,
             ctypes.c_char_p, ctypes.c_uint32)
DataElement._getDataElementFilename = \
    _genwrap("getDataElementFilename", ctypes.c_uint32, DataElement,
             ctypes.c_char_p, ctypes.c_uint32)
DataElement._getDataElementChildCount = \
    _genwrap("getDataElementChildCount", ctypes.c_uint32, DataElement)
DataElement._getDataElementChild = \
    _genwrap("getDataElementChild", DataElement, DataElement, ctypes.c_uint32)
DataElement._copy_classification = \
    _genwrap("copyClassification", None, DataElement, DataElement)

class DataVariant(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, value=None, vtype=None, xml=True):
        ctypes.Structure.__init__(self)
        if isinstance(value, DataVariant):
            self.handle, self.__owns = value.handle, False
            return
        self.__owns = True
        import types
        if vtype is not None and not isinstance(value, ctypes.c_void_p):
            self.handle = \
                DataVariant._createDataVariantFromString(str(vtype),
                                                         str(value),
                                                         xml).handle
            return
        if vtype is None and value is not None:
            vtype = None
            if type(value) == types.StringType:
                self.handle = \
                    DataVariant._createDataVariantFromString("string",
                                                             str(value),
                                                             1).handle
                return
            elif type(value) == types.IntType or type(value) == types.LongType:
                if value < 0:
                    if value > -(2**(ctypes.sizeof(ctypes.c_byte)*8)/2):
                        vtype = "char"
                        value = ctypes.pointer(ctypes.c_byte(value))
                    elif value > -(2**(ctypes.sizeof(ctypes.c_short)*8)/2):
                        vtype = "short"
                        value = ctypes.pointer(ctypes.c_short(value))
                    elif value > -(2**(ctypes.sizeof(ctypes.c_int)*8)/2):
                        vtype = "int"
                        value = ctypes.pointer(ctypes.c_int(value))
                    elif value > -(2**(ctypes.sizeof(ctypes.c_long)*8)/2):
                        vtype = "long"
                        value = ctypes.pointer(ctypes.c_long(value))
                    elif value > -(2**(ctypes.sizeof(ctypes.c_longlong)*8)/2):
                        vtype = "Int64"
                        value = ctypes.pointer(ctypes.c_longlong(value))
                else:
                    if value < 2**(ctypes.sizeof(ctypes.c_ubyte)*8):
                        vtype = "unsigned char"
                        value = ctypes.pointer(ctypes.c_ubyte(value))
                    elif value < 2**(ctypes.sizeof(ctypes.c_ushort)*8):
                        vtype = "unsigned short"
                        value = ctypes.pointer(ctypes.c_ushort(value))
                    elif value < 2**(ctypes.sizeof(ctypes.c_uint)*8):
                        vtype = "unsigned int"
                        value = ctypes.pointer(ctypes.c_uint(value))
                    elif value < 2**(ctypes.sizeof(ctypes.c_ulong)*8):
                        vtype = "unsigned long"
                        value = ctypes.pointer(ctypes.c_ulong(value))
                    elif value < 2**(ctypes.sizeof(ctypes.c_ulonglong)*8):
                        vtype = "UInt64"
                        value = ctypes.pointer(ctypes.c_ulonglong(value))
            elif type(value) == types.FloatType:
                vtype, value = "float", ctypes.pointer(ctypes.c_float(value))
            else:
                raise OpticksError("Can't automatically convert %s." %
                                   str(type(value)))
        self.handle = self._createDataVariant(vtype, value).handle

    def __del__(self):
        if self.__owns:
            self._freeDataVariant(self)

    def __repr__(self):
        if not self.valid:
            return "<DataVariant: invalid>"
        return "<DataVariant: '%s' type: '%s'>" % (self.xml, self.dv_type)

    @property
    def display(self):
        if not self.valid:
            return None
        return _stringbuffer_wrap(self._getDataVariantValueString, self, 0)

    @property
    def xml(self):
        if not self.valid:
            return None
        return _stringbuffer_wrap(self._getDataVariantValueString, self, 1)

    @property
    def valid(self):
        return bool(self._isDataVariantValid(self))

    @property
    def dv_type(self):
        if not self.valid:
            return ""
        buf = ctypes.create_string_buffer(32)
        self._getDataVariantTypeName(self, buf, 32)
        return ctypes.string_at(buf)

    @property
    def value(self):
        if self.dv_type == "string": # special case..can't handle std::string
            return self.xml
        return _void_p_to_native(self.dv_type, self._getDataVariantValue(self))

class PlugInArgList(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __del__(self):
        if self.__owns:
            self._freePlugInArgList(self)

    def __repr__(self):
        return "PlugInArgList(%i)" % self.handle.value

    def __len__(self):
        return self._getPlugInArgCount(self)

    def __getitem__(self, key):
        from types import IntType
        if type(key) == IntType:
            return self._getPlugInArgByIndex(self, key)
        return self._getPlugInArgByName(self, key)

    def keys(self):
        #pylint: disable=W0212
        rval = []
        for idx in range(len(self)):
            argref = self._getPlugInArgByIndex(self, idx)
            rval.append(_stringbuffer_wrap(PlugInArg._getPlugInArgName,
                                           argref))
        return rval

class PlugInArg(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __repr__(self):
        return "PlugInArg(%i)" % self.handle

    @property
    def name(self):
        return _stringbuffer_wrap(self._getPlugInArgName, self)

    @property
    def type(self):
        return _stringbuffer_wrap(self._getPlugInArgTypeName, self)

    @property
    def description(self):
        return _stringbuffer_wrap(self._getPlugInArgDescription, self)

    @property
    def default_set(self):
        return bool(self._isPlugInArgDefaultSet(self))

    @property
    def actual_set(self):
        return bool(self._isPlugInArgActualSet(self))

    @property
    def value(self):
        return _void_p_to_native(self.type, self._getPlugInArgValue(self))

    def get_default(self):
        if not self.default_set:
            raise OpticksError("Default value is not set.")
        return _void_p_to_native(self.type,
                                 self._getPlugInArgDefaultValue(self))

    def set_default(self, value):
        value = _prep_for_set(value, self.type)
        if isinstance(value, DataVariant):
            self._setPlugInArgDefaultValueFromDataVariant(self, value)
        elif isinstance(value, ctypes.c_void_p):
            self._setPlugInArgDefaultValueFromVoid(self, value)
        else:
            raise OpticksError("Unable to store value.")

    # this can be changed to use .setter when we supporting only python >= 2.6
    default = property(get_default, set_default)

    def get_actual(self):
        if not self.actual_set:
            raise OpticksError("Actual value is not set.")
        return _void_p_to_native(self.type, self._getPlugInArgActualValue(self))

    def set_actual(self, value):
        value = _prep_for_set(value, self.type)
        if isinstance(value, DataVariant):
            self._setPlugInArgActualValueFromDataVariant(self, value)
        elif isinstance(value, ctypes.c_void_p):
            self._setPlugInArgActualValueFromVoid(self, value)
        else:
            raise OpticksError("Unable to store value.")

    # this can be changed to use .setter when we supporting only python >= 2.6
    actual = property(get_actual, set_actual)

class WizardNode(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]

    @property
    def name(self):
        return _stringbuffer_wrap(self._getWizardNodeName, self)

    @property
    def type(self):
        return _stringbuffer_wrap(self._getWizardNodeType, self)

    def get_value(self):
        value = _void_p_to_native(self.type, self._getWizardNodeValue(self))
        if isinstance(value, ctypes.c_void_p):
            new_dv = DataVariant(value, self.type)
            if new_dv.valid:
                value = new_dv
        return value

    def set_value(self, value):
        value = _prep_for_set(value, self.type)
        if isinstance(value, DataVariant):
            self._setWizardNodeValue(self, self._getDataVariantValue(value))
        elif isinstance(value, ctypes.c_void_p):
            self._setWizardNodeValue(self, value)
        else:
            raise OpticksError("Unable to store value.")

    value = property(get_value, set_value)

    def __repr__(self):
        return ("<WizardNode object: '%s' of type: '%s'>" %
                (self.name, self.type))

DataVariant._createDataVariantFromString = \
    _genwrap("createDataVariantFromString", DataVariant,
             ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int)
DataVariant._vectorToArray = \
    _genwrap("vectorToArray", ctypes.c_uint32, ctypes.c_void_p,
             ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p))
DataVariant._createDataVariant = \
    _genwrap("createDataVariant", DataVariant, ctypes.c_char_p,
             ctypes.c_void_p)
DataVariant._freeDataVariant = \
    _genwrap("freeDataVariant", None, DataVariant)
DataVariant._isDataVariantValid = \
    _genwrap("isDataVariantValid", ctypes.c_int, DataVariant)
DataVariant._getDataVariantTypeName = \
    _genwrap("getDataVariantTypeName", ctypes.c_uint32, DataVariant,
             ctypes.c_char_p, ctypes.c_uint32)
DataVariant._getDataVariantValue = \
    _genwrap("getDataVariantValue", ctypes.c_void_p, DataVariant)
DataVariant._getDataVariantValueString = \
    _genwrap("getDataVariantValueString", ctypes.c_uint32, DataVariant,
             ctypes.c_int, ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._getPlugInArgName = \
    _genwrap("getPlugInArgName", ctypes.c_uint32, PlugInArg,
             ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._getPlugInArgTypeName = \
    _genwrap("getPlugInArgTypeName", ctypes.c_uint32, PlugInArg,
             ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._getPlugInArgDescription = \
    _genwrap("getPlugInArgDescription", ctypes.c_uint32, PlugInArg,
             ctypes.c_char_p, ctypes.c_uint32)
PlugInArg._isPlugInArgDefaultSet = \
    _genwrap("isPlugInArgDefaultSet", ctypes.c_int, PlugInArg)
PlugInArg._isPlugInArgActualSet = \
    _genwrap("isPlugInArgActualSet", ctypes.c_int, PlugInArg)
PlugInArg._getPlugInArgValue = \
    _genwrap("getPlugInArgValue", ctypes.c_void_p, PlugInArg)
PlugInArg._getPlugInArgDefaultValue = \
    _genwrap("getPlugInArgDefaultValue", ctypes.c_void_p, PlugInArg)
PlugInArg._getPlugInArgActualValue = \
    _genwrap("getPlugInArgActualValue", ctypes.c_void_p, PlugInArg)
PlugInArg._setPlugInArgDefaultValueFromVoid = \
    _genwrap("setPlugInArgDefaultValueFromVoid", None, PlugInArg,
             ctypes.c_void_p)
PlugInArg._setPlugInArgDefaultValueFromDataVariant = \
    _genwrap("setPlugInArgDefaultValueFromDataVariant", None, PlugInArg,
             DataVariant)
PlugInArg._setPlugInArgActualValueFromVoid = \
    _genwrap("setPlugInArgActualValueFromVoid", None, PlugInArg,
             ctypes.c_void_p)
PlugInArg._setPlugInArgActualValueFromDataVariant = \
    _genwrap("setPlugInArgActualValueFromDataVariant", None, PlugInArg,
             DataVariant)
PlugInArgList._freePlugInArgList = \
    _genwrap("freePlugInArgList", None, PlugInArgList)
PlugInArgList._getPlugInArgCount = \
    _genwrap("getPlugInArgCount", ctypes.c_uint32, PlugInArgList)
PlugInArgList._getPlugInArgByName = \
    _genwrap("getPlugInArgByName", PlugInArg, PlugInArgList, ctypes.c_char_p)
PlugInArgList._getPlugInArgByIndex = \
    _genwrap("getPlugInArgByIndex", PlugInArg, PlugInArgList, ctypes.c_uint32)
WizardNode._getWizardNodeName = \
    _genwrap("getWizardNodeName", ctypes.c_uint32, WizardNode,
             ctypes.c_char_p, ctypes.c_uint32)
WizardNode._getWizardNodeType = \
    _genwrap("getWizardNodeType", ctypes.c_uint32, WizardNode,
             ctypes.c_char_p, ctypes.c_uint32)
WizardNode._getWizardNodeValue = \
    _genwrap("getWizardNodeValue", ctypes.c_void_p, WizardNode)
WizardNode._setWizardNodeValue = \
    _genwrap("setWizardNodeValue", ctypes.c_int, WizardNode, ctypes.c_void_p)

class PlugIn(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, name, batch=True):
        ctypes.Structure.__init__(self)
        self.handle, self.__owns = self._createPlugIn(name, batch).handle, True

    def __del__(self):
        if self.__owns:
            self._freePlugIn(self)

    @property
    def inputs(self):
        return self._getPlugInInputArgList(self)

    @property
    def outputs(self):
        return self._getPlugInOutputArgList(self)

    def __call__(self):
        return bool(self._executePlugIn(self))

class Wizard(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]

    class WizardNodeList(object):
        def __init__(self, wizard, input_list):
            assert(wizard is not None)
            self.__wizard, self.__input_list = wizard, input_list

        def __len__(self):
            if self.__input_list:
                return self._getWizardInputNodeCount(self.__wizard)
            return self._getWizardOutputNodeCount(self.__wizard)

        def __getitem__(self, key):
            from types import IntType
            if type(key) == IntType:
                if self.__input_list:
                    return self._getWizardInputNodeByIndex(self.__wizard, key)
                return self._getWizardOutputNodeByIndex(self.__wizard, key)
            if self.__input_list:
                return self._getWizardInputNodeByName(self.__wizard, str(key))
            return self._getWizardOutputNodeByName(self.__wizard, str(key))

        def iter(self):
            return self.iter_keys()

        def iter_values(self):
            def do_iter(wizard, cnt, input_list):
                for idx in xrange(cnt):
                    if input_list:
                        yield self._getWizardInputNodeByIndex(wizard, idx)
                    else:
                        yield self._getWizardInputNodeByIndex(wizard, idx)
            return do_iter(self.__wizard, len(self), self.__input_list)

        def iter_keys(self):
            def do_iter(wizard, cnt, input_list):
                for idx in xrange(cnt):
                    node = None
                    if input_list:
                        node = self._getWizardInputNodeByIndex(wizard, idx)
                    else:
                        node = self._getWizardInputNodeByIndex(wizard, idx)
                    yield node.name
            return do_iter(self.__wizard, len(self), self.__input_list)

    def __init__(self, filename):
        ctypes.Structure.__init__(self)
        self.handle, self.__owns = self._loadWizard(filename).handle, True

    def __del__(self):
        if self.__owns:
            self._freeWizard(self)

    @property
    def inputs(self):
        return Wizard.WizardNodeList(self, True)

    @property
    def outputs(self):
        return Wizard.WizardNodeList(self, False)

    def __call__(self):
        return bool(self._executeWizard(self))

    @property
    def name(self):
        return _stringbuffer_wrap(self._getWizardName, self)

PlugIn._createPlugIn = \
    _genwrap("createPlugIn", PlugIn, ctypes.c_char_p, ctypes.c_int)
PlugIn._freePlugIn = _genwrap("freePlugIn", None, PlugIn, errorCheck=False)
PlugIn._getPlugInInputArgList = \
    _genwrap("getPlugInInputArgList", PlugInArgList, PlugIn)
PlugIn._getPlugInOutputArgList = \
    _genwrap("getPlugInOutputArgList", PlugInArgList, PlugIn)
PlugIn._executePlugIn = _genwrap("executePlugIn", ctypes.c_int, PlugIn)
Wizard._loadWizard = _genwrap("loadWizard", Wizard, ctypes.c_char_p)
Wizard._freeWizard = _genwrap("freeWizard", None, Wizard, errorCheck=False)
Wizard._getWizardName = \
    _genwrap("getWizardName", ctypes.c_uint32, Wizard, ctypes.c_char_p,
             ctypes.c_uint32)
Wizard.WizardNodeList._getWizardInputNodeCount = \
    _genwrap("getWizardInputNodeCount", ctypes.c_uint32, Wizard)
Wizard.WizardNodeList._getWizardOutputNodeCount = \
    _genwrap("getWizardOutputNodeCount", ctypes.c_uint32, Wizard)
Wizard.WizardNodeList._getWizardInputNodeByIndex = \
    _genwrap("getWizardInputNodeByIndex", WizardNode, Wizard, ctypes.c_uint32)
Wizard.WizardNodeList._getWizardOutputNodeByIndex = \
    _genwrap("getWizardOutputNodeByIndex", WizardNode, Wizard, ctypes.c_uint32)
Wizard.WizardNodeList._getWizardInputNodeByName = \
    _genwrap("getWizardInputNodeByName", WizardNode, Wizard, ctypes.c_char_p)
Wizard.WizardNodeList._getWizardOutputNodeByName = \
    _genwrap("getWizardOutputNodeByName", WizardNode, Wizard,
             ctypes.c_char_p)
Wizard._executeWizard = _genwrap("executeWizard", ctypes.c_int, Wizard)

class DynamicObject(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, element=None, wrapper=None):
        ctypes.Structure.__init__(self)
        if element is None and wrapper is None:
            self.handle = self._createDynamicObject().handle
            self.__owns = True
        elif wrapper is None:
            self.handle = self._getDataElementMetadata(element).handle
            self.__owns = False
        else:
            self.handle, self.__owns = wrapper, False

    def __del__(self):
        if self.__owns:
            self._freeDynamicObject(self)

    def clear(self):
        self._clearMetadata(self)

    def __len__(self):
        return self._getMetadataAttributeCount(self)

    def __getitem__(self, key):
        val = DataVariant(self._getMetadataAttributeByPath(self, key))
        if not val.valid:
            raise KeyError("'DynamicObject' has no attribute '%s'" % key)
        elif val.dv_type == 'DynamicObject':
            val = DynamicObject(wrapper=ctypes.cast(val.value, ctypes.c_void_p))
        return val

    def __setitem__(self, key, value):
        if isinstance(value, DynamicObject):
            value = DataVariant(ctypes.cast(self.handle, ctypes.c_void_p),
                                "DynamicObject")
        elif not isinstance(value, DataVariant):
            value = DataVariant(value)
        if not value.valid:
            raise ValueError("Invalid 'DataVariant' value.")
        self._setMetadataAttributeByPath(self, key, value)

    def __delitem__(self, key):
        try:
            self._removeMetadataAttributeByPath(self, key)
        except SimpleApiError:
            raise KeyError("'DynamicObject' has no attribute '%s'" % key)


    def __getattr__(self, name):
        if name == '__members__':
            rval = []
            for idx in range(len(self)):
                rval.append(_stringbuffer_wrap(self._getMetadataAttributeName,
                                               self, idx))
            return rval
        val = DataVariant(self._getMetadataAttribute(self, name))
        if not val.valid:
            raise AttributeError("'DynamicObject' has no attribute '%s'" % name)
        elif val.dv_type == 'DynamicObject':
            val = DynamicObject(wrapper=ctypes.cast(val.value, ctypes.c_void_p))
        return val

    def __setattr__(self, name, value):
        if name.startswith('_') or name == "handle":
            return object.__setattr__(self, name, value)
        return self.__setitem__(name, value)

    def __delattr__(self, name):
        try:
            self._removeMetadataAttribute(self, name)
        except SimpleApiError:
            raise KeyError("'DynamicObject' has no attribute '%s'" % name)

    def __iter__(self):
        return self.iter_keys()

    def iter_keys(self):
        def do_iter(meta, cnt):
            for idx in xrange(cnt):
                yield _stringbuffer_wrap(self._getMetadataAttributeName,
                                         meta, idx)
        return do_iter(self, len(self))

    def __reversed__(self):
        def do_iter(meta, cnt):
            for idx in xrange(cnt-1, -1, -1):
                yield _stringbuffer_wrap(self._getMetadataAttributeName,
                                         meta, idx)
        return do_iter(self, len(self))

    def __str__(self):
        return "<DynamicObject with %i attribute(s)>" % len(self)

    def __repr__(self):
        return ("DynamicObject(wrapper=DynamicObject(%i))" %
                ctypes.addressof(self))

class ConfigurationSettings(object):
    def __init__(self):
        self.__defaults = None

    def __getitem__(self, key):
        tempf = _genwrap("getConfigurationSetting", DataVariant,
                         ctypes.c_char_p)
        return tempf(key)

    def __setitem__(self, key, value):
        if not isinstance(value, DataVariant):
            value = DataVariant(value)
        tempf = _genwrap("setConfigurationSetting", ctypes.c_int,
                         ctypes.c_char_p, DataVariant)
        tempf(key, value)

    def add_to_defaults(self, key):
        """Add the specified configuration setting to the defaults
        list which is maintained as a member object until
        serialized or cleared.

        """
        if self.__defaults is None:
            self.__defaults = DynamicObject()
        tempf = _genwrap("copyConfigurationSetting", ctypes.c_int,
                         ctypes.c_char_p, DynamicObject)
        tempf(key, self.__defaults)

    def serialize_defaults(self, filename):
        if self.__defaults is None:
            raise ValueError("No configuration settings in defaults.")
        tempf = _genwrap("serializeConfigurationSettingDefaults",
                         ctypes.c_int, ctypes.c_char_p, DynamicObject)
        tempf(filename, self.__defaults)
        self.clear_defaults()

    def clear_defaults(self):
        self.__defaults = None

DynamicObject._createDynamicObject = \
    _genwrap("createDynamicObject", DynamicObject)
DynamicObject._freeDynamicObject = \
    _genwrap("freeDynamicObject", None, DynamicObject, errorCheck=False)
DynamicObject._getDataElementMetadata = \
    _genwrap("getDataElementMetadata", DynamicObject, DataElement)
DynamicObject._getMetadataAttributeCount = \
    _genwrap("getMetadataAttributeCount", ctypes.c_uint32, DynamicObject)
DynamicObject._getMetadataAttributeName = \
    _genwrap("getMetadataAttributeName", ctypes.c_uint32,
             DynamicObject, ctypes.c_uint32, ctypes.c_char_p, ctypes.c_uint32)
DynamicObject._getMetadataAttribute = \
    _genwrap("getMetadataAttribute", DataVariant, DynamicObject,
             ctypes.c_char_p)
DynamicObject._getMetadataAttributeByPath = \
    _genwrap("getMetadataAttributeByPath", DataVariant, DynamicObject,
             ctypes.c_char_p)
DynamicObject._setMetadataAttribute = \
    _genwrap("setMetadataAttribute", None, DynamicObject,
             ctypes.c_char_p, DataVariant)
DynamicObject._setMetadataAttributeByPath = \
    _genwrap("setMetadataAttributeByPath", None, DynamicObject,
             ctypes.c_char_p, DataVariant)
DynamicObject._removeMetadataAttribute = \
    _genwrap("removeMetadataAttribute", None, DynamicObject, ctypes.c_char_p)
DynamicObject._removeMetadataAttributeByPath = \
    _genwrap("removeMetadataAttributeByPath", None, DynamicObject,
             ctypes.c_char_p)
DynamicObject._clearMetadata  = _genwrap("clearMetadata", None, DynamicObject)

class IntComplex32(ctypes.Structure):
    "Integer complex with 16-bit real and 16-bit imaginary elements."
    _fields_ = [("real", ctypes.c_int16), ("imag", ctypes.c_int16)]

class FloatComplex64(ctypes.Structure):
    "Floating point complex with 32-bit real and 32-bit imaginary elements."
    _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]

class Encoding(ctypes.c_uint32):
    "Opticks data encoding type."
    INT1SBYTE = 0
    INT1UBYTE = 1
    INT2SBYTES = 2
    INT2UBYTES = 3
    INT4SCOMPLEX = 4
    INT4SBYTES = 5
    INT4UBYTES = 6
    FLT4BYTES = 7
    FLT8COMPLEX = 8
    FLT8BYTES = 9

    def __repr__(self):
        if self.value == self.INT1SBYTE:
            strname = "INT1SBYTE"
        elif self.value == self.INT1UBYTE:
            strname = "INT1UBYTE"
        elif self.value == self.INT2SBYTES:
            strname = "INT2SBYTES"
        elif self.value == self.INT2UBYTES:
            strname = "INT2UBYTES"
        elif self.value == self.INT4SBYTES:
            strname = "INT4SBYTES"
        elif self.value == self.INT4UBYTES:
            strname = "INT4UBYTES"
        elif self.value == self.INT4SCOMPLEX:
            strname = "INT4SCOMPLEX"
        elif self.value == self.FLT4BYTES:
            strname = "FLT4BYTES"
        elif self.value == self.FLT8BYTES:
            strname = "FLT8BYTES"
        elif self.value == self.FLT8COMPLEX:
            strname = "FLT8COMPLEX"
        else:
            strname = "Unknown"
        return "<Encoding: %s>" % strname

    def to_ctype(self):
        "Return an appropriate ctypes data type for this encoding type."
        retval = None
        if self.value == self.INT1SBYTE:
            retval = ctypes.POINTER(ctypes.c_int8)
        elif self.value == self.INT1UBYTE:
            retval = ctypes.POINTER(ctypes.c_uint8)
        elif self.value == self.INT2SBYTES:
            retval = ctypes.POINTER(ctypes.c_int16)
        elif self.value == self.INT2UBYTES:
            retval = ctypes.POINTER(ctypes.c_uint16)
        elif self.value == self.INT4SBYTES:
            retval = ctypes.POINTER(ctypes.c_int32)
        elif self.value == self.INT4UBYTES:
            retval = ctypes.POINTER(ctypes.c_uint32)
        elif self.value == self.INT4SCOMPLEX:
            retval = ctypes.POINTER(IntComplex32)
        elif self.value == self.FLT4BYTES:
            retval = ctypes.POINTER(ctypes.c_float)
        elif self.value == self.FLT8BYTES:
            retval = ctypes.POINTER(ctypes.c_double)
        elif self.value == self.FLT8COMPLEX:
            retval = ctypes.POINTER(FloatComplex64)
        else:
            retval = ctypes.c_void_p
        return retval

    def to_numpy_type(self):
        "Return an appropriate numpy dtype for this encoding type."
        retval = None
        if self.value == self.INT1SBYTE:
            retval = "int8"
        elif self.value == self.INT1UBYTE:
            retval = "uint8"
        elif self.value == self.INT2SBYTES:
            retval = "int16"
        elif self.value == self.INT2UBYTES:
            retval = "uint16"
        elif self.value == self.INT4SBYTES:
            retval = "int32"
        elif self.value == self.INT4UBYTES:
            retval = "uint32"
        elif self.value == self.INT4SCOMPLEX:
            retval = "i2i2"
        elif self.value == self.FLT4BYTES:
            retval = "float32"
        elif self.value == self.FLT8BYTES:
            retval = "float64"
        elif self.value == self.FLT8COMPLEX:
            retval = "complex64"
        else:
            retval = "void"
        return retval

    def from_numpy_type(self, typestr):
        "Return an appropriate numpy dtype for this encoding type."
        retval = None
        if typestr == "int8":
            retval = self.INT1SBYTE
        elif typestr == "uint8":
            retval = self.INT1UBYTE
        elif typestr == "int16":
            retval = self.INT2SBYTES
        elif typestr == "uint16":
            retval = self.INT2UBYTES
        elif typestr == "int32":
            retval = self.INT4SBYTES
        elif typestr == "uint32":
            retval = self.INT4UBYTES
        elif typestr == "float32":
            retval = self.FLT4BYTES
        elif typestr == "float64":
            retval = self.FLT8BYTES
        elif typestr == "complex64":
            retval = self.FLT8COMPLEX
        else:
            raise TypeError("'%s' can't be represented in Opticks." % typestr)
        return retval

class Interleave(ctypes.c_uint32):
    "Opticks data interleave format."
    BSQ = 0
    BIP = 1
    BIL = 2

    def __repr__(self):
        if self.value == self.BSQ:
            return "<Interleave: BSQ>"
        elif self.value == self.BIP:
            return "<Interleave: BIP>"
        elif self.value == self.BIL:
            return "<Interleave: BIL>"
        return "<Interleave: Unknown"

class ProcessingLocationPreference(ctypes.c_uint32):
    "Processing location hint for creation of raster elements."
    PREFER_RAM = 0
    RAM = 1
    ONDISK = 2

    def __repr__(self):
        if self.value == self.ONDISK:
            return "<ProcessingLocationPreference: on-disk only>"
        elif self.value == self.RAM:
            return "<ProcessingLocationPreference: in memory only>"
        elif self.value == self.PREFER_RAM:
            return "<ProcessingLocationPreference: prefer in memory>"
        return "<Interleave: Unknown"

class DataInfo(ctypes.Structure):
    "Information about a raster element."
    _fields_ = [("rows", ctypes.c_uint32),
                ("columns", ctypes.c_uint32),
                ("bands", ctypes.c_uint32),
                ("interleave", Interleave),
                ("encoding", Encoding),
                ("encoding_size", ctypes.c_uint32),
                ("num_bad_values", ctypes.c_uint32),
                ("p_bad_values", ctypes.POINTER(ctypes.c_int32))]

    def __init__(self, *args):
        #pylint: disable=W0231
        pass # don't call the base class __init__

    def __new__(cls, data_element=None):
        create_data_info = _genwrap("createDataInfo",
                                    ctypes.POINTER(DataInfo), DataElement)
        rval = create_data_info(data_element).contents
        if rval:
            rval.__coreOwns = True
        return rval

    def __del__(self):
        if self.__coreOwns:
            tempf = _genwrap("destroyDataInfo", None,
                             ctypes.POINTER(DataInfo), errorCheck=False)
            tempf(self)

    def __repr__(self):
        return ("<DataInfo: %i,%i,%i %s %s>" %
                (self.rows, self.columns, self.bands,
                self.interleave, self.encoding))

    def get_bad_values(self):
        rval = []
        for idx in range(self.num_bad_values):
            rval.append(self.p_bad_values[idx])
        return rval

    def set_bad_values(self, val):
        #pylint: disable=W0201
        assert(isinstance(val, list))
        self.num_bad_values = len(val)
        tempv = (ctypes.c_int32 * self.num_bad_values)
        self.p_bad_values = ctypes.cast(ctypes.POINTER(ctypes.c_int32),
                                        tempv)
        for idx in range(self.num_bad_values):
            self.p_bad_values[idx] = ctypes.c_int32(val[idx])

    bad_values = property(get_bad_values, set_bad_values)

class RasterElementArgs(ctypes.Structure):
    "Argument structure for creation of a new raster element."
    _fields_ = [("rows", ctypes.c_uint32),
                ("columns", ctypes.c_uint32),
                ("bands", ctypes.c_uint32),
                ("interleave", Interleave),
                ("encoding", Encoding),
                ("location", ProcessingLocationPreference),
                ("parent", DataElement),
                ("num_bad_values", ctypes.c_uint32),
                ("p_bad_values", ctypes.POINTER(ctypes.c_int32))]

    def __repr__(self):
        return ("<RasterElementArgs: %i,%i,%i %s %s %s>" %
                (self.rows, self.columns, self.bands, self.interleave,
                self.encoding, self.location))

    def from_numpy_array(self, array):
        """This will fill in details from a numpy array. Before
        calling this function you must set
        'interleave' appropriately.

        """
        #pylint: disable=W0201
        try:
            #pylint: disable=W0612
            import numpy
        except ImportError:
            # numpy not available
            raise NotImplementedError("numpy is not available")
        if len(array.shape) == 3:
            if self.interleave.value == Interleave.BSQ:
                self.bands, self.rows, self.columns = array.shape
            elif self.interleave.value == Interleave.BIL:
                self.rows, self.bands, self.columns = array.shape
            elif self.interleave.value == Interleave.BIP:
                self.rows, self.columns, self.bands = array.shape
        elif len(array.shape) == 2:
            self.bands = 1
            self.rows, self.columns = array.shape
        else:
            raise ValueError("Array must be 2-d or 3-d")
        self.encoding = self.encoding.from_numpy_type(array.dtype.name)

    def get_bad_values(self):
        rval = []
        for idx in range(self.num_bad_values):
            rval.append(self.p_bad_values[idx])
        return rval

    def set_bad_values(self, val):
        #pylint: disable=W0201
        assert(isinstance(val, list))
        self.num_bad_values = len(val)
        tempv = (ctypes.c_int32 * self.num_bad_values)()
        self.p_bad_values = ctypes.cast(tempv,
                                        ctypes.POINTER(ctypes.c_int32))
        for idx in range(self.num_bad_values):
            self.p_bad_values[idx] = ctypes.c_int32(val[idx])

    bad_values = property(get_bad_values, set_bad_values)

class DataPointerArgs(ctypes.Structure):
    "Argument structure for creation of a new data pointer."
    _fields_ = [("row_start", ctypes.c_uint32),
                ("row_end", ctypes.c_uint32),
                ("column_start", ctypes.c_uint32),
                ("column_end", ctypes.c_uint32),
                ("band_start", ctypes.c_uint32),
                ("band_end", ctypes.c_uint32),
                ("interleave", Interleave)]

    def __repr__(self):
        return ("<DataPointerArgs: %i-%i, %i-%i, %i-%i, %s>" %
                (self.row_start, self.row_end, self.column_start,
                self.column_end, self.band_start, self.band_end,
                self.interleave))

class DataAccessorArgs(ctypes.Structure):
    "Argument structure for creation of a new data accessor."
    _fields_ = [("row_start", ctypes.c_uint32),
                ("row_end", ctypes.c_uint32),
                ("concurrent_rows", ctypes.c_uint32),
                ("column_start", ctypes.c_uint32),
                ("column_end", ctypes.c_uint32),
                ("concurrent_columns", ctypes.c_uint32),
                ("band_start", ctypes.c_uint32),
                ("band_end", ctypes.c_uint32),
                ("concurrent_bands", ctypes.c_uint32),
                ("interleave", Interleave),
                ("writable", ctypes.c_uint32)]

    def __repr__(self):
        return ("<DataAccessorArgs: %i-%i, %i-%i, %i-%i, %s>" %
                (self.row_start, self.row_end, self.column_start,
                self.column_end, self.band_start, self.band_end,
                self.interleave))

class AoiIterator(ctypes.Structure):
    "An iterator over an AOI."
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, element = None, raster = None, bounding_box = None):
        """Create a new AOI iteraor over a specified raster
        element or bounding box. Pass in either a raster element
        or a 4-tuple (x1, y1, x2, y2) bounding box. If element is None,
        iterate over the entire raster or bounding_box.

        """
        ctypes.Structure.__init__(self)
        assert(raster is not None or bounding_box is not None)
        assert(not (raster is not None and bounding_box is not None))

        try:
            if raster is not None:
                if element is None:
                    tempf = _genwrap("createAoiIteratorOverRaster",
                                     AoiIterator, ctypes.c_void_p, DataElement)
                    self.handle = tempf(element, raster).handle
                else:
                    tempf = _genwrap("createAoiIteratorOverRaster",
                                     AoiIterator, DataElement, DataElement)
                    self.handle = tempf(element, raster).handle
            else:
                if element is None:
                    tempf = _genwrap("createAoiIteratorOverBoundingBox",
                                     AoiIterator, ctypes.c_void_p,
                                     ctypes.c_int32, ctypes.c_int32,
                                     ctypes.c_int32, ctypes.c_int32)
                    self.handle = tempf(element, bounding_box[0],
                                        bounding_box[1], bounding_box[2],
                                        bounding_box[3]).handle
                else:
                    tempf = _genwrap("createAoiIteratorOverBoundingBox",
                                     AoiIterator, DataElement,
                                     ctypes.c_int32, ctypes.c_int32,
                                     ctypes.c_int32, ctypes.c_int32)
                    self.handle = tempf(element, bounding_box[0],
                                        bounding_box[1], bounding_box[2],
                                        bounding_box[3]).handle
            self.__last = False
        except SimpleApiError, err:
            if err.code == SimpleApiError.SIMPLE_NOT_FOUND:
                self.__last = False
        self.__first, self.__owns = True, True

    def __del__(self):
        if self.__owns:
            _genwrap("freeAoiIterator", None, AoiIterator)(self)

    def __iter__(self):
        return self

    def next(self):
        if not self.__first and not self.__last:
            if self._nextAoiIterator(self) == 0:
                self.__last = True
        if self.__last:
            raise StopIteration()
        self.__first = False
        column, row = ctypes.c_int32(-1), ctypes.c_int32(-1)
        self._getAoiIteratorLocation(self,
                                     ctypes.byref(column),
                                     ctypes.byref(row))
        return column.value, row.value
AoiIterator._nextAoiIterator = \
    _genwrap("nextAoiIterator", ctypes.c_int, AoiIterator)
AoiIterator._getAoiIteratorLocation = \
    _genwrap("getAoiIteratorLocation", ctypes.c_int, AoiIterator,
             ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32))

class Aoi(DataElement):
    "An AOI with support for iteration and random access."
    _getAoiValue = \
        _genwrap("getAoiValue", ctypes.c_int, DataElement,
                 ctypes.c_int32, ctypes.c_int32)
    _setAoiValue = \
        _genwrap("setAoiValue", ctypes.c_int, DataElement,
                 ctypes.c_uint32, ctypes.c_uint32, ctypes.c_int)
    _getAoiMinimalBoundingBox = \
        _genwrap("getAoiMinimalBoundingBox", ctypes.c_int,
                 DataElement, ctypes.POINTER(ctypes.c_int32),
                 ctypes.POINTER(ctypes.c_int32),
                 ctypes.POINTER(ctypes.c_int32),
                 ctypes.POINTER(ctypes.c_int32))

    def __init__(self, name=None, create=False, element=None):
        """Get an AOI.
        If name is specified, get the named AOI.
        If the named AOI does not exist an attempt
        will be made to create it if create is True.
        If element is specified, use an existing DataElement.

        """
        assert(name is not None or element is not None)
        assert(not (name is not None and element is not None))
        if element is not None:
            self.handle = element.handle
        else:
            DataElement.__init__(self, name, create=create, typ="AoiElement")

    def __getitem__(self, (column, row)):
        return bool(self._getAoiValue(self, column, row))

    def __setitem__(self, (column, row), value):
        self._setAoiValue(self, column, row, int(value))

    @property
    def minimal_bounding_box(self):
        min_column = ctypes.c_int32(0)
        min_row = ctypes.c_int32(0)
        max_column = ctypes.c_int32(0)
        max_row = ctypes.c_int32(0)
        self._getAoiMinimalBoundingBox(self,
                                       ctypes.byref(min_column),
                                       ctypes.byref(min_row),
                                       ctypes.byref(max_column),
                                       ctypes.byref(max_row))
        return min_column.value, min_row.value, max_column.value, max_row.value

    def __iter__(self):
        return apply(self.iter_bounding, self.minimal_bounding_box)

    def iter_raster(self, raster_element):
        """Create an iterator over an AOI bounded by the extents
        of a RasterElement.

        """
        return AoiIterator(self, raster = raster_element)

    def iter_bounding(self, min_column, min_row, max_column, max_row):
        """Create an iterator over an AOI bounded by the
        specified pixel coordinates.

        """
        bbox = (min_column, min_row, max_column, max_row)
        return AoiIterator(self, bounding_box = bbox)

class DataAccessor(ctypes.Structure):
    """Wrapper for an Opticks data accessor. This is the most
    flexible data access method but is also the most complex.

    """
    _fields_ = [("handle", ctypes.c_void_p)]

    def __del__(self):
        if self.__owns:
            tempf = _genwrap("destroyDataAccessor", None, DataAccessor,
                             errorCheck=False)
            tempf(self)

    def initialize(self, *args):
        #pylint: disable=W0201
        "Not user callable...this is used by RasterElement.get_data_accessor"
        # args = owns, encoding, colcount, writable
        self.__owns, self.__encoding, self.__col_count, self.__writable = args

    @property
    def row(self):
        "Get a ctypes pointer to the current row."
        return ctypes.cast(ctypes.c_void_p(self._getDataAccessorRow(self)),
                           self.__encoding)

    def next_row(self, count = 1, reset_column = True):
        """Advance the data accessor count number of rows.
        If reset column is True, the data accessor will point to
        the original start column of the new row.

        """
        self._nextDataAccessorRow(self, count, reset_column)

    @property
    def column(self):
        "Get a ctypes pointer to the current column."
        return ctypes.cast(ctypes.c_void_p(self._getDataAccessorColumn(self)),
                           self.__encoding)

    def next_column(self, count = 1):
        "Advance the data accessor count number of columns."
        self._nextDataAccessorColumn(self, count)

    def __getitem__(self, (row, column)):
        "Access the data point at a specific (row, column)."
        self.to_pixel(row, column)
        if not self.valid:
            raise OpticksError("Location (%i, %i) is invalid." % (row, column))
        return self.column.contents.value

    def __setitem__(self, (row, column), value):
        if not self.__writable:
            raise OpticksError("Accessor is read-only")
        self.to_pixel(row, column)
        if not self.valid:
            raise OpticksError("Location (%i, %i) is invalid." % (row, column))
        self.column[0] = value

    def to_pixel(self, row, column):
        self._to_pixel(self, row, column)

    def iter_rows(self, incr = 1):
        """Create an iterator across rows which accesses
        the entire row each iteration.

        """
        def do_iter(acc, incr):
            while acc.valid:
                yield acc.row
                acc.next_row(incr)
        return do_iter(self, incr)

    def iter_columns(self, incr = 1):
        "Create an iteractor across columns in the current row."
        def do_iter(acc, col_count, incr):
            #pylint: disable=W0612
            for idx in xrange(col_count):
                yield acc.column
                acc.next_column(incr)
        return do_iter(self, self.__col_count, incr)

    @property
    def valid(self):
        return self._valid(self)

    @property
    def row_size(self):
        return self._rowsize(self)

DataAccessor._getDataAccessorRow = \
    _genwrap("getDataAccessorRow", ctypes.c_void_p, DataAccessor)
DataAccessor._getDataAccessorColumn = \
    _genwrap("getDataAccessorColumn", ctypes.c_void_p, DataAccessor)
DataAccessor._nextDataAccessorRow = \
    _genwrap("nextDataAccessorRow", None, DataAccessor, ctypes.c_uint32,
             ctypes.c_int)
DataAccessor._nextDataAccessorColumn = \
    _genwrap("nextDataAccessorColumn", None, DataAccessor, ctypes.c_uint32)
DataAccessor._valid = \
    _genwrap("isDataAccessorValid", ctypes.c_int, DataAccessor)
DataAccessor._rowsize = \
    _genwrap("getDataAccessorRowSize", ctypes.c_uint32, DataAccessor)
DataAccessor._to_pixel = \
    _genwrap("toDataAccessorPixel", None, DataAccessor, ctypes.c_uint32,
             ctypes.c_uint32)

class RasterElement(DataElement):
    "A raster element."
    _createDataPointer = \
        _genwrap("createDataPointer", ctypes.c_void_p, DataElement,
                 ctypes.POINTER(DataPointerArgs),
                 ctypes.POINTER(ctypes.c_int))
    _createDataAccessor = \
        _genwrap("createDataAccessor", DataAccessor, DataElement,
                 ctypes.POINTER(DataAccessorArgs))
    _updateRasterElement = _genwrap("updateRasterElement", None, DataElement)
    _copyDataToRasterElement = \
        _genwrap("copyDataToRasterElement", ctypes.c_int,
                 DataElement, ctypes.POINTER(DataPointerArgs),
                 ctypes.c_void_p)

    def __init__(self, name=None, args=None, raw_data=None, element=None):
        """Get a raster element.
        If name is specified, get the named raster.
        If name and args are specified, create a new raster.
        If element is specified, use an existing DataElement.
        If raw_data is not None, a new RasterElement will be created
        and rawData be copied to the new RasterElement using
        set_data_pointer() or set_data_array(). args must be
        specified with raw_data. Most of the args fields can be derived
        with RasterElementArgs.from_numpy_array().

        """
        assert(name is not None or element is not None)
        assert(not (name is not None and element is not None))
        if element is not None:
            self.handle = element.handle
        elif args is None and raw_data is None:
            super(RasterElement, self).__init__(name)
        else:
            tempf = _genwrap("createRasterElement", DataElement,
                             ctypes.c_char_p, RasterElementArgs)
            self.handle = tempf(name, args).handle
            if raw_data is not None:
                try:
                    import numpy
                    if isinstance(raw_data, numpy.ndarray):
                        self.set_data_array(raw_data)
                        return
                except ImportError:
                    pass
                self.set_data_pointer(raw_data)

    @property
    def info(self):
        return DataInfo(self)

    def get_data_accessor(self, args = None):
        "Create a DataAccessor for this raster element."
        nfo = DataInfo(self)
        col_count = None
        assert(args is None or isinstance(args, DataAccessorArgs))
        if args is None:
            acc = self._createDataAccessor(self, None)
        else:
            acc = self._createDataAccessor(self, ctypes.byref(args))
        acc._DataAccessor__owns = True
        acc._DataAccessor__encoding = nfo.encoding.to_ctype()
        if args is None:
            col_count, writable = nfo.columns, False
        else:
            col_count = args.column_end - args.column_start + 1
            writable = args.writable
        acc.initialize(True, nfo.encoding.to_ctype(), col_count, writable)
        return acc

    def update(self):
        self._updateRasterElement(self)

    def get_data_pointer(self, args=None):
        """Create a data pointer to an element with optional DataPointerArgs.
        Returns the ctypes data pointer and an ownership variable.
        If the second return value is True, the caller must call
        destroyDataPointer() with the first return value. When done
        with the data, the caller must delete the deleter object (with
        del or by removing that last reference) in order to clean up
        allocated memory. If the memory is shared, the second return
        value will be None.

        """
        own, deleter = ctypes.c_int(0), None
        ptr = self._createDataPointer(self, args, ctypes.byref(own))
        if own:
            class DeleterObj(object):
                def __init__(self, ptr):
                    self.__ptr = ptr
                def __del__(self):
                    tempf = _genwrap("destroyDataPointer", None,
                                     ctypes.c_void_p, errorCheck=False)
                    tempf(self.__ptr)
            deleter = DeleterObj(ptr)
        return ptr, deleter

    def get_data_array(self, args=None):
        """Create a data pointer to an element with optional DataPointerArgs.
        Returns a numpy array and a deleter object. When done with
        the data, the caller must delete the deleter object (with
        del or by removing the last reference) in order to clean up
        allocated memory. If the memory is shared, the second return
        value will be None.

        """
        try:
            import numpy
            ptr, deleter = self.get_data_pointer(args)
            nfo = DataInfo(self)
            rows, cols, bands = nfo.rows, nfo.columns, nfo.bands
            if args is not None:
                rows = args.row_end - args.row_start + 1
                cols = args.column_end - args.column_start + 1
                bands = args.band_end - args.band_start + 1
            func = ctypes.pythonapi.PyBuffer_FromMemory
            func.restype = ctypes.py_object
            datalen = rows * cols * bands * nfo.encoding
            dbuffer = func(ptr, datalen)
            array = numpy.frombuffer(dbuffer,
                                     dtype=nfo.encoding.to_numpy_type())
            if nfo.interleave.value == Interleave.BIP:
                array.shape = (rows, cols, bands)
            elif nfo.interleave.value == Interleave.BSQ:
                array.shape = (bands, rows, cols)
            elif nfo.interleave.value == Interleave.BIL:
                array.shape = (rows, bands, cols)
            return array, deleter
        except ImportError:
            # numpy wrapper will not be available
            raise NotImplementedError("numpy is not available")

    def set_data_pointer(self, data, args=None):
        """Copy data to a RasterElement with optional DataPointerArgs.
        Data must be a ctypes.c_void_p. The caller should call
        update() when this is complete to redisplay the data.

        """
        self._copyDataToRasterElement(self, args, data)

    def set_data_array(self, data, args=None):
        """Copy data to a RasterElement with optional DataPointerArgs.
        Data must be a numpy.ndarray. The caller should call update()
        when this is complete to redisplay the data.
        The array info will be checked against args or if args
        is None, it will be populated with appropriate info.

        """
        #pylint: disable=W0201
        try:
            import numpy
            if not isinstance(data, numpy.ndarray):
                raise TypeError("Invalid data type, must be "\
                                "numpy.ndarray or ctypes.c_void_p")
            nfo = DataInfo(self)
            if args is None:
                args = DataPointerArgs()
                args.interleave = nfo.interleaveFormat
                if len(data.shape) == 2:
                    args.row_end, args.column_end = \
                        map(lambda x: x - 1, data.shape)
                    args.band_end = 0
                elif len(data.shape) == 3:
                    if args.interleave.value == Interleave.BSQ:
                        args.band_end, args.row_end, args.column_end = \
                            map(lambda x: x - 1, data.shape)
                    elif args.interleave.value == Interleave.BIL:
                        args.row_end, args.band_end, args.column_end = \
                            map(lambda x: x - 1, data.shape)
                    elif args.interleave.value == Interleave.BIP:
                        args.row_end, args.column_end, args.band_end = \
                            map(lambda x: x - 1, data.shape)
                else:
                    raise ValueError("Data must be 2 or 3 dimensional.")
            if args.row_end - args.row_start + 1 > nfo.rows:
                raise ValueError("Array has too many rows.")
            elif args.column_end - args.column_start + 1 > nfo.columns:
                raise ValueError("Array has too many columns.")
            elif args.band_end - args.band_start + 1 > nfo.bands:
                raise ValueError("Array has too many bands.")
            if nfo.encoding.to_numpy_type() != str(data.dtype):
                raise ValueError("Array has wrong dtype.")

            if ((args.row_end - args.row_start + 1) == nfo.rows and
                (args.column_end - args.column_start + 1) == nfo.columns and
                (args.band_end - args.band_start + 1) == nfo.bands):
                args = None
            rawdata = data.ctypes.data_as(ctypes.c_void_p)
            self.set_data_pointer(rawdata, args)
        except ImportError:
            # numpy wrapper will not be available
            raise NotImplementedError("numpy is not available")

class Signature(DataElement):
    "A signature data type."
    #pylint: disable=R0921
    _getSignatureDataSetCount = \
        _genwrap("getSignatureDataSetCount", ctypes.c_uint32, DataElement)
    _getSignatureDataSetName = \
        _genwrap("getSignatureDataSetName", ctypes.c_uint32,
                 DataElement, ctypes.c_uint32, ctypes.c_char_p,
                 ctypes.c_uint32)
    _getSignatureDataSet = \
        _genwrap("getSignatureDataSet", DataVariant, DataElement,
                 ctypes.c_char_p)
    _setSignatureDataSet = \
        _genwrap("setSignatureDataSet", ctypes.c_int, DataElement,
                 ctypes.c_char_p, DataVariant)

    def __init__(self, name=None, create=False, element=None):
        """Get a signature.
        If name is specified, get the named signature.
        If the signature does not exist and create is True,
        attempt to create the signature.
        If element is specified, use an existing DataElement.

        """
        assert(name is not None or element is not None)
        assert(not (name is not None and element is not None))
        if element is not None:
            self.handle = element.handle
        else:
            DataElement.__init__(self, name, create=create, typ="Signature")

    def keys(self):
        k = []
        for idx in range(self._getSignatureDataSetCount(self)):
            k.append(_stringbuffer_wrap(self._getSignatureDataSetName,
                                        self, idx))
        return k

    def __getitem__(self, key):
        return self._getSignatureDataSet(self, key)

    def __setitem__(self, key, value):
        if not isinstance(value, DataVariant):
            value = DataVariant(value)
        self._setSignatureDataSet(self, key, value)

    def __delitem__(self, key):
        raise NotImplementedError()

class SignatureSet(DataElement):
    "A signature set data type."
    _getSignatureSetCount = \
        _genwrap("getSignatureSetCount", ctypes.c_uint32, DataElement)
    _getSignatureSetSignature = \
        _genwrap("getSignatureSetSignature", DataElement,
                 DataElement, ctypes.c_uint32)

    def __init__(self, name=None, create=False, element=None):
        """Get a signature set.
        If name is specified, get the named signature set.
        If the signature set does not exist and create is True,
        attempt to create the signature set.
        If element is specified, use an existing DataElement.

        """
        assert(name is not None or element is not None)
        assert(not (name is not None and element is not None))
        if element is not None:
            self.handle = element.handle
        else:
            DataElement.__init__(self, name, create=create, typ="SignatureSet")

    def __len__(self):
        return int(self._getSignatureSetCount(self))

    def __getitem__(self, index):
        if index >= len(self):
            raise IndexError()
        return Signature(element=self._getSignatureSetSignature(self, index))

# important IEEE-754 contant
NAN = 1e30000/1e30000 # overflow to cause Inf then divide to cause NaN

class Layer(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, name=None, typ=None, other=None):
        """Get a Layer by name.
        The name may be a session ID or a layer specification.
        See the Simple API module in the main developer documentation
        for more information on layer specifications. In summary, a
        layer specification is two parts, both optional:
        viewName|layerName where the default view is the active
        view and the default layer depends on a number of factors and
        is detailed in the main developer documentation.
        If typ is None, access any layer type. Otherwise, access only
        layers of the type specified.
        If other is specified the internal handle for that Layer
        will be copied to the new Layer. This is generally an
        internal usage.

        """
        ctypes.Structure.__init__(self)
        if other is not None:
            assert(name is None and typ is None and isinstance(other, Layer))
            self.handle = other.handle
        else:
            tempf = _genwrap("getLayer", Layer, ctypes.c_char_p,
                             ctypes.c_char_p)
            self.handle = tempf(name, typ).handle
        self.__owns = False

    def __del__(self):
        if self.__owns:
            _genwrap("destroyLayer", None, Layer, errorCheck=False)(self)

    def destroy(self, val=True):
        """Mark this layer for destruction. When the layer object
        is garbage collected it will be removed from the view
        and destroyed. If val is False, destruction
        will be cancelled.

        """
        self.__owns = val

    @property
    def name(self):
        return _stringbuffer_wrap(self._getLayerName, self)

    @property
    def type(self):
        return _stringbuffer_wrap(self._getLayerType, self)

    @property
    def element(self):
        return self._getLayerElement(self)

    @property
    def view(self):
        return self._getLayerView(self)

    def get_scale(self):
        x_scale, y_scale = ctypes.c_double(0.0), ctypes.c_double(0.0)
        self._getLayerScaleOffset(self, ctypes.byref(x_scale),
                                  ctypes.byref(y_scale), None, None)
        return x_scale.value, y_scale.value
    def set_scale(self, (x_scale, y_scale)):
        self._setLayerScaleOffset(self, x_scale, y_scale, NAN, NAN)
    scale = property(get_scale, set_scale, doc="The Layer scale factor.")

    def get_offset(self):
        x_offset, y_offset = ctypes.c_double(0.0), ctypes.c_double(0.0)
        self._getLayerScaleOffset(self, None, None,
                                  ctypes.byref(x_offset),
                                  ctypes.byref(y_offset))
        return x_offset.value, y_offset.value
    def set_offset(self, (x_offset, y_offset)):
        self._setLayerScaleOffset(self, NAN, NAN, x_offset, y_offset)
    offset = property(get_offset, set_offset, doc="The Layer offset in pixels.")

    def get_display_index(self):
        return self._getLayerDisplayIndex(self)
    def set_display_index(self, index):
        self._setLayerDisplayIndex(self, index)
    display_index = property(get_display_index,
                             set_display_index,
                             doc="Indicates the ordering in the layer stack.")

    def get_displayed(self):
        return bool(self._isLayerDisplayed(self))
    def set_displayed(self, value):
        if value:
            self._setLayerDisplayed(self, 1)
        else:
            self._setLayerDisplayed(self, 0)
    displayed = property(get_displayed, set_displayed)

    def derive(self, name=None, typ=None):
        """Derive a new layer or copy an existing layer.
        If typ is None, a copy of the layer will be created.
        name is the new layer's name. If name is None,
        the new layer will have the same name as the original layer.
        Returns a new Layer.

        """
        if typ is None:
            typ = self.type
        return Layer(other=self._deriveLayer(self, name, typ))

    def convert(self, typ):
        "Convert to a new layer type."
        self.handle = self._convertLayer(self, typ).handle

    @property
    def active(self):
        return self._isLayerActive(self)

    def activate(self):
        self._activateLayer(self)

class View(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, name=None, typ=None, element=None, create=False):
        """Get a View by name.
        The name may be a session ID or a view name.
        If typ is None, access any view type. Otherwise,
        access only views of the type specified.

        If create is True, create a new View of typ with name.
        If the new view requires a DataElement (currently
        SpatialDataView) then element should contain the DataElement.
        If create is True and the View exists, an exception
        will be raised. If create is True and element is not None,
        typ is assumed to be SpatialDataView.

        """
        ctypes.Structure.__init__(self)
        if create:
            if typ is None and element is not None:
                typ = "Spatial Data View"
            tempf = _genwrap("createView", View, ctypes.c_char_p,
                             ctypes.c_char_p, DataElement)
            self.handle = tempf(name, typ, element).handle
        else:
            tempf = _genwrap("getView", View, ctypes.c_char_p, ctypes.c_char_p)
            self.handle = tempf(name, typ).handle
        self.__owns = False

    def __del__(self):
        if self.__owns:
            _genwrap("destroyView", None, View, errorCheck=False)(self)

    def destroy(self, val=True):
        """Mark this view for destruction. When the view object
        is garbage collected it will be destroyed. If val is False,
        destruction will be cancelled.

        """
        self.__owns = val

    def get_name(self):
        return _stringbuffer_wrap(self._getViewName, self)
    def set_name(self, name):
        self._setViewName(self, name)
    name = property(get_name, set_name)

    @property
    def type(self):
        return _stringbuffer_wrap(self._getViewType, self)

    @property
    def primary_element(self):
        return RasterElement(element=self._getViewPrimaryRasterElement(self))

    def add_layer(self, element, typ, name=None):
        """Create a new typ layer to display element. The name of the Layer
        will be name. If name is None, the name of the element will be used.

        """
        tempf = _genwrap("createLayer", Layer, View,
                         DataElement, ctypes.c_char_p, ctypes.c_char_p)
        return tempf(self, element, typ, name)

    def iter_layers(self):
        def do_iter(view):
            get_view_layer = _genwrap("getViewLayer", Layer,
                                      View, ctypes.c_uint32)
            idx = 0
            while True:
                try:
                    yield get_view_layer(view, idx)
                except SimpleApiError, err:
                    if err.code == SimpleApiError.SIMPLE_NOT_FOUND:
                        return
                    raise
                finally:
                    idx += 1
        return do_iter(self)

View._getViewName = \
    _genwrap("getViewName", ctypes.c_uint32, View, ctypes.c_char_p,
             ctypes.c_uint32)
View._setViewName = \
    _genwrap("setViewName", ctypes.c_int, View, ctypes.c_char_p)
View._getViewType = \
    _genwrap("getViewType", ctypes.c_uint32, View, ctypes.c_char_p,
             ctypes.c_uint32)
View._getViewPrimaryRasterElement = \
    _genwrap("getViewPrimaryRasterElement", DataElement, View)
Layer._getLayerName = \
    _genwrap("getLayerName", ctypes.c_uint32, Layer, ctypes.c_char_p,
             ctypes.c_uint32)
Layer._getLayerType = \
    _genwrap("getLayerType", ctypes.c_uint32, Layer, ctypes.c_char_p,
             ctypes.c_uint32)
Layer._getLayerElement = _genwrap("getLayerElement", DataElement, Layer)
Layer._getLayerView = _genwrap("getLayerView", View, Layer)
Layer._getLayerScaleOffset = \
    _genwrap("getLayerScaleOffset", ctypes.c_int, Layer,
             ctypes.POINTER(ctypes.c_double),
             ctypes.POINTER(ctypes.c_double),
             ctypes.POINTER(ctypes.c_double),
             ctypes.POINTER(ctypes.c_double))
Layer._setLayerScaleOffset = \
    _genwrap("setLayerScaleOffset", ctypes.c_int, Layer,
             ctypes.c_double, ctypes.c_double, ctypes.c_double,
             ctypes.c_double)
Layer._isLayerDisplayed = _genwrap("isLayerDisplayed", ctypes.c_int, Layer)
Layer._setLayerDisplayed = \
    _genwrap("setLayerDisplayed", ctypes.c_int, Layer, ctypes.c_int)
Layer._getLayerDisplayIndex = \
    _genwrap("getLayerDisplayIndex", ctypes.c_uint32, Layer)
Layer._setLayerDisplayIndex = \
    _genwrap("setLayerDisplayIndex", ctypes.c_int, Layer, ctypes.c_uint32)
Layer._deriveLayer = \
    _genwrap("deriveLayer", Layer, Layer, ctypes.c_char_p,
             ctypes.c_char_p)
Layer._convertLayer = _genwrap("convertLayer", Layer, Layer, ctypes.c_char_p)
Layer._isLayerActive = _genwrap("isLayerActive", ctypes.c_int, Layer)
Layer._activateLayer = _genwrap("activateLayer", ctypes.c_int, Layer)

class PassArea(ctypes.c_uint32):
    "Opticks PassAreaEnum type."
    LOWER = 0
    UPPER = 1
    MIDDLE = 2
    OUTSIDE = 3

    def __repr__(self):
        strname = "Unknown"
        if self.value == self.LOWER:
            strname = "Below 1st threshold"
        elif self.value == self.UPPER:
            strname = "Above 1st threshold"
        elif self.value == self.MIDDLE:
            strname = "Between 1st and 2nd thresholds"
        elif self.value == self.OUTSIDE:
            strname = "Outside 1st and 2nd thresholds"
        return "<PassArea: %s>" % strname

class RegionUnits(ctypes.c_uint32):
    "Opticks RegionUnitsEnum type."
    RAW_VALUE = 0
    PERCENTAGE = 1
    PERCENTILE = 2
    STD_DEV = 3

    def __repr__(self):
        strname = "Unknown"
        if self.value == self.RAW_VALUE:
            strname = "Raw value"
        elif self.value == self.PERCENTAGE:
            strname = "Percentage"
        elif self.value == self.PERCENTILE:
            strname = "Percentile"
        elif self.value == self.STD_DEV:
            strname = "Standard deviation"
        return "<RegionUnits: %s>" % strname

class Stretch(ctypes.c_uint32):
    "Opticks StretchTypeEnum type."
    LINEAR = 0
    LOGARITHMIC = 1
    EXPONENTIAL = 2
    EQUALIZE = 3

    def __repr__(self):
        strname = "Unknown"
        if self.value == self.LINEAR:
            strname = "Linear"
        elif self.value == self.LOGARITHMIC:
            strname = "Logarithmic"
        elif self.value == self.EXPONENTIAL:
            strname = "Exponential"
        elif self.value == self.EQUALIZE:
            strname = "Histogram Equalization"
        return "<Stretch: %s>" % strname

class Color(object):
    "Opticks Color type"

    def __init__(self, value=None, red=0, green=0, blue=0, alpha=255):
        #pylint: disable=R0913
        if value is None:
            self.red = red
            self.green = green
            self.blue = blue
            self.alpha = alpha
        elif isinstance(value, Color):
            # copy constructor
            self.red = value.red
            self.green = value.green
            self.blue = value.blue
            self.alpha = value.alpha
        elif isinstance(value, str):
            if len(value) == 9 and value[0] == '#':
                self.red = int(value[1:3], 16)
                self.green = int(value[3:5], 16)
                self.blue = int(value[5:7], 16)
                self.alpha = int(value[7:9], 16)
            else:
                raise TypeError("Color initialation must be an " \
                                "encoded int, '#RRGGBBAA', " \
                                "'(red, green, blue)', " \
                                "'(red, green, blue, alpha)', " \
                                "or 'red=0, green=0, blue=0, alpha=255'")
        elif isinstance(value, tuple) and (len(value) == 3 or len(value) == 4):
            if len(value) == 3:
                value = value + (alpha, )
            self.red, self.green, self.blue, self.alpha = value
        elif isinstance(value, int) or isinstance(value, long):
            self.red = (value >> 24) & 0xff
            self.green = (value >> 16) & 0xff
            self.blue = (value >> 8) & 0xff
            self.alpha = value & 0xff
        else:
            raise TypeError("Color initialation must be an encoded int, " \
                            "'#RRGGBBAA', '(red, green, blue)', " \
                            "'(red, green, blue, alpha)', or " \
                            "'red=0, green=0, blue=0, alpha=255'")

    def __eq__(self, other):
        return (self.red == other.red and
                self.green == other.green and
                self.blue == other.blue and
                self.alpha == other.alpha)

    @property
    def value(self):
        return ((self.red << 24) | (self.green << 16) |
                (self.blue << 8) | self.alpha)

    def __repr__(self):
        return ('#%02X%02X%02X%02X' %
                (self.red, self.green, self.blue, self.alpha))

class RasterChannel(ctypes.c_uint32):
    "Opticks RasterChannelEnum type."
    GRAY = 0
    RED = 1
    GREEN = 2
    BLUE = 3

    def __repr__(self):
        strname = "Unknown"
        if self.value == self.GRAY:
            strname = "gray/colormap/indexed"
        elif self.value == self.RED:
            strname = "red"
        elif self.value == self.GREEN:
            strname = "green"
        elif self.value == self.BLUE:
            strname = "blue"
        return "<RasterChannel: %s>" % strname

class ComplexComponent(ctypes.c_uint32):
    "Opticks ComplexComponentEnum type."
    MAGNITUDE = 0
    PHASE = 1
    INPHASE = 2
    QUADRATURE = 3

    def __repr__(self):
        strname = "Unknown"
        if self.value == self.MAGNITUDE:
            strname = "magnitude"
        elif self.value == self.PHASE:
            strname = "phase"
        elif self.value == self.INPHASE:
            strname = "in-phase"
        elif self.value == self.QUADRATURE:
            strname = "quadrature"
        return "<ComplexComponent: %s>" % strname

class ThresholdLayer(Layer):
    "A Threshold layer."

    class Info(ctypes.Structure):
        _fields_ = [('first_threshold', ctypes.c_double),
                    ('second_threshold', ctypes.c_double),
                    ('pass_area', PassArea),
                    ('units', RegionUnits)]

        def __repr__(self):
            return ("<ThresholdInfo: %f - %f %r %r>" %
                    (self.first_threshold, self.second_threshold,
                     self.pass_area, self.units))

    def __init__(self, name=None, other=None):
        """Get a Threshold Layer by name.
        See Layer documentation for information on values for name.
        If other is specified the internal handle for that Layer will
        be copied to the new Layer. The typ value for the Layer
        contructor will be 'ThresholdLayer'.
        Other may be a Layer object which will be cast to a ThresholdLayer.

        """
        if other is not None:
            if not isinstance(other, Layer) or other.type != 'ThresholdLayer':
                raise TypeError("Layer is not a ThresholdLayer.")
            Layer.__init__(self, other=other)
        else:
            Layer.__init__(self, name=name, typ='ThresholdLayer')

    def get_info(self):
        info = ThresholdLayer.Info()
        tempf = _genwrap('getThresholdLayerInfo', ctypes.c_int,
                         Layer, ctypes.POINTER(ThresholdLayer.Info))
        tempf(self, ctypes.byref(info))
        return info
    def set_info(self, info):
        assert(isinstance(info, ThresholdLayer.Info))
        tempf = _genwrap('setThresholdLayerInfo', ctypes.c_int,
                         Layer, ctypes.POINTER(ThresholdLayer.Info))
        tempf(self, ctypes.byref(info))
    info = property(get_info, set_info, doc="Threshold parameters.")

    def get_thresholds(self):
        info = self.info
        return info.first_threshold, info.second_threshold
    def set_thresholds(self, (first, second)):
        info = self.info
        info.first_threshold, info.second_threshold = first, second
        self.info = info
    thresholds = property(get_thresholds,
                          set_thresholds,
                          doc="First and second thresholds")

    def get_pass_area(self):
        return self.info.pass_area
    def set_pass_area(self, value):
        info = self.info
        info.pass_area = value
        self.info = info
    pass_area = property(get_pass_area, set_pass_area, doc="Pass area enum")

    def get_units(self):
        return self.info.units
    def set_units(self, value):
        info = self.info
        info.units = value
        self.info = info
    units = property(get_units, set_units, doc="Region units enum")

class PseudocolorClass(object):
    "A pseudocolor class."

    _getPseudocolorClassName = \
        _genwrap("getPseudocolorClassName", ctypes.c_uint32,
                 Layer, ctypes.c_int32, ctypes.c_char_p, ctypes.c_uint32)
    _getPseudocolorClassValue = \
        _genwrap("getPseudocolorClassValue", ctypes.c_int32,
                 Layer, ctypes.c_int32)
    _getPseudocolorClassColor = \
        _genwrap("getPseudocolorClassColor", ctypes.c_uint32,
                 Layer, ctypes.c_int32)
    _isPseudocolorClassDisplayed = \
        _genwrap("isPseudocolorClassDisplayed", ctypes.c_int, Layer,
                 ctypes.c_int32)
    _setPseudocolorClassName = \
        _genwrap("setPseudocolorClassName", ctypes.c_int, Layer,
                 ctypes.c_int32, ctypes.c_char_p)
    _setPseudocolorClassValue = \
        _genwrap("setPseudocolorClassValue", ctypes.c_int, Layer,
                 ctypes.c_int32, ctypes.c_int32)
    _setPseudocolorClassColor = \
        _genwrap("setPseudocolorClassColor", ctypes.c_int, Layer,
                 ctypes.c_int32, ctypes.c_uint32)
    _setPseudocolorClassDisplayed = \
        _genwrap("setPseudocolorClassDisplayed", ctypes.c_int,
                 Layer, ctypes.c_int32, ctypes.c_int)

    def __init__(self, layer, class_id):
        self.__layer, self.__id = layer, class_id

    def __repr__(self):
        if self.displayed:
            return ("<PseudocolorClass '%s' %i displayed as %s>" %
                    (self.name, self.value, self.color))
        return ("<PseudocolorClass '%s' %i hidden with color %s>" %
                (self.name, self.value, self.color))

    def get_name(self):
        return _stringbuffer_wrap(self._getPseudocolorClassName,
                                  self.__layer, self.__id)
    def set_name(self, name):
        self._setPseudocolorClassName(self.__layer, self.__id, name)
    name = property(get_name, set_name, doc="The pseudocolor class name.")

    def get_value(self):
        return self._getPseudocolorClassValue(self.__layer, self.__id)
    def set_value(self, value):
        self._setPseudocolorClassValue(self.__layer, self.__id, value)
    value = property(get_value, set_value, doc="The pseudocolor class value.")

    def get_color(self):
        return Color(self._getPseudocolorClassColor(self.__layer, self.__id))
    def set_color(self, color):
        if not isinstance(color, Color):
            color = Color(color)
        self._setPseudocolorClassColor(self.__layer, self.__id, color.value)
    color = property(get_color, set_color, doc="The pseudocolor class color.")

    def get_displayed(self):
        return bool(self._isPseudocolorClassDisplayed(self.__layer, self.__id))
    def set_displayed(self, value):
        self._setPseudocolorClassDisplayed(self.__layer, self.__id, value)
    displayed = property(get_displayed,
                         set_displayed,
                         doc="Is the pseudocolor class displayed?")

class PseudocolorLayer(Layer):
    "A Pseudocolor layer."

    _getPseudocolorClassCount = \
        _genwrap("getPseudocolorClassCount", ctypes.c_uint32, Layer)
    _getPseudocolorClassId = \
        _genwrap("getPseudocolorClassId", ctypes.c_int32, Layer,
                 ctypes.c_uint32)
    _addPseudocolorClass = \
        _genwrap("addPseudocolorClass", ctypes.c_int32, Layer,
                 ctypes.c_char_p, ctypes.POINTER(ctypes.c_int32),
                 ctypes.POINTER(ctypes.c_uint32),
                 ctypes.POINTER(ctypes.c_int))

    def __init__(self, name=None, other=None):
        """Get a Pseudocolor Layer by name.
        See Layer documentation for information on values for name.
        If other is specified the internal handle for that Layer
        will be copied to the new Layer. The typ value for the Layer
        contructor will be 'PseudocolorLayer'.
        Other may be a Layer object which will be cast to a PseudocolorLayer.

        """
        if other is not None:
            if not isinstance(other, Layer) or other.type != 'PseudocolorLayer':
                raise TypeError("Layer is not a PseudocolorLayer.")
            Layer.__init__(self, other=other)
        else:
            Layer.__init__(self, name=name, typ='PseudocolorLayer')

    def __len__(self):
        return self._getPseudocolorClassCount(self)

    def __getitem__(self, index):
        return PseudocolorClass(self, self._getPseudocolorClassId(self, index))

    def __iter__(self):
        def do_iter(layer, cnt):
            for index in xrange(cnt):
                yield layer[index]
        return do_iter(self, len(self))

    def add_class(self, name=None, value=None, color=None, displayed=None):
        """Add a new class.
        If name, value, color, and displayed are not None, the class
        is initialized to those values. If any of name, value, color,
        or displayed is None, an uninitialized class is created.

        """
        if (name is not None and value is not None and
            color is not None and displayed is not None):
            if not isinstance(value, ctypes.c_int32):
                value = ctypes.c_int32(value)
            if not isinstance(color, Color):
                color = Color(color)
            color = ctypes.c_uint32(color.value)
            if displayed:
                displayed = ctypes.c_int(1)
            else:
                displayed = ctypes.c_int(0)
            temph = self._addPseudocolorClass(self, name,
                                              ctypes.byref(value),
                                              ctypes.byref(color),
                                              ctypes.byref(displayed))
            return PseudocolorClass(self, temph)
        temph = self._addPseudocolorClass(self, None,
                                          None, None, None)
        return PseudocolorClass(self, temph)

class RasterLayerStretchInfo(ctypes.Structure):
    _fields_ = [('lower', ctypes.c_double),
                ('upper', ctypes.c_double),
                ('stretch', Stretch),
                ('units', RegionUnits)]

    def __repr__(self):
        return ("<RasterLayerStretchInfo: %f-%f, type %s, units %s>" %
               (self.lower, self.upper, self.stretch, self.units))

class RasterStatistics(ctypes.Structure):
    #pylint: disable=W0201
    _fields_ = [('min', ctypes.c_double),
                ('max', ctypes.c_double),
                ('mean', ctypes.c_double),
                ('std_dev', ctypes.c_double),
                ('_histogramCenters', ctypes.POINTER(ctypes.c_double)),
                ('_histogramCounts', ctypes.POINTER(ctypes.c_uint)),
                ('_percentiles', ctypes.POINTER(ctypes.c_double)),
                ('resolution', ctypes.c_uint32)]
    @property
    def histogram_centers(self):
        #pylint: disable=E0203
        if hasattr(self, "_stored_centers"):
            return self._stored_centers
        self._stored_centers = self._histogramCenters[:256]
        return self._stored_centers

    @property
    def histogram_counts(self):
        #pylint: disable=E0203
        if hasattr(self, "_stored_counts"):
            return self._stored_counts
        self._stored_counts = self._histogramCounts[:256]
        return self._stored_counts

    @property
    def percentiles(self):
        #pylint: disable=E0203
        if hasattr(self, "_stored_percentiles"):
            return self._stored_percentiles
        self._stored_percentiles = self._percentiles[:1001]
        return self._stored_percentiles

    def __repr__(self):
        return "<RasterStatistics: %i resolution>" % self.resolution

class RasterLayer(Layer):
    "A Raster layer."

    _getRasterLayerStretchInfo = \
        _genwrap("getRasterLayerStretchInfo", ctypes.c_int, Layer,
                 RasterChannel, ctypes.POINTER(RasterLayerStretchInfo))
    _setRasterLayerStretchInfo = \
        _genwrap("setRasterLayerStretchInfo", ctypes.c_int, Layer,
                 RasterChannel, ctypes.POINTER(RasterLayerStretchInfo))
    _getRasterLayerComplexComponent = \
        _genwrap("getRasterLayerComplexComponent", ComplexComponent, Layer)
    _setRasterLayerComplexComponent = \
        _genwrap("setRasterLayerComplexComponent", ctypes.c_int,
                 Layer, ComplexComponent)
    _getRasterLayerColormapName = \
        _genwrap("getRasterLayerColormapName", ctypes.c_uint32, Layer,
                 ctypes.c_char_p, ctypes.c_uint32)
    _setRasterLayerColormapName = \
        _genwrap("setRasterLayerColormapName", ctypes.c_int, Layer,
                 ctypes.c_char_p)
    _getRasterLayerColormapValues = \
        _genwrap("getRasterLayerColormapValues", ctypes.c_int, Layer,
                 ctypes.POINTER(ctypes.c_uint32))
    _setRasterLayerColormapValues = \
        _genwrap("setRasterLayerColormapValues", ctypes.c_int, Layer,
                 ctypes.c_char_p, ctypes.POINTER(ctypes.c_uint32))
    _getRasterLayerGpuEnabled = \
        _genwrap("getRasterLayerGpuEnabled", ctypes.c_int, Layer)
    _setRasterLayerGpuEnabled = \
        _genwrap("setRasterLayerGpuEnabled", ctypes.c_int, Layer, ctypes.c_int)
    _getRasterLayerFilterCount = \
        _genwrap("getRasterLayerFilterCount", ctypes.c_uint32, Layer,
                 ctypes.c_int)
    _getRasterLayerFilterName = \
        _genwrap("getRasterLayerFilterName", ctypes.c_uint32, Layer,
                 ctypes.c_uint32, ctypes.c_int, ctypes.c_char_p,
                 ctypes.c_uint32)
    _setRasterLayerFilters = \
        _genwrap("setRasterLayerFilters", ctypes.c_int, Layer,
                 ctypes.c_uint32, ctypes.POINTER(ctypes.c_char_p))
    _resetRasterLayerFilter = \
        _genwrap("resetRasterLayerFilter", ctypes.c_int, Layer,
                 ctypes.c_char_p)
    _setRasterLayerFilterFrozen = \
        _genwrap("setRasterLayerFilterFrozen", ctypes.c_int, Layer,
                 ctypes.c_char_p, ctypes.c_int)
    _isRasterLayerRgbDisplayed = \
        _genwrap("isRasterLayerRgbDisplayed", ctypes.c_int, Layer)
    _setRasterLayerRgbDisplayed = \
        _genwrap("setRasterLayerRgbDisplayed", ctypes.c_int, Layer,
                 ctypes.c_int)
    _getRasterLayerDisplayedBand = \
        _genwrap("getRasterLayerDisplayedBand", ctypes.c_uint32,
                 Layer, RasterChannel, ctypes.POINTER(ctypes.c_void_p))
    _setRasterLayerDisplayedBand = \
        _genwrap("setRasterLayerDisplayedBand", ctypes.c_int,
                 Layer, RasterChannel, ctypes.c_uint32, DataElement)
    _getRasterLayerStatistics = \
        _genwrap("getRasterLayerStatistics", ctypes.c_int,
                 Layer, RasterChannel, ComplexComponent,
                 ctypes.POINTER(RasterStatistics))

    def __init__(self, name=None, other=None):
        """Get a Raster Layer by name.
        See Layer documentation for information on values for name.
        If other is specified the internal handle for that Layer
        will be copied to the new Layer.
        The typ value for the Layer contructor will be 'RasterLayer'.
        Other may be a Layer object which will be cast to a RasterLayer.

        """
        if other is not None:
            if not isinstance(other, Layer) or other.type != 'RasterLayer':
                raise TypeError("Layer is not a RasterLayer.")
            Layer.__init__(self, other=other)
        else:
            Layer.__init__(self, name=name, typ='RasterLayer')

    def get_stretch(self, channel):
        nfo = RasterLayerStretchInfo()
        self._getRasterLayerStretchInfo(self, channel, ctypes.byref(nfo))
        return nfo
    def set_stretch(self, channel, nfo):
        self._setRasterLayerStretchInfo(self, channel, ctypes.byref(nfo))

    def get_stretch_gray_type(self):
        nfo = self.get_stretch(RasterChannel.GRAY)
        return nfo.stretch
    def set_stretch_gray_type(self, value):
        nfo = self.get_stretch(RasterChannel.GRAY)
        nfo.stretch = value
        self.set_stretch(RasterChannel.GRAY, nfo)
    stretch_gray_type = property(get_stretch_gray_type, set_stretch_gray_type)

    def get_stretch_rgb_type(self):
        nfo = self.get_stretch(RasterChannel.RED)
        return nfo.stretch
    def set_stretch_rgb_type(self, value):
        nfo = self.get_stretch(RasterChannel.RED)
        nfo.stretch = value
        self.set_stretch(RasterChannel.RED, nfo)
    stretch_rgb_type = property(get_stretch_rgb_type, set_stretch_rgb_type)

    def get_stretch_gray(self):
        nfo = self.get_stretch(RasterChannel.GRAY)
        return (nfo.lower, nfo.upper)
    def set_stretch_gray(self, (lower, upper)):
        nfo = self.get_stretch(RasterChannel.GRAY)
        if lower is not None:
            nfo.lower = lower
        if upper is not None:
            nfo.upper = upper
        self.set_stretch(RasterChannel.GRAY, nfo)
    stretch_gray = property(get_stretch_gray, set_stretch_gray)

    def get_stretch_gray_units(self):
        nfo = self.get_stretch(RasterChannel.GRAY)
        return nfo.units
    def set_stretch_gray_units(self, value):
        nfo = self.get_stretch(RasterChannel.GRAY)
        nfo.units = value
        self.set_stretch(RasterChannel.GRAY, nfo)
    stretch_gray_units = property(get_stretch_gray_units, set_stretch_gray_units)

    def get_stretch_red(self):
        nfo = self.get_stretch(RasterChannel.RED)
        return (nfo.lower, nfo.upper)
    def set_stretch_red(self, (lower, upper)):
        nfo = self.get_stretch(RasterChannel.RED)
        if lower is not None:
            nfo.lower = lower
        if upper is not None:
            nfo.upper = upper
        self.set_stretch(RasterChannel.RED, nfo)
    stretch_red = property(get_stretch_red, set_stretch_red)

    def get_stretch_red_units(self):
        nfo = self.get_stretch(RasterChannel.RED)
        return nfo.units
    def set_stretch_red_units(self, value):
        nfo = self.get_stretch(RasterChannel.RED)
        nfo.units = value
        self.set_stretch(RasterChannel.RED, nfo)
    stretch_red_units = property(get_stretch_red_units, set_stretch_red_units)

    def get_stretch_green(self):
        nfo = self.get_stretch(RasterChannel.GREEN)
        return (nfo.lower, nfo.upper)
    def set_stretch_green(self, (lower, upper)):
        nfo = self.get_stretch(RasterChannel.GREEN)
        if lower is not None:
            nfo.lower = lower
        if upper is not None:
            nfo.upper = upper
        self.set_stretch(RasterChannel.GREEN, nfo)
    stretch_green = property(get_stretch_green, set_stretch_green)

    def get_stretch_green_units(self):
        nfo = self.get_stretch(RasterChannel.GREEN)
        return nfo.units
    def set_stretch_green_units(self, value):
        nfo = self.get_stretch(RasterChannel.GREEN)
        nfo.units = value
        self.set_stretch(RasterChannel.GREEN, nfo)
    stretch_green_units = property(get_stretch_green_units, set_stretch_green_units)

    def get_stretch_blue(self):
        nfo = self.get_stretch(RasterChannel.BLUE)
        return (nfo.lower, nfo.upper)
    def set_stretch_blue(self, (lower, upper)):
        nfo = self.get_stretch(RasterChannel.BLUE)
        if lower is not None:
            nfo.lower = lower
        if upper is not None:
            nfo.upper = upper
        self.set_stretch(RasterChannel.BLUE, nfo)
    stretch_blue = property(get_stretch_blue, set_stretch_blue)

    def get_stretch_blue_units(self):
        nfo = self.get_stretch(RasterChannel.BLUE)
        return nfo.units
    def set_stretch_blue_units(self, value):
        nfo = self.get_stretch(RasterChannel.BLUE)
        nfo.units = value
        self.set_stretch(RasterChannel.BLUE, nfo)
    stretch_blue_units = property(get_stretch_blue_units, set_stretch_blue_units)

    def get_complex_component(self):
        return self._getRasterLayerComplexComponent(self)
    def set_complex_component(self, value):
        self._setRasterLayerComplexComponent(self, value)
    complex_component = property(get_complex_component,
                                 set_complex_component,
                                 doc="Complex component displayed.")

    def get_colormap_name(self):
        return _stringbuffer_wrap(self._getRasterLayerColormapName, self)
    def set_colormap_name(self, name):
        self._setRasterLayerColormapName(self, name)
    colormap_name = property(get_colormap_name,
                             set_colormap_name,
                             doc="Internal name or filename of the colormap.")

    def get_colormap(self):
        cmap = (ctypes.c_uint32 * 256)()
        self._getRasterLayerColormapValues(self, cmap)
        return map(Color, cmap)
    def set_colormap(self, value, name=None):
        """Set a new colormap. Value is a sequence of 256
        colors. name is an optional name to associate
        with the colormap.

        """
        if len(value) != 256:
            raise ValueError("Colormap must be a sequence of 256 colors.")
        cmap = (ctypes.c_uint32 * 256)()
        cmap[:] = map(lambda x: Color(x).value, value)
        self._setRasterLayerColormapValues(self, name, cmap)
    colormap = property(get_colormap,
                        set_colormap,
                        doc="""Colormap table which is applied
                            when in grayscale/colormap/indexed
                            display mode.""")

    def get_gpu_enabled(self):
        return bool(self._getRasterLayerGpuEnabled(self))
    def set_gpu_enabled(self, value):
        self._setRasterLayerGpuEnabled(self, value)
    gpu_enabled = property(get_gpu_enabled,
                           set_gpu_enabled,
                           doc="Is the GPU rendering this layer?")

    def get_rgb_displayed(self):
        return bool(self._isRasterLayerRgbDisplayed(self))
    def set_rgb_displayed(self, value):
        self._setRasterLayerRgbDisplayed(self, value)
    rgb_displayed = property(get_rgb_displayed, set_rgb_displayed)

    def get_displayed_band(self, channel):
        rval = ctypes.c_void_p(0)
        bandnum = self._getRasterLayerDisplayedBand(self, channel,
                                                    ctypes.byref(rval))
        if not rval:
            element = None
        else:
            data_element = DataElement(subtype_as_void=rval,
                                       typ="RasterElement")
            element = RasterElement(element=data_element)
        return (bandnum, element)

    def set_displayed_band(self, channel, band, element=None):
        if element is None:
            relement = self.get_displayed_band(channel)[1]
            if relement is not None:
                self._setRasterLayerDisplayedBand(self, channel, band, relement)
        else:
            self._setRasterLayerDisplayedBand(self, channel, band, element)

    def set_rgb_bands(self, red=None, green=None, blue=None):
        self.rgb_displayed = True
        if red is not None:
            self.set_displayed_band(RasterChannel.RED, red, self.element)
        if green is not None:
            self.set_displayed_band(RasterChannel.GREEN, green, self.element)
        if blue is not None:
            self.set_displayed_band(RasterChannel.BLUE, blue, self.element)

    def set_gray_band(self, gray):
        self.rgb_displayed = False
        self.set_displayed_band(RasterChannel.GRAY, gray, self.element)

    def get_statistics(self, channel, component=ComplexComponent.MAGNITUDE):
        stat = RasterStatistics()
        self._getRasterLayerStatistics(self, channel, component, stat)
        return stat

    @property
    def filters(self):
        rval = []
        for index in range(self._getRasterLayerFilterCount(self, 0)):
            rval.append(_stringbuffer_wrap(self._getRasterLayerFilterName,
                                           self, index, 0))
        return rval

    def get_enabled_filters(self):
        rval = []
        for index in range(self._getRasterLayerFilterCount(self, 1)):
            rval.append(_stringbuffer_wrap(self._getRasterLayerFilterName,
                                           self, index, 1))
        return rval
    def set_enabled_filters(self, value):
        value = list(value)
        count = len(value)
        filters = (ctypes.c_char_p * count)()
        filters[:] = value
        self._setRasterLayerFilters(self, count, filters)
    enabled_filters = property(get_enabled_filters,
                               set_enabled_filters,
                               doc="Currently enabled GPU filters.")

    def reset_filter(self, filter_name):
        """Reset a feedback filter. If filter is not a feedback
        filter, do nothing.

        """
        self._resetRasterLayerFilter(self, filter_name)

    def freeze_filter(self, filter_name, freeze=True):
        """Freeze of unfreeze a feedback filter. If filter
        is not a feedback filter, do nothing.

        """
        self._setRasterLayerFilterFrozen(self, filter_name, int(freeze))

class AnimationState(ctypes.c_uint32):
    "Opticks AnimationState type."
    STOP = 0
    PLAY_FORWARD = 1
    PLAY_BACKWARD = 2
    PAUSE_FORWARD = 3
    PAUSE_BACKWARD = 4

    def __repr__(self):
        if self.value == self.STOP:
            return "<AnimationState: stopped>"
        elif self.value == self.PLAY_FORWARD:
            return "<AnimationState: playing forward>"
        elif self.value == self.PLAY_BACKWARD:
            return "<AnimationState: playing backward>"
        elif self.value == self.PAUSE_FORWARD:
            return "<AnimationState: paused, will resume forward>"
        elif self.value == self.PAUSE_BACKWARD:
            return "<AnimationState: paused, will resume backward>"
        return "<AnimationState: unknown value>"

class AnimationCycle(ctypes.c_uint32):
    "Opticks AnimationCycle type."
    PLAY_ONCE = 0
    REPEAT = 1
    BOUNCE = 2

    def __repr__(self):
        if self.value == self.PLAY_ONCE:
            return "<AnimationCycle: play once>"
        elif self.value == self.REPEAT:
            return "<AnimationCycle: repeat>"
        elif self.value == self.BOUNCE:
            return "<AnimationCycle: bounce>"
        return "<AnimationCycle: unknown value>"

animation_callback_t = ctypes.CFUNCTYPE(None, ctypes.c_char_p,
                                        ctypes.c_char_p, ctypes.c_uint32,
                                        ctypes.c_double, ctypes.c_void_p)

class Animation(ctypes.Structure):
    _fields_ = [("handle", ctypes.c_void_p)]
    __owns = False

    def __init__(self, name=None, create=False, time_based=True):
        """Get an animation by name. If name is none, get the active animation
        If create is True and the animation
        does not exist, it will be created. If created, time_based will
        determine if the animation is time based of frame based.

        """
        ctypes.Structure.__init__(self)
        self.__owns = False
        try:
            tempf = _genwrap("getAnimationController", Animation,
                             ctypes.c_char_p)
            self.handle = tempf(name).handle
        except SimpleApiError:
            if not create:
                raise
            tempf = _genwrap("createAnimationController", Animation,
                                   ctypes.c_char_p, ctypes.c_int)
            self.handle = tempf(name, time_based).handle

    def __del__(self):
        if self.__owns:
            self._destroyAnimationController(self)

    def destroy(self, val=True):
        """Mark this animation for destruction. When the animation object
        is garbage collected it will be destroyed. If val is False,
        destruction will be cancelled.

        """
        self.__owns = val

    def get_state(self):
        return self._getAnimationControllerState(self)
    def set_state(self, value):
        if not isinstance(value, AnimationState):
            value = AnimationState(value)
        self._setAnimationControllerState(self, value)
    state = property(get_state, set_state,
                     doc="Playback state of the animation.")

    def get_cycle(self):
        return self._getAnimationControllerCycle(self)
    def set_cycle(self, value):
        if not isinstance(value, AnimationCycle):
            value = AnimationCycle(value)
        self._setAnimationControllerCycle(self, value)
    cycle = property(get_cycle, set_cycle, doc="Cycle mode of the animation.")

    def get_can_drop_frames(self):
        return bool(self._canAnimationControllerDropFrames(self))
    def set_can_drop_frames(self, value):
        self._setAnimationControllerCanDropFrames(self, value)
    can_drop_frames = property(get_can_drop_frames,
                               set_can_drop_frames,
                               doc="""Allow the controller to drop
                               frames if necessary to maintain
                               the frame rate.""")

    def get_interval_multiplier(self):
        return self._getAnimationControllerIntervalMultiplier(self)
    def set_interval_multiplier(self, value):
        self._setAnimationControllerIntervalMultiplier(self, value)
    interval_multiplier = property(get_interval_multiplier,
                                   set_interval_multiplier,
                                   doc="Adjust the speed of playback.")

    def activate(self):
        "Make this animation active in the animation toolbar."
        self._activateAnimationController(self)

    def attach(self, raster):
        """Attach a raster element to an animation. Raster must be a
        raster layer.

        """
        self._attachRasterLayerToAnimationController(self, raster)

    def callback(self, name, callback_func, frame_count, frame_times=None,
                 user_data=None):
        """Attach a callback_func to an animation.
        If callback_func is a Python callable, it will be wrapped
        with animation_callback_t. name is the name for the new
        attachment. frame_count is the number of frames. Each
        time a frame is `displayed' callback_func will be executed.
        If the animation is time based, frame_times can be a
        list of real values indicating playback times. The
        list must be of length equal to frame_count. If
        frame_times is None, times will be generated for 1fps playback.
        user_data will be passed as is to the callback function.

        """
        #pylint: disable=R0913
        typ = (ctypes.c_double * frame_count)
        if frame_times is not None and not isinstance(frame_times, typ):
            if len(frame_times) != frame_count:
                raise TypeError("`frame_times' must be" \
                                "None or a list of length %i" % frame_count)
            tmp = typ()
            for idx in xrange(frame_count):
                tmp[idx] = frame_times[idx]
            frame_times = tmp
        if not isinstance(callback_func, animation_callback_t):
            callback_func = animation_callback_t(callback_func)
        hndl = ctypes.c_void_p(
            self._attachCallbackToAnimationController(self, name,
                                                      callback_func,
                                                      user_data, frame_count,
                                                      frame_times))
        class DeleterObj(object):
            def __init__(self, cntrl, name, hndl, cb_func):
                self.__cntrl = cntrl
                self.__name = name
                self.__hndl = hndl
                self.__cb_func = cb_func
            def __del__(self):
                destroy_attachment = \
                    _genwrap("destroyAnimationControllerAttachment", None,
                             Animation, ctypes.c_char_p, ctypes.c_void_p,
                             errorCheck=False)
                destroy_attachment(self.__cntrl, self.__name, self.__hndl)
                del self.__cb_func
        return DeleterObj(self, name, hndl, callback_func)

    def play(self):
        self._playAnimationController(self)

    def pause(self):
        self._pauseAnimationController(self)

    def stop(self):
        self._stopAnimationController(self)

Animation._destroyAnimationController = \
    _genwrap("destroyAnimationController", None, Animation, errorCheck=False)
Animation._activateAnimationController = \
    _genwrap("activateAnimationController", ctypes.c_int, Animation)
Animation._getAnimationControllerState = \
    _genwrap("getAnimationControllerState", AnimationState, Animation)
Animation._setAnimationControllerState = \
    _genwrap("setAnimationControllerState", ctypes.c_int, Animation,
             AnimationState)
Animation._playAnimationController = \
    _genwrap("playAnimationController", ctypes.c_int, Animation)
Animation._pauseAnimationController = \
    _genwrap("pauseAnimationController", ctypes.c_int, Animation)
Animation._stopAnimationController = \
    _genwrap("stopAnimationController", ctypes.c_int, Animation)
Animation._getAnimationControllerCycle = \
    _genwrap("getAnimationControllerCycle", AnimationCycle, Animation)
Animation._setAnimationControllerCycle = \
    _genwrap("setAnimationControllerCycle", ctypes.c_int, Animation,
             AnimationCycle)
Animation._canAnimationControllerDropFrames = \
    _genwrap("canAnimationControllerDropFrames", ctypes.c_int, Animation)
Animation._setAnimationControllerCanDropFrames = \
    _genwrap("setAnimationControllerCanDropFrames", ctypes.c_int, Animation,
             ctypes.c_int)
Animation._getAnimationControllerIntervalMultiplier = \
    _genwrap("getAnimationControllerIntervalMultiplier", ctypes.c_double,
             Animation)
Animation._setAnimationControllerIntervalMultiplier = \
    _genwrap("setAnimationControllerIntervalMultiplier", ctypes.c_int,
             Animation, ctypes.c_double)
Animation._attachRasterLayerToAnimationController = \
    _genwrap("attachRasterLayerToAnimationController", ctypes.c_int,
             Animation, Layer)
Animation._attachCallbackToAnimationController = \
    _genwrap("attachCallbackToAnimationController", ctypes.c_void_p,
             Animation, ctypes.c_char_p, animation_callback_t,
             ctypes.c_void_p, ctypes.c_uint32,
             ctypes.POINTER(ctypes.c_double))

class Gcp(ctypes.Structure):
    _fields_ = [("column", ctypes.c_double),
                ("row", ctypes.c_double),
                ("__reserved1", ctypes.c_double),
                ("latitude", ctypes.c_double),
                ("longitude", ctypes.c_double),
                ("__reserved2", ctypes.c_double),
                ("rms_error_latitude", ctypes.c_double),
                ("rms_error_longitude", ctypes.c_double),
                ("__reserved3", ctypes.c_double)]

    def __repr__(self):
        return "<GCP Point (%5.2f, %5.2f)->(%3.8f,%3.8f) err: (%.8f,%.8f)>" % (
               self.column, self.row,
               self.latitude, self.longitude,
               self.rms_error_latitude, self.rms_error_longitude)

    def __eq__(self, other):
        return (self.column == other.column and
                self.row == other.row and
                self.latitude == other.latitude and
                self.longitude == other.longitude)

def get_gcp_points(gcp_list=None):
    "Get the list of GCP points and return them as a python list-like object"
    cnt = _get_gcp_count(gcp_list)
    lst = (Gcp * cnt)()
    _get_gcp_points(gcp_list, ctypes.cast(lst, ctypes.POINTER(Gcp)))
    return lst

def set_gcp_points(gcp_list=None, points=None):
    "Set the list of GCP points from a python list-like objects"
    if points is None:
        points = []
    cnt = len(points)
    typ = (Gcp * cnt)
    if type(points) != type:
        tmp = typ()
        for idx in range(cnt):
            tmp[idx] = points[idx]
        points = tmp
    _set_gcp_points(gcp_list, cnt, ctypes.cast(points, ctypes.POINTER(Gcp)))
    return cnt

_get_gcp_count = _genwrap("getGcpCount", ctypes.c_uint32, DataElement)
_get_gcp_point = _genwrap("getGcpPoint", Gcp, DataElement, ctypes.c_uint32)
_get_gcp_points = _genwrap("getGcpPoints", ctypes.c_uint32, DataElement,
                           ctypes.POINTER(Gcp))
_set_gcp_points = _genwrap("setGcpPoints", ctypes.c_uint32, DataElement,
                           ctypes.c_uint32, ctypes.POINTER(Gcp))
