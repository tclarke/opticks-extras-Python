import unittest
import opticks
import ctypes

#pylint: disable=W0212

def run_tests(*args):
    args = map(lambda x: "opticks.test.%s" % x, args)
    if len(args) == 0:
        args = ["opticks.test"]
    import sys
    runner = unittest.TextTestRunner(sys.stdout, verbosity=2)
    suite = unittest.TestLoader().loadTestsFromNames(args)
    return runner.run(suite)

def load_test_file(name, batch=False):
    "Load a file from the current test data path."
    import os.path
    load_file = opticks._genwrap("loadFile", ctypes.c_uint32,
                                 ctypes.c_char_p, ctypes.c_int)
    get_testdata_path = opticks._genwrap("getTestDataPath", ctypes.c_uint32,
                                         ctypes.c_char_p, ctypes.c_uint32)
    path = os.path.join(opticks._stringbuffer_wrap(get_testdata_path), name)
    rval = load_file(path, int(batch))
    return rval

class ErrorsTestCase(unittest.TestCase):
    def tearDown(self):
        opticks.SimpleApiError._set_last_error(
            opticks.SimpleApiError.SIMPLE_NO_ERROR)

    def test_error_set(self):
        opticks.SimpleApiError._set_last_error(
            opticks.SimpleApiError.SIMPLE_WRONG_TYPE)
        self.assertEqual(opticks.SimpleApiError._get_last_error(),
                         opticks.SimpleApiError.SIMPLE_WRONG_TYPE)

class AnimationTestCase(unittest.TestCase):
    def setUp(self):
        self.failUnless(load_test_file("ir_bushehr_06jun02_ps.tif"))
        self.view = opticks.View()

    def tearDown(self):
        self.view.destroy()
        self.view = None

    def test_animation_get(self):
        pass

class AnimationCallbackTestCase(unittest.TestCase):
    def setUp(self):
        self.anim = opticks.Animation.create('foo')
        self.deleter = None

    def tearDown(self):
        self.anim.destroy()
        self.anim = None
        self.deleter = None

    def test_animation_fetch(self):
        self.failUnless(opticks.Animation('foo'))
        self.anim.activate()
        self.failUnless(opticks.Animation())

    def test_callback_deletion(self):
        self.anim.activate()
        def test_cb(*args):
            pass
        self.deleter = self.anim.callback('bar', test_cb, 3)

class DataVariantTestCase(unittest.TestCase):
    def _string_test(self, typ, val):
        dvar = opticks.DataVariant(val, typ)
        self.failUnless(dvar.valid)
        self.failUnlessEqual(dvar.xml, val)

    def _val_test(self, typ, val):
        dvar = opticks.DataVariant(val)
        self.failUnless(dvar.valid)
        self.failUnlessEqual(dvar.dv_type, typ)
        if typ == "float" or typ == "double":
            self.failUnlessAlmostEqual(dvar.value, val)
        else:
            self.failUnlessEqual(dvar.value, val)

    def test_create_from_string(self):
        import sys
        self._string_test("DateTime", "2009-01-02T15:30:10Z")
        if sys.platform == "win32":
            self._string_test("Filename", "file:///C:/this/is/a/path.ext")
        else:
            self._string_test("Filename", "file:///this/is/a/path.ext")
        self._string_test("char", "-2")
        self._string_test("unsigned char", "2")
        self._string_test("short", "-300")
        self._string_test("unsigned short", "300")
        self._string_test("int", "-40000")
        self._string_test("unsigned int", "40000")
        self._string_test("Int64", "-1000000000000")
        self._string_test("UInt64", "1000000000000")
        self._string_test("float", "1.2345")
        self._string_test("double", "1.23456785830939")
        self._string_test("bool", "true")
        self._string_test("string", "this is a string")
        self._string_test("ColorType", "#11223355")
        self._string_test("ColorType", "InvalidColor")
        self._string_test("LocationType", "42.0049 -60.1234567891")
        # not going to test every enum type, just a few reprsentatives
        self._string_test("AnimationCycle", "play_once")
        self._string_test("ComplexComponent", "Phase")
        self._string_test("ProcessingLocation", "onDiskReadOnly")

    def test_create_from_python_value(self):
        self._val_test("string", "this is a string")
        self._val_test("char", -2)
        self._val_test("short", -300)
        self._val_test("int", -40000)
        self._val_test("Int64", -10000000000)
        self._val_test("unsigned char", 200)
        self._val_test("unsigned short", 32000)
        self._val_test("unsigned int", 3000000000)
        self._val_test("UInt64", 100000000000)
        self._val_test("float", 1.23)

    def test_positive_errors(self):
        self.failUnlessRaises(opticks.SimpleApiError,
                              opticks.DataVariant, "bad value", "int")
        self.failUnlessRaises(opticks.SimpleApiError,
                              opticks.DataVariant, "9999", "char")
        self.failIf(opticks.DataVariant().valid)
        val = 1.23456789012345678
        dvar = opticks.DataVariant(val)
        self.failUnless(dvar.valid)
        self.failUnlessEqual(dvar.dv_type, "float")
        self.failIfEqual(dvar.value, val)

class PlugInArgTestCase(unittest.TestCase):
    def setUp(self):
        self.plugin = opticks.PlugIn("Passthrough PlugIn")

    def tearDown(self):
        del self.plugin

    def test_values(self):
        pial = self.plugin.inputs
        self.failUnlessEqual(len(pial), 1)
        self.failUnlessEqual(pial.keys()[0], 'Input Integer')
        self.failUnlessEqual(pial[0].name, pial['Input Integer'].name)
        self.failUnlessEqual(pial[0].type, 'unsigned int')
        self.failUnless(pial[0].default_set)
        self.failIf(pial[0].actual_set)
        self.failUnlessEqual(pial[0].default, 10)

    def test_set(self):
        pial = self.plugin.inputs
        self.failUnlessEqual(pial[0].value, pial[0].default)
        pial[0].actual = 42
        self.failUnless(pial[0].actual_set)
        self.failUnlessEqual(pial[0].value, pial[0].actual)
        self.failUnlessEqual(pial[0].value, 42)

class ExecuteTestCase(unittest.TestCase):
    def setUp(self):
        self.plugin = opticks.PlugIn("Passthrough PlugIn")

    def tearDown(self):
        del self.plugin

    def test_passthrough(self):
        self.failUnless(self.plugin())
        self.failUnlessEqual(self.plugin.inputs[0].value,
                             self.plugin.outputs[0].value)

    def test_passthrough_non_default(self):
        self.plugin.inputs[0].actual = 42
        self.failUnless(self.plugin())
        self.failUnlessEqual(self.plugin.outputs[0].actual, 42)

class PcaTestCase(unittest.TestCase):
    def setUp(self):
        self.plugin = opticks.PlugIn("Principal Component Analysis")
        self.failUnless(load_test_file("ir_bushehr_06jun02_ps.tif", True))
        self.data_el = opticks.DataElement("ir_bushehr_06jun02_ps.tif")
        self.pass_data_el = None

    def tearDown(self):
        if self.data_el:
            self.data_el.destroy()
        if self.pass_data_el:
            self.pass_data_el.destroy()
        self.data_el, self.pass_data_el = None, None

    def test_pca(self):
        self.plugin.inputs['Data Element'].actual = self.data_el
        self.failUnless(self.plugin.inputs['Data Element'].actual_set)
        self.plugin.inputs['Transform Type'].actual = "Correlation Coefficient"
        self.failUnless(self.plugin())
        self.failUnless(self.plugin.outputs['Corrected Data Cube'].actual_set)
        corr = self.plugin.outputs['Corrected Data Cube'].actual
        self.pass_data_el = \
            opticks.DataElement.cast(corr, "RasterElement")

class GeoTestCase(unittest.TestCase):
    def setUp(self):
        self.failUnless(load_test_file("ir_bushehr_06jun02_ps.tif"))
        self.raster = opticks.DataElement("ir_bushehr_06jun02_ps.tif")
        gcp_match = "ir_bushehr_06jun02_ps.tif|Corner Coordinates"
        self.gcps = opticks.DataElement(gcp_match)

    def tearDown(self):
        self.gcps = None
        self.raster.destroy()
        self.raster = None

    def test_count(self):
        self.failUnlessEqual(opticks._get_gcp_count(self.gcps), 5)

    def test_get_point(self):
        point = opticks._get_gcp_point(self.gcps, 1)
        self.failUnlessAlmostEqual(0.0, point.column)
        self.failUnlessAlmostEqual(996.0, point.row)
        self.failUnlessAlmostEqual(28.82643037, point.latitude)
        self.failUnlessAlmostEqual(50.88279747, point.longitude)
        self.failUnlessAlmostEqual(0.0, point.rms_error_latitude)
        self.failUnlessAlmostEqual(0.0, point.rms_error_longitude)

    def test_points(self):
        points = list(opticks.get_gcp_points(self.gcps))
        self.failUnlessEqual(len(points), 5)
        points[1] = points[2]
        opticks.set_gcp_points(self.gcps, points)
        points = list(opticks.get_gcp_points(self.gcps))
        self.failUnlessEqual(points[1], points[2])

class DynamicObjectTestCase(unittest.TestCase):
    def setUp(self):
        self.dyn_obj = opticks.DynamicObject()

    def tearDown(self):
        self.dyn_obj = None

    def test_dynamic_object_creation(self):
        self.failIf(self.dyn_obj is None)

    def test_dynamic_object_get_set(self):
        self.dyn_obj['foo'] = 42
        self.failUnlessEqual(self.dyn_obj['foo'].value, 42)

    def test_configuration_settings(self):
        settings = opticks.ConfigurationSettings()
        self.failUnless(settings['FileLocations/ImportPath'].valid)

class MetadataTestCase(unittest.TestCase):
    def setUp(self):
        self.failUnless(load_test_file("ir_bushehr_06jun02_ps.tif", True))
        self.data_el = opticks.DataElement("ir_bushehr_06jun02_ps.tif")
        self.meta = self.data_el.metadata
        self.meta.clear()
        self.failUnlessEqual(len(self.meta), 0)

    def tearDown(self):
        self.data_el.destroy()
        self.data_el = None

    def test_basic(self):
        self.meta['a'] = 10
        self.meta.b = 20
        self.meta['c d'] = 30
        self.failUnlessEqual(len(self.meta), 3)
        self.failUnlessEqual(self.meta.a.value, 10)
        self.failUnlessEqual(self.meta['b'].value, 20)
        self.failUnlessEqual(self.meta['c d'].value, 30)

    def test_hierachical(self):
        self.meta['a/b/c'] = 10
        self.meta['a/d'] = 20
        self.failUnlessEqual(len(self.meta), 1)
        self.failUnlessEqual(len(self.meta.a), 2)
        self.failUnlessEqual(len(self.meta.a.b), 1)
        self.failUnlessEqual(self.meta.a.b.c.value, 10)
        self.failUnlessEqual(self.meta['a/b/c'].value, 10)
        self.failUnlessEqual(self.meta.a.d.value, 20)
        self.failUnlessEqual(self.meta['a/d'].value, 20)
        self.meta.clear()
        self.failUnlessEqual(len(self.meta), 0)

    def test_delete(self):
        self.meta.a = 'bcd'
        self.failUnlessEqual(len(self.meta), 1)
        self.failUnlessEqual(self.meta.a.value, 'bcd')
        del self.meta.a
        self.failUnlessEqual(len(self.meta), 0)

        self.meta['bcd'] = 'bcd'
        self.failUnlessEqual(len(self.meta), 1)
        self.failUnlessEqual(self.meta['bcd'].value, 'bcd')
        del self.meta['bcd']
        self.failUnlessEqual(len(self.meta), 0)

class AoiTestCase(unittest.TestCase):
    def setUp(self):
        self.failUnless(load_test_file("ir_bushehr_06jun02_ps.tif", True))
        self.data_el = opticks.DataElement("ir_bushehr_06jun02_ps.tif")
        self.aoi = opticks.Aoi.create("ir_bushehr_06jun02_ps.tif|test aoi")

    def tearDown(self):
        self.data_el.destroy()
        self.data_el = None

    def test_aoi(self):
        self.failUnless(self.aoi)
        self.aoi[10, 15] = True
        self.aoi[12, 15] = True
        self.aoi[10, 20] = True
        self.aoi[12, 20] = True
        self.failUnless(self.aoi[10, 15])
        self.failUnless(self.aoi[12, 15])
        self.failUnless(self.aoi[10, 20])
        self.failUnless(self.aoi[12, 20])
        self.failIf(self.aoi[42, 42])
        self.failUnlessEqual(self.aoi.minimal_bounding_box,
                             (10, 15, 12, 20))
        self.failUnlessEqual(len(list(iter(self.aoi))), 4)
        self.failUnlessEqual(list(iter(self.aoi)),
                             [(10, 15),(12, 15),(10, 20),(12, 20)])
        aiter = opticks.AoiIterator(raster=self.data_el)
        self.failUnlessEqual([aiter.next(), aiter.next(),
                              aiter.next(), aiter.next()],
                             [(0, 0), (1, 0), (2, 0), (3, 0)])
        aiter = opticks.AoiIterator(bounding_box=(1, 3, 2, 5))
        self.failUnlessEqual([aiter.next(), aiter.next(),
                              aiter.next(), aiter.next()],
                             [(1, 3), (2, 3), (1, 4), (2, 4)])

class TempSliceObject(object):
    def __init__(self, dims):
        self.dims = dims

    def __getitem__(self, key):
        return opticks._DataArrayTemp.parse_indices(key, self.dims)

class RasterTestCase(unittest.TestCase):
    def setUp(self):
        self.failUnless(load_test_file("ir_bushehr_06jun02_ps.tif", True))
        self.fetch_re = opticks.RasterElement("ir_bushehr_06jun02_ps.tif")
        self.create_re = None

    def tearDown(self):
        self.fetch_re.destroy()
        self.fetch_re = None
        if self.create_re is not None:
            self.create_re.destroy()
            self.create_re = None

    def test_get_element(self):
        self.failUnless(self.fetch_re)

    def test_data_info(self):
        dinfo = opticks.DataInfo(self.fetch_re)
        self.failUnlessEqual(dinfo.rows, 997)
        self.failUnlessEqual(dinfo.columns, 1000)
        self.failUnlessEqual(dinfo.bands, 3)
        self.failUnlessEqual(dinfo.interleave.value, opticks.Interleave.BIP)
        self.failUnlessEqual(dinfo.encoding.value, opticks.Encoding.INT2UBYTES)
        self.failUnlessEqual(dinfo.encoding_size, 2)
        self.failUnlessEqual(dinfo.bad_values, [0])

    def test_create_raster_element(self):
        interleave = opticks.Interleave.BSQ
        encoding = opticks.Encoding.INT1UBYTE
        location = opticks.ProcessingLocationPreference.RAM
        bad_values = [100, 101, 102]
        self.create_re = opticks.RasterElement.create3d_empty("Test element",
                                                              10, 12, 2,
                                                              interleave,
                                                              encoding,
                                                              location,
                                                              None,
                                                              bad_values)
        self.failUnless(self.create_re)
        self.create_re.destroy()

    def test_data_accessor(self):
        acc = self.fetch_re.get_data_accessor()
        self.failUnless(acc is not None and acc.valid)
        # data is BIP, locations are row, col, band zero indexed
        self.failUnlessEqual(acc.row[0], 1437) # 0, 0, 0
        self.failUnlessEqual(acc.row[1], 1421) # 0, 0, 1
        self.failUnlessEqual(acc.column[0], 1437) # 0, 0, 0
        acc.next_column()
        self.failUnlessEqual(acc.column[0], 1590) # 0, 1, 0
        acc.next_row()
        self.failUnlessEqual(acc.row[0], 1558) # 1, 0, 0
        acc.to_pixel(0, 0)
        self.failUnlessEqual(acc.row[0], 1437) # 0, 0, 0

        self.failUnlessEqual(acc[2, 4], 1365) # 4, 2, 0
        self.failUnlessEqual(acc[4, 2], 1654) # 2, 4, 0

    def test_data_accessor_args(self):
        acc = self.fetch_re.get_data_accessor(opticks.Interleave.BSQ,
                                              1, 1, 5, 7, 10, 11)
        self.failUnless(acc is not None and acc.valid)
        iter_results = map(lambda ad: ad.contents.value, acc.iter_rows())
        self.failUnlessEqual(iter_results, [1622, 1590])
        acc.to_pixel(10, 5)
        iter_results = map(lambda ad: ad.contents.value, acc.iter_columns())
        self.failUnlessEqual(iter_results, [1622, 1662, 1686])

    def test_data_accessor_write(self):
        acc = self.fetch_re.get_data_accessor(opticks.Interleave.BIP,
                                              ecol=1, erow=1)
        self.failUnless(acc is not None and acc.valid)
        def do_assign(acc):
            acc[0, 0] = 10
        self.failUnlessRaises(opticks.OpticksError, do_assign, acc)

        acc = self.fetch_re.get_data_accessor(opticks.Interleave.BIP,
                                              ecol=1, erow=1,
                                              write=True)
        self.failUnless(acc is not None and acc.valid)
        self.failUnlessEqual(acc[0, 0], 1437)
        acc[0, 0] = 10
        self.fetch_re.update()
        self.failUnlessEqual(acc[0, 0], 10)

    def test_data_pointer(self):
        data, deleter = self.fetch_re.get_data_pointer()
        self.failUnless(data is not None)
        self.failUnlessEqual(len(data), 5982000)
        self.failUnlessEqual(self.fetch_re.info.encoding.value,
                             opticks.Encoding.INT2UBYTES)
        self.failUnlessEqual(self.fetch_re.info.interleave.value,
                             opticks.Interleave.BIP)
        #check row=0, col=0, band=0 value
        ushort_ptr = ctypes.cast(ctypes.c_char_p(data[:]),
                                 ctypes.POINTER(ctypes.c_uint16))
        self.failUnlessEqual(ushort_ptr[0], 1437)
        #check row=0, col=3, band=1 value
        index = (3 * self.fetch_re.info.bands) + 1
        self.failUnlessEqual(ushort_ptr[index], 1341)
        #check very last pixel
        pos = len(data) / self.fetch_re.info.encoding_size - 1
        self.failUnlessEqual(ushort_ptr[pos], 1421)
        del data, deleter

    def test_data_pointer_args(self):
        #check row=0, col=0, band=0 value
        data, deleter = self.fetch_re.get_data_pointer(erow=0, ecol=0, eband=0)
        self.failUnless(data is not None)
        self.failUnlessEqual(len(data), self.fetch_re.info.encoding_size)
        ushort_ptr = ctypes.cast(ctypes.c_char_p(data[:]),
                                 ctypes.POINTER(ctypes.c_uint16))
        self.failUnlessEqual(ushort_ptr[0], 1437)
        del data, deleter
        #check row=0, col=3, band=1 value
        data, deleter = self.fetch_re.get_data_pointer(0, 0, 3, 3, 1, 1)
        self.failUnless(data is not None)
        self.failUnlessEqual(len(data), self.fetch_re.info.encoding_size)
        ushort_ptr = ctypes.cast(ctypes.c_char_p(data[:]),
                                 ctypes.POINTER(ctypes.c_uint16))
        self.failUnlessEqual(ushort_ptr[0], 1341)
        del data, deleter
        #check very last pixel
        data, deleter = self.fetch_re.get_data_pointer(brow=-1,
                                                       bcol=-1,
                                                       bband=-1)
        self.failUnless(data is not None)
        self.failUnlessEqual(len(data), self.fetch_re.info.encoding_size)
        ushort_ptr = ctypes.cast(ctypes.c_char_p(data[:]),
                                 ctypes.POINTER(ctypes.c_uint16))
        self.failUnlessEqual(ushort_ptr[0], 1421)
        del data, deleter

    def test_data_pointer_write(self):
        import array
        temp = array.array('H') #array of shorts
        temp.fromlist(range(20)) #populate with values from 0 to 20

        #writing to a region without enough data in buffer
        #should fail
        self.failUnlessRaises(ValueError, self.fetch_re.set_data_pointer, temp)

        #set column 0 to 19 in row 0, band 0 and then verify
        self.fetch_re.set_data_pointer(temp, erow=0, eband=0, ecol=19)
        data, deleter = self.fetch_re.get_data_pointer(erow=0, eband=0, ecol=19)
        self.failUnlessEqual(len(data) / self.fetch_re.info.encoding_size,
                             len(temp))
        ushort_ptr = ctypes.cast(ctypes.c_char_p(data[:]),
                                 ctypes.POINTER(ctypes.c_uint16))
        for index in xrange(len(data) / self.fetch_re.info.encoding_size):
            self.failUnlessEqual(ushort_ptr[index], temp[index])
        del data, deleter

        #set row 0 to 19 in column 0, band 0 and then verify
        self.fetch_re.set_data_pointer(temp, erow=19, eband=0, ecol=0)
        data, deleter = self.fetch_re.get_data_pointer(erow=19, eband=0, ecol=0)
        self.failUnlessEqual(len(data) / self.fetch_re.info.encoding_size,
                             len(temp))
        ushort_ptr = ctypes.cast(ctypes.c_char_p(data[:]),
                                 ctypes.POINTER(ctypes.c_uint16))
        for index in xrange(len(data) / self.fetch_re.info.encoding_size):
            self.failUnlessEqual(ushort_ptr[index], temp[index])
        del data, deleter

        #set band 0 to 2 in row 0, column 0 then verify
        temp = array.array('H') #array of shorts
        temp.fromlist(range(3)) #populate with values from 0 to 2
        self.fetch_re.set_data_pointer(temp, erow=0, eband=2, ecol=0)
        data, deleter = self.fetch_re.get_data_pointer(erow=0, eband=2, ecol=0)
        self.failUnlessEqual(len(data) / self.fetch_re.info.encoding_size,
                             len(temp))
        ushort_ptr = ctypes.cast(ctypes.c_char_p(data[:]),
                                 ctypes.POINTER(ctypes.c_uint16))
        for index in xrange(len(data) / self.fetch_re.info.encoding_size):
            self.failUnlessEqual(ushort_ptr[index], temp[index])
        del data, deleter

    def test_slices(self):
        tso = TempSliceObject((10, 20, 30))
        self.failUnlessEqual(tso[1],
                             [(1, 1, 1), (0, 20, 1), (0, 30, 1)])
        self.failUnlessEqual(tso[1, 2],
                             [(1, 1, 1), (2, 2, 1), (0, 30, 1)])
        self.failUnlessEqual(tso[...],
                             [(0, 10, 1), (0, 20, 1), (0, 30, 1)])
        self.failUnlessEqual(tso[1:1],
                             [(1, 1, 1), (0, 20, 1), (0, 30, 1)])
        self.failUnlessEqual(tso[1:1, 2:2],
                             [(1, 1, 1), (2, 2, 1), (0, 30, 1)])
        self.failUnlessEqual(tso[..., 1:1],
                             [(0, 10, 1), (0, 20, 1), (1, 1, 1)])
        self.failUnlessEqual(tso[..., 1:1, 2:2],
                             [(0, 10, 1), (1, 1, 1), (2, 2, 1)])
        self.failUnlessEqual(tso[1:1, ...],
                             [(1, 1, 1), (0, 20, 1), (0, 30, 1)])
        self.failUnlessEqual(tso[1:1, 2:2, ...],
                             [(1, 1, 1), (2, 2, 1), (0, 30, 1)])
        self.failUnlessEqual(tso[1:1, ..., 2:2],
                             [(1, 1, 1), (0, 20, 1), (2, 2, 1)])
        self.failUnlessEqual(tso[1, 2, 3],
                             [(1, 1, 1), (2, 2, 1), (3, 3, 1)])
        #fails if you provide more indices than dimensions
        try:
            print tso[1, 2, 3, 4]
            self.fail("Should have thrown an exception, " \
                      "specifically IndexError")
        except IndexError:
            pass
        except:
            self.fail("Should have thrown IndexError exception")
        #fails if you provide more than one ellipsis
        try:
            print tso[1, ..., ...]
            self.fail("Should have thrown an exception, " \
                      "specifically IndexError")
        except IndexError:
            pass
        except:
            self.fail("Should have thrown IndexError exception")

try:
    import numpy
    class RasterNumpyTestCase(unittest.TestCase):
        def setUp(self):
            self.failUnless(load_test_file("ir_bushehr_06jun02_ps.tif", True))
            self.fetch_re = opticks.RasterElement("ir_bushehr_06jun02_ps.tif")
            self.create_re = None

        def tearDown(self):
            self.fetch_re.destroy()
            self.fetch_re = None
            if self.create_re is not None:
                self.create_re.destroy()
                self.create_re = None

        def test_data_array(self):
            self.failUnless(self.fetch_re)
            data = self.fetch_re.data_array[...]
            self.failUnless(data is not None)
            self.failUnlessEqual(data.size, 2991000)
            self.failUnlessEqual(data.dtype, numpy.dtype('uint16'))
            self.failUnlessEqual(data.shape, (997, 1000, 3))
            del data

        def test_data_array_bad_writes(self):
            self.failUnless(self.fetch_re)
            org_data = self.fetch_re.data_array[1]
            fake_data = numpy.arange(org_data.size)
            del org_data
            try:
                self.fetch_re.data_array[1] = fake_data
                self.fail("No exception, but expected ValueError " \
                          "exception because numpy.ndarray.dtype " \
                          "is not correct")
            except ValueError:
                pass
            except:
                self.fail("Expected ValueError exception because " \
                          "numpy.ndarray.dtype is not correct")

            org_data = self.fetch_re.data_array[1]
            fake_data = numpy.arange(1, dtype=org_data.dtype)
            del org_data
            try:
                self.fetch_re.data_array[1] = fake_data
                self.fail("No exception, but expected ValueError exception " \
                          "because size of numpy.ndarray is not correct")
            except ValueError:
                pass
            except:
                self.fail("Expected ValueError exception because " \
                          "size of numpy.ndarray is not correct")

            import array
            fake_data = array.array('H')
            try:
                self.fetch_re.data_array[1] = fake_data
                self.fail("No exception, but expected TypeError " \
                          "exception because fake_data is not a numpy.ndarray")
            except TypeError:
                pass
            except:
                self.fail("Expected TypeError exception because " \
                          "fake_data is not a numpy.ndarray")

        def test_data_array_write(self):
            #row test
            org_data = self.fetch_re.data_array[1]
            fake_data = numpy.arange(org_data.size, dtype=org_data.dtype)
            fake_data.shape = org_data.shape
            self.fetch_re.data_array[1] = fake_data
            expected_data = numpy.arange(0,
                                         org_data.size,
                                         org_data.shape[2],
                                         dtype=org_data.dtype)
            del org_data
            new_data = self.fetch_re.data_array[1, ..., 0]
            expected_data.shape = new_data.shape
            self.failUnless(numpy.array_equal(expected_data, new_data))
            del new_data

            #column test
            org_data = self.fetch_re.data_array[..., 1, :]
            fake_data = numpy.arange(org_data.size, dtype=org_data.dtype)
            fake_data.shape = org_data.shape
            self.fetch_re.data_array[..., 1, :] = fake_data
            expected_data = numpy.arange(0,
                                         org_data.size,
                                         org_data.shape[2],
                                         dtype=org_data.dtype)
            del org_data
            new_data = self.fetch_re.data_array[..., 1, 0]
            expected_data.shape = new_data.shape
            self.failUnless(numpy.array_equal(expected_data, new_data))
            del new_data

            #band test
            org_data = self.fetch_re.data_array[..., 1]
            fake_data = numpy.arange(org_data.size, dtype=org_data.dtype)
            fake_data.shape = org_data.shape
            self.fetch_re.data_array[..., 1] = fake_data
            expected_data = numpy.arange(org_data.shape[1],
                                         org_data.shape[1] * 2,
                                         dtype=org_data.dtype)
            del org_data
            new_data = self.fetch_re.data_array[1, ..., 1]
            expected_data.shape = new_data.shape
            self.failUnless(numpy.array_equal(expected_data, new_data))
            del new_data

        def test_create_raster2d(self):
            temp = numpy.arange(10, dtype="uint16")
            temp.shape = (5, 2)

            relem = opticks.RasterElement.create2d("foo", temp)
            self.failUnless(relem is not None)
            self.failUnless(relem.rows, 5)
            self.failUnless(relem.columns, 2)
            self.failUnless(relem.bands, 1)
            self.failUnless(relem.encoding.value, opticks.Encoding.INT2UBYTES)
            relem.destroy()
            del relem

        def test_create_raster3d(self):
            temp = numpy.arange(40, dtype="uint16")
            temp.shape = (5, 2, 4)

            relem = opticks.RasterElement.create3d("foo", temp,
                                                   opticks.Interleave.BIP)
            self.failUnless(relem is not None)
            self.failUnless(relem.rows, 5)
            self.failUnless(relem.columns, 2)
            self.failUnless(relem.bands, 4)
            self.failUnless(relem.encoding.value, opticks.Encoding.INT2UBYTES)
            relem.destroy()
            del relem

            relem = opticks.RasterElement.create3d("foo", temp,
                                                   opticks.Interleave.BSQ)
            self.failUnless(relem is not None)
            self.failUnless(relem.bands, 5)
            self.failUnless(relem.rows, 2)
            self.failUnless(relem.columns, 4)
            self.failUnless(relem.encoding.value, opticks.Encoding.INT2UBYTES)
            relem.destroy()
            del relem

            relem = opticks.RasterElement.create3d("foo", temp,
                                                   opticks.Interleave.BIL)
            self.failUnless(relem is not None)
            self.failUnless(relem.rows, 5)
            self.failUnless(relem.bands, 2)
            self.failUnless(relem.columns, 4)
            self.failUnless(relem.encoding.value, opticks.Encoding.INT2UBYTES)
            relem.destroy()
            del relem

        def test_create_raster3d_from_block(self):
            temp = numpy.arange(40, dtype="uint16")
            temp.shape = (5, 2, 4)
            temp_block = temp.view(type=opticks.RasterBlock)
            temp_block.interleave = opticks.Interleave(opticks.Interleave.BIL)

            relem = opticks.RasterElement.create3d("foo", temp_block)
            self.failUnless(relem is not None)
            self.failUnless(relem.rows, 5)
            self.failUnless(relem.bands, 2)
            self.failUnless(relem.columns, 4)
            self.failUnless(relem.encoding.value, opticks.Encoding.INT2UBYTES)
            relem.destroy()
            del relem

            relem = opticks.RasterElement.create3d("foo", temp_block,
                                                   opticks.Interleave.BIP)
            self.failUnless(relem is not None)
            #temp_block takes precedence
            self.failUnless(relem.interleave.value, opticks.Interleave.BIL)
            self.failUnless(relem.rows, 5)
            self.failUnless(relem.bands, 2)
            self.failUnless(relem.columns, 4)
            self.failUnless(relem.encoding.value, opticks.Encoding.INT2UBYTES)
            relem.destroy()
            del relem

except ImportError:
    class RasterNumpyTestCase(unittest.TestCase):
        #pylint: disable=R0201
        def test_numpy_available(self):
            print "NumPy tests could not be run because " \
                  "numpy could not be imported"

class SignatureTestCase(unittest.TestCase):
    def setUp(self):
        self.sig = opticks.Signature.create("Test Signature")

    def tearDown(self):
        self.sig.destroy()
        self.sig = None

    def test_signature(self):
        self.failUnless(self.sig is not None)
        self.sig['foo'] = 42.0
        self.sig['bar'] = 1.23
        self.failUnlessAlmostEqual(self.sig['foo'].value, 42.0)
        self.failUnlessAlmostEqual(self.sig['bar'].value, 1.23)
        self.failUnlessEqual(self.sig.keys(), ['bar','foo'])

class TypesTestCase(unittest.TestCase):
    def setUp(self):
        self.failUnless(load_test_file("ir_bushehr_06jun02_ps.tif"))
        self.data_el = opticks.DataElement("ir_bushehr_06jun02_ps.tif")

    def tearDown(self):
        self.data_el.destroy()
        self.data_el = None

    def test_get_element(self):
        self.failUnless(self.data_el)

    def test_cast_element(self):
        self.failUnless(self.data_el.cast_data_element("RasterElement"))

    def test_properties(self):
        import os.path
        self.failUnless(self.data_el.name.endswith("ir_bushehr_06jun02_ps.tif"))
        self.failUnlessEqual(self.data_el.type, "RasterElement")
        self.failUnlessEqual(os.path.basename(self.data_el.filename),
                             "ir_bushehr_06jun02_ps.tif")
        self.failUnlessEqual(len(self.data_el.children), 1)
        self.failUnlessEqual(self.data_el.children[0].name,
                             "Corner Coordinates")
        self.failUnlessEqual(self.data_el.children[0].type, "GcpList")

class LayerTestCase(unittest.TestCase):
    def setUp(self):
        self.failUnless(load_test_file("ir_bushehr_06jun02_ps.tif"))

    def tearDown(self):
        opticks.View().destroy()

    def test_layer_access(self):
        rlayer = opticks.Layer(typ="RasterLayer")
        self.failUnless(rlayer)
        self.failUnless(rlayer.name.endswith("ir_bushehr_06jun02_ps.tif"))
        glayer = opticks.Layer()
        self.failUnless(glayer)
        self.failUnlessEqual(glayer.name, "Corner Coordinates")
        rlayer = opticks.Layer("|ir_bushehr_06jun02_ps.tif")
        self.failUnless(rlayer)
        self.failUnless(rlayer.name.endswith("ir_bushehr_06jun02_ps.tif"))
        layer_match = "ir_bushehr_06jun02_ps.tif|ir_bushehr_06jun02_ps.tif"
        rlayer = opticks.Layer(layer_match)
        self.failUnless(rlayer)
        self.failUnless(rlayer.name.endswith("ir_bushehr_06jun02_ps.tif"))
        self.failUnlessRaises(opticks.SimpleApiError, opticks.Layer,
                              layer_match, "BadType")
        rlayer = opticks.Layer(layer_match, "RasterLayer")
        self.failUnless(rlayer)
        self.failUnless(rlayer.name.endswith("ir_bushehr_06jun02_ps.tif"))
        glayer = opticks.Layer("ir_bushehr_06jun02_ps.tif|Corner Coordinates",
                               "GcpLayer")
        self.failUnless(glayer)
        self.failUnlessEqual(glayer.name, "Corner Coordinates")
        self.failUnlessEqual(glayer.element.name, "Corner Coordinates")
        self.failUnless(glayer.view)

    def test_scale_offset(self):
        glayer = opticks.Layer("|Corner Coordinates")
        self.failUnlessEqual(glayer.scale, (1.0, 1.0))
        self.failUnlessEqual(glayer.offset, (0.0, 0.0))
        glayer.scale = 0.5, 0.25
        glayer.offset = 100, 200
        self.failUnlessEqual(glayer.scale, (0.5, 0.25))
        self.failUnlessEqual(glayer.offset, (100.0, 200.0))

    def test_displayed(self):
        glayer = opticks.Layer("|Corner Coordinates")
        self.failUnless(glayer.displayed)
        glayer.displayed = False
        glayer.displayed = False # ensure an exception is not thrown
        self.failIf(glayer.displayed)
        glayer.displayed = True
        self.failUnless(glayer.displayed)

    def test_display_index(self):
        glayer = opticks.Layer("|Corner Coordinates")
        rlayer = opticks.Layer(typ="RasterLayer")
        self.failUnlessEqual(glayer.display_index, 0)
        self.failUnlessEqual(rlayer.display_index, 1)
        glayer.display_index = 1
        self.failUnlessEqual(glayer.display_index, 1)
        self.failUnlessEqual(rlayer.display_index, 0)

    def test_conversion(self):
        rlayer = opticks.Layer(typ="RasterLayer")
        rlayer.derive(typ="ThresholdLayer")
        tlayer = opticks.Layer(typ="ThresholdLayer")
        self.failUnlessEqual(tlayer.type, "ThresholdLayer")
        tlayer = opticks.Layer.convert(tlayer, "PseudocolorLayer")
        self.failUnlessEqual(tlayer.type, "PseudocolorLayer")

    def test_threshold_layer(self):
        rlayer = opticks.Layer(typ="RasterLayer")
        rlayer.derive(typ="ThresholdLayer")
        tlayer = opticks.Layer(typ="ThresholdLayer")
        tlayer.pass_area = opticks.PassArea.OUTSIDE
        self.failUnlessEqual(tlayer.pass_area, opticks.PassArea.OUTSIDE)
        tlayer.thresholds = 10, 15
        self.failUnlessEqual(tlayer.thresholds, (10.0, 15.0))
        tlayer.regionunits = opticks.RegionUnits.STD_DEV
        self.failUnlessEqual(tlayer.regionunits, opticks.RegionUnits.STD_DEV)

    def test_colormap(self):
        rlayer = opticks.RasterLayer()
        self.failUnlessEqual(rlayer.colormap_name, "Default Grayscale")
        rlayer.colormap_name = 'StopLight'
        self.failUnlessEqual(rlayer.colormap_name, "Stop Light")
        rlayer.colormap_name = 'RedTemp'
        self.failUnlessEqual(rlayer.colormap_name, "RedTemp")
        rlayer.colormap_name = 'WeatherMap.clu'
        self.failUnlessEqual(rlayer.colormap_name, "WeatherMap")
        rlayer.colormap_name = 'Hot Iron'
        self.failUnlessEqual(rlayer.colormap_name, "Hot Iron")
        try:
            rlayer.colormap_name = "foo"
            self.fail('Setting colormap_name to "foo" did not fail as expected')
        except opticks.SimpleApiError:
            pass
        cscale = zip(xrange(256), xrange(256), (0,) * 256)
        rlayer.set_colormap(cscale, "Yellow")
        self.failUnlessEqual(map(opticks.Color, cscale), rlayer.colormap)
        self.failUnlessEqual(rlayer.colormap_name, "Yellow")
        cscale.reverse()
        rlayer.colormap = cscale
        self.failUnlessEqual(map(opticks.Color, cscale), rlayer.colormap)
        self.failUnlessEqual(rlayer.colormap_name, "")

    def test_statistics(self):
        rlayer = opticks.RasterLayer()
        stat = rlayer.get_statistics(opticks.RasterChannel.GRAY)
        self.failUnlessAlmostEqual(stat.min, 8.0)
        self.failUnlessAlmostEqual(stat.max, 2047.0)
        self.failUnlessAlmostEqual(stat.mean, 1127.29884817)
        self.failUnlessAlmostEqual(stat.std_dev, 428.13824196)
        self.failUnlessEqual(stat.resolution, 1)
        self.failUnlessEqual(len(stat.histogram_centers), 256)
        self.failUnlessEqual(len(stat.histogram_counts), 256)
        self.failUnlessEqual(len(stat.percentiles), 1001)

    def test_display_mode(self):
        rlayer = opticks.RasterLayer()
        rlayer.rgb_displayed = True
        self.failUnlessEqual(rlayer.rgb_displayed, True)
        rlayer.rgb_displayed = False
        self.failUnlessEqual(rlayer.rgb_displayed, False)

    def test_display_band(self):
        rlayer = opticks.RasterLayer()
        rlayer.set_displayed_band(opticks.RasterChannel.GRAY, 1)
        (bandnum, raster) = \
            rlayer.get_displayed_band(opticks.RasterChannel.GRAY)
        self.failUnlessEqual(bandnum, 1)
        self.failUnlessEqual(raster.name, rlayer.element.name)
        self.failUnlessEqual(raster.handle, rlayer.element.handle)

        rlayer.set_displayed_band(opticks.RasterChannel.GRAY,
                                  1000) #bandnum intentionally out-of-range
        (bandnum, raster) = \
            rlayer.get_displayed_band(opticks.RasterChannel.GRAY)
        self.failUnlessEqual(bandnum, 0)
        self.failUnlessEqual(raster, None)

        rlayer.set_displayed_band(opticks.RasterChannel.GRAY, 1, rlayer.element)
        (bandnum, raster) = \
            rlayer.get_displayed_band(opticks.RasterChannel.GRAY)
        self.failUnlessEqual(bandnum, 1)
        self.failUnlessEqual(raster.name, rlayer.element.name)
        self.failUnlessEqual(raster.handle, rlayer.element.handle)

        rlayer.set_rgb_bands(red=0, green=1, blue=2)
        (rednum, red) = rlayer.get_displayed_band(opticks.RasterChannel.RED)
        (greennum, green) = \
            rlayer.get_displayed_band(opticks.RasterChannel.GREEN)
        (bluenum, blue) = rlayer.get_displayed_band(opticks.RasterChannel.BLUE)
        self.failUnlessEqual(rlayer.rgb_displayed, True)
        self.failUnlessEqual(rednum, 0)
        self.failUnlessEqual(greennum, 1)
        self.failUnlessEqual(bluenum, 2)
        self.failUnlessEqual(red.handle, rlayer.element.handle)
        self.failUnlessEqual(green.handle, rlayer.element.handle)
        self.failUnlessEqual(blue.handle, rlayer.element.handle)

        rlayer.set_gray_band(2)
        (graynum, gray) = rlayer.get_displayed_band(opticks.RasterChannel.GRAY)
        self.failUnlessEqual(rlayer.rgb_displayed, False)
        self.failUnlessEqual(graynum, 2)
        self.failUnlessEqual(gray.handle, rlayer.element.handle)

class ViewTestCase(unittest.TestCase):
    def setUp(self):
        self.failUnless(load_test_file("ir_bushehr_06jun02_ps.tif"))
        self.view = opticks.View()

    def tearDown(self):
        self.view.destroy()
        self.view = None

    def test_view_properties(self):
        self.failUnlessEqual(self.view.type, "Spatial Data View")
        self.failUnless(self.view.name.endswith("ir_bushehr_06jun02_ps.tif"))
        self.view.name = "foobar"
        self.failUnlessEqual(self.view.name, "foobar")
        bush_handle = opticks.DataElement("ir_bushehr_06jun02_ps.tif").handle
        self.failUnlessEqual(self.view.primary_element.handle,
                             bush_handle)

class ViewCreateTestCase(unittest.TestCase):
    def setUp(self):
        self.failUnless(load_test_file("ir_bushehr_06jun02_ps.tif"), True)
        self.element = opticks.DataElement("ir_bushehr_06jun02_ps.tif")

    def tearDown(self):
        self.element.destroy()
        self.element = None

    def test_view_create(self):
        self.failUnless(opticks.View.create("foobar",
                                            element=self.element))
