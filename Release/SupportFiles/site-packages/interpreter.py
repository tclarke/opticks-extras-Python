"""Python side interactive interpreter support"""
from code import InteractiveInterpreter
import sys
from StringIO import StringIO

__copyright__ = """ The information in this file is
 Copyright(c) 2009 Ball Aerospace & Technologies Corporation
 and is subject to the terms and conditions of the
 GNU Lesser General Public License Version 2.1
 The license text is available from
 http://www.gnu.org/licenses/lgpl.html"""

class StrBufStream:
    def __init__(self):
        self.__buf = ""

    def available(self):
        if self.__buf:
            return len(self.__buf)
        return 0

    def close(self):
        self.__buf = None

    def read(self, count):
        buf = ""
        if count >= len(self.__buf):
            buf, self.__buf = self.__buf,""
        else:
            buf, self.__buf = self.__buf[:count], self.__buf[count:]
        return buf

    def write(self, buf, count=None):
        if count is None:
            count = len(buf)
        if len(buf) <= count:
            self.__buf += buf
            return len(buf)
        self.__buf += buf[:count]
        return count

def get_real_stdout():
    buf = sys.stdout.getvalue()
    sys.stdout.truncate(0)
    return buf

def get_real_stderr():
    buf = sys.stderr.getvalue()
    sys.stderr.truncate(0)
    return buf

class PythonInteractiveInterpreter(InteractiveInterpreter):
    def __init__(self):
        self.stdin, self.stdout, self.stderr = None, None, None
        self.buf = []
        sys.stdout = StringIO()
        sys.stderr = StringIO()
        InteractiveInterpreter.__init__(self)
        sys.ps1 = ""
        sys.ps2 = ""
        self.more = False

    def push(self, line):
        self.buf.append(line)
        source = "\n".join(self.buf)
        more = self.runsource(source)
        if not more:
            self.buf = []
        return more

    def process_event(self):
        """ Process input and return True if input is complete or incorrect;
            False if input is correct but incomplete
        """
        out = get_real_stdout()
        if out and self.stdout:
            self.stdout.write(out, len(out)) # flush stdout
        err = get_real_stderr()
        if err and self.stderr:
            self.stderr.write(err, len(err)) # flush stderr
        if not self.stdin:
            return True # invalid stdin

        line = self.stdin.read(self.stdin.available())

        self.more = self.push(line)
        out = get_real_stdout()
        if out and self.stdout:
            self.stdout.write(out, len(out)) # flush stdout
        err = get_real_stderr()
        if err and self.stderr:
            self.stderr.write(err, len(err)) # flush stderr
        return not(self.more)
