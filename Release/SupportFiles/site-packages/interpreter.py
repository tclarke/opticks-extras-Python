from code import InteractiveInterpreter
import sys
from StringIO import StringIO

__copyright__ = """ The information in this file is
 Copyright(c) 2009 Ball Aerospace & Technologies Corporation
 and is subject to the terms and conditions of the
 GNU Lesser General Public License Version 2.1
 The license text is available from   
 http://www.gnu.org/licenses/lgpl.html"""
__doc__ = """Python side interactive interpreter support"""

class StrBufStream:
   def __init__(self):
      self.__buf = ""

   def available(self):
      if self.__buf:
         return len(self.__buf)
      return 0

   def close(self):
      self.__buf = None

   def read(self, count):
      buf = ""
      if count >= len(self.__buf):
         buf,self.__buf = self.__buf,""
      else:
         buf,self.__buf = self.__buf[:count],self.__buf[count:]
      return buf

   def isNonBlocking(self):
      return True

   def write(self, buf, count=None):
      if count is None: count = len(buf)
      if len(buf) <= count:
         self.__buf += buf
         return len(buf)
      self.__buf += buf[:count]
      return count

class PythonInteractiveInterpreter(InteractiveInterpreter):
   def __init__(self):
      self.stdin,self.stdout,self.stderr = None,None,None
      self.buf = [] 
      sys.stdout = StringIO()
      sys.stderr = StringIO()
      InteractiveInterpreter.__init__(self)
      sys.ps1 = ""
      sys.ps2 = ""
      self.more = False 

   def getRealStdout(self):
      buf = sys.stdout.getvalue()
      sys.stdout.truncate(0)
      return buf

   def getRealStderr(self):
      buf = sys.stderr.getvalue()
      sys.stderr.truncate(0)
      return buf
      
   def push(self, line):
      self.buf.append(line)
      source = "\n".join(self.buf)
      more = self.runsource(source)
      if not more:
         self.buf = []
      return more 

   def processEvent(self):
      """ Process input and return True if input is complete or incorrect;
          False if input is correct but incomplete
      """
      out = self.getRealStdout()
      if out and self.stdout: self.stdout.write(out, len(out)) # flush stdout
      err = self.getRealStderr()
      if err and self.stderr: self.stderr.write(err, len(err)) # flush stderr
      if not self.stdin: return True # invalid stdin

      line = self.stdin.read(self.stdin.available())

      self.more = self.push(line)
      out = self.getRealStdout()
      if out and self.stdout: self.stdout.write(out, len(out)) # flush stdout
      err = self.getRealStderr()
      if err and self.stderr: self.stderr.write(err, len(err)) # flush stderr
      return not(self.more)

