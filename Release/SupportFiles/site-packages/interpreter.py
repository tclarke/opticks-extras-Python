from code import InteractiveInterpreter
import sys
from StringIO import StringIO

__doc__ = """Python side interactive interpreter support"""

class StrBufStream:
   def __init__(self):
      self.__buf = ""

   def available(self):
      if self.__buf:
         return len(self.__buf)
      return 0

   def close(self):
      self.__buf = None

   def read(self, count):
      buf = ""
      if count >= len(self.__buf):
         buf,self.__buf = self.__buf,""
      else:
         buf,self.__buf = self.__buf[:count],self.__buf[count:]
      return buf

   def isNonBlocking(self):
      return True

   def write(self, buf, count=None):
      if count is None: count = len(buf)
      if len(buf) <= count:
         self.__buf += buf
         return len(buf)
      self.__buf += buf[:count]
      return count

class PythonInteractiveInterpreter(InteractiveInterpreter):
   def __init__(self):
      self.stdin,self.stdout,self.stderr = None,None,None
      self.buf = ""
      sys.stdout = StringIO()
      InteractiveInterpreter.__init__(self)
      sys.ps1 = ""
      sys.ps2 = ""

   def getRealStdout(self):
      buf = sys.stdout.getvalue()
      sys.stdout.truncate(0)
      return buf

   def processEvent(self):
      """ Process input and return True if input is complete or incorrect;
          False if input is correct but incomplete
      """
      out = self.getRealStdout()
      if out and self.stdout: self.stdout.write(out, len(out)) # flush stdout
      if not self.stdin: return True # invalid stdin

      buf = self.stdin.read(self.stdin.available())
      inMultiline = self.buf and buf != "\n" # pending input and new input added
      buf = self.buf + buf
      if buf:
         if self.runsource(buf) or inMultiline:
            # Input is correct but incomplete, store the input and prompt with ps2
            self.buf = buf
            out = self.getRealStdout()
            if out and self.stdout: self.stdout.write(out, len (out)) # flush stdout
            if self.stdout: self.stdout.write(sys.ps2, len(sys.ps2))  # prompt
         else:
            # Input is complete or incorrect, clear the input buffer and prompt with ps1
            self.buf = ""
            out = self.getRealStdout()
            if out and self.stdout: self.stdout.write(out, len(out)) # flush stdout
            if self.stdout: self.stdout.write(sys.ps1, len(sys.ps1)) # prompt
            return True
      elif self.buf and self.stdout:
         # Empty input but there is pending input, prompt with ps2
         self.stdout.write(sys.ps2, len(sys.ps2))
      elif self.stdout:
         # Empty input and no pending input, prompt with ps1
         self.stdout.write(sys.ps1, len(sys.ps1))
      return False

   def write(self, data):
      if self.stderr:
         data = str(data)
         self.stderr.write(data, len(data))
