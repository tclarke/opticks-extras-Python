"""Python side interactive interpreter support"""
from code import InteractiveInterpreter
import sys
import StringIO
import _opticks
import ctypes
import tokenize
import token

__copyright__ = """ The information in this file is
 Copyright(c) 2009 Ball Aerospace & Technologies Corporation
 and is subject to the terms and conditions of the
 GNU Lesser General Public License Version 2.1
 The license text is available from
 http://www.gnu.org/licenses/lgpl.html"""

class StrBufStream:
    def __init__(self):
        self.__buf = ""

    def available(self):
        if self.__buf:
            return len(self.__buf)
        return 0

    def close(self):
        self.__buf = None

    def read(self, count):
        buf = ""
        if count >= len(self.__buf):
            buf, self.__buf = self.__buf,""
        else:
            buf, self.__buf = self.__buf[:count], self.__buf[count:]
        return buf

    def write(self, buf, count=None):
        if count is None:
            count = len(buf)
        if len(buf) <= count:
            self.__buf += buf
            return len(buf)
        self.__buf += buf[:count]
        return count

_send_output = None

class CustomStringIO(StringIO.StringIO):
    def __init__(self, error_stream):
        StringIO.StringIO.__init__(self)
        self.is_error_stream = error_stream

    def write(self, s):
        StringIO.StringIO.write(self, s)
        self.seek(0)
        text = self.read()
        self.truncate(0)
        _send_output(text, len(text), self.is_error_stream)

def connect_io():
    global _send_output
    pyobj = ctypes.py_object(_send_output_c_func_pointer)
    send_out_vp = ctypes.pythonapi.PyCObject_AsVoidPtr(pyobj)
    _send_output = ctypes.CFUNCTYPE(None, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32)(send_out_vp)
    sys.stdout = CustomStringIO(0)
    sys.stderr = CustomStringIO(1)

class PythonInteractiveInterpreter(InteractiveInterpreter):
    def __init__(self, localAndGlobalDict):
        self.stdin = None
        self.buf = ""
        InteractiveInterpreter.__init__(self, localAndGlobalDict)
        sys.ps1 = ""
        sys.ps2 = ""
        self.more = False

    def push(self, line):
        if len(self.buf) > 0:
            self.buf += "\n"
        self.buf += line
        more = self.runsource(self.buf)
        if not more:
            self.buf = ""
        return more

    def process_event(self):
        """ Process input and return True if input is complete or incorrect;
            False if input is correct but incomplete
        """
        if not self.stdin:
            return True # invalid stdin
        line = self.stdin.read(self.stdin.available())
        lines = line.split("\n")
        for the_line in lines:
            self.more = self.push(the_line)
        if self.more and line.count("\n") >= 1:
            tempStr = StringIO.StringIO(line)
            space_count = 0
            token_iter = tokenize.generate_tokens(tempStr.readline)
            val = token_iter.next()
            if (val[0] == tokenize.INDENT):
                space_count = val[3][1]
            #add two lines with space equal to the indent level and re-run command
            #the reason for two lines is to terminate a line continuation and
            #a block
            self.more = self.push(" " * space_count + "\n" + " " * space_count)
        return not(self.more)
