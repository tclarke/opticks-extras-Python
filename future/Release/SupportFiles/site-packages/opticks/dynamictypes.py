from ctypes import *
from .utils import genwrap, stringBufferWrap
import data
import _opticks

__doc__ = "Functions to work with Opticks dynamic types."

####
# Utility functions
####
def void_pToNative(typename, value):
   typ = None
   isvector = False
   if typename.startswith("vector<"):
      typename = typename[7:-1]
      isvector = True
   if typename == "char": typ = c_byte
   elif typename == "unsigned char": typ = c_ubyte
   elif typename == "short": typ = c_short
   elif typename == "unsigned short": typ = c_ushort
   elif typename == "int": typ = c_int
   elif typename == "unsigned int": typ = c_uint
   elif typename == "long": typ = c_long
   elif typename == "unsigned long": typ = c_ulong
   elif typename == "Int64" or typename == "int64": typ = c_longlong
   elif typename == "UInt64" or typename == "uint64": typ = c_ulonglong
   elif typename == "float": typ = c_float
   elif typename == "double": typ = c_double
   else: return cast(value, c_void_p)
   if isvector:
      rval = c_void_p(0)
      sz = _vectorToArray(value, "vector<%s>" % typename, byref(rval))
      sz /= sizeof(typ)
      typ = typ * sz
      return cast(rval, POINTER(typ)).contents
   return cast(value, POINTER(typ)).contents.value

def _prepForSet(value, typ):
   if isinstance(value, (DataVariant, c_void_p)):
      return value
   elif isinstance(value, data.types.DataElement):
      rval = value.castDataElement(typ)
      if rval == 0:
         return None
      return c_void_p(rval)
   elif typ == "char":
      return cast(pointer(c_byte(value)), c_void_p)
   elif typ == "short":
      return cast(pointer(c_short(value)), c_void_p)
   elif typ == "int":
      return cast(pointer(c_int(value)), c_void_p)
   elif typ == "long":
      return cast(pointer(c_long(value)), c_void_p)
   elif typ == "Int64":
      return cast(pointer(c_longlong(value)), c_void_p)
   elif typ == "unsigned char":
      return cast(pointer(c_ubyte(value)), c_void_p)
   elif typ == "unsigned short":
      return cast(pointer(c_ushort(value)), c_void_p)
   elif typ == "unsigned int":
      return cast(pointer(c_uint(value)), c_void_p)
   elif typ == "unsigned long":
      return cast(pointer(c_ulong(value)), c_void_p)
   elif typ == "UInt64":
      return cast(pointer(c_ulonglong(value)), c_void_p)
   elif typ == "float":
      return cast(pointer(c_float(value)), c_void_p)
   elif typ == "double":
      return cast(pointer(c_double(value)), c_void_p)
   else: # try an XML string conversion
      return createDataVariantFromString(typ, str(value), 1)
   return None

####
# Data types
####
class DataVariant(Structure):
   _fields_ = [("handle", c_void_p)]
   __owns = False

   def __init__(self, value=None, vtype=None, xml=True):
      if isinstance(value, DataVariant):
         self.handle, self.__owns = value.handle, False
         return
      self.__owns = True
      import types
      if vtype is not None and not isinstance(value, c_void_p):
         self.handle = createDataVariantFromString(str(vtype), str(value), xml).handle
         return
      if vtype is None and value is not None:
         vtype = None
         if type(value) == types.StringType:
            self.handle = createDataVariantFromString("string", str(value), 1).handle
            return
         elif type(value) == types.IntType or type(value) == types.LongType:
            if value < 0:
               if value > -(2**(sizeof(c_byte)*8)/2):
                  vtype, value = "char", pointer(c_byte(value))
               elif value > -(2**(sizeof(c_short)*8)/2):
                  vtype, value = "short", pointer(c_short(value))
               elif value > -(2**(sizeof(c_int)*8)/2):
                  vtype, value = "int", pointer(c_int(value))
               elif value > -(2**(sizeof(c_long)*8)/2):
                  vtype, value = "long", pointer(c_long(value))
               elif value > -(2**(sizeof(c_longlong)*8)/2):
                  vtype, value = "Int64", pointer(c_longlong(value))
            else:
               if value < 2**(sizeof(c_ubyte)*8):
                  vtype, value = "unsigned char", pointer(c_ubyte(value))
               elif value < 2**(sizeof(c_ushort)*8):
                  vtype, value = "unsigned short", pointer(c_ushort(value))
               elif value < 2**(sizeof(c_uint)*8):
                  vtype, value = "unsigned int", pointer(c_uint(value))
               elif value < 2**(sizeof(c_ulong)*8):
                  vtype, value = "unsigned long", pointer(c_ulong(value))
               elif value < 2**(sizeof(c_ulonglong)*8):
                  vtype, value = "UInt64", pointer(c_ulonglong(value))
         elif type(value) == types.FloatType:
            vtype, value = "float", pointer(c_float(value))
         else:
            raise _opticks.error("Can't automatically convert %s." % str(type(value)))
      self.handle = createDataVariant(vtype, value).handle

   def __del__(self):
      if self.__owns:
         freeDataVariant(self)

   def __repr__(self):
      if not self.valid:
         return "<DataVariant: invalid>"
      return "<DataVariant: '%s' type: '%s'>" % (self.xml, self.dvtype)
   
   @property
   def display(self):
      if not self.valid:
         return None
      return stringBufferWrap(getDataVariantValueString, self, 0)
   
   @property
   def xml(self):
      if not self.valid:
         return None
      return stringBufferWrap(getDataVariantValueString, self, 1)

   @property
   def valid(self):
      return bool(isDataVariantValid(self))

   @property
   def dvtype(self):
      if not self.valid:
         return ""
      buf = create_string_buffer(32)
      getDataVariantTypeName(self, buf, 32)
      return string_at(buf)

   @property
   def value(self):
      if self.dvtype == "string": # special case..can't handle std::string
         return self.xml
      return void_pToNative(self.dvtype, getDataVariantValue(self))

class PlugInArgList(Structure):
   _fields_ = [("handle", c_void_p)]
   __owns = False

   def __del__(self):
      if self.__owns:
         freePlugInArgList(self)

   def __repr__(self):
      return "PlugInArgList(%i)" % self.handle.value

   def __len__(self):
      return getPlugInArgCount(self)

   def __getitem__(self, key):
      from types import IntType
      if type(key) == IntType:
         return getPlugInArgByIndex(self, key)
      return getPlugInArgByName(self, key)

   def keys(self):
      rval = []
      for idx in range(len(self)):
         rval.append(stringBufferWrap(getPlugInArgName, getPlugInArgByIndex(self, idx)))
      return rval

class PlugInArg(Structure):
   _fields_ = [("handle", c_void_p)]
   __owns = False

   def __repr__(self):
      return "PlugInArg(%i)" % self.handle

   @property
   def name(self):
      return stringBufferWrap(getPlugInArgName, self)

   @property
   def type(self):
      return stringBufferWrap(getPlugInArgTypeName, self)

   @property
   def description(self):
      return stringBufferWrap(getPlugInArgDescription, self)

   def isDefaultSet(self):
      return bool(isPlugInArgDefaultSet(self))

   def isActualSet(self):
      return bool(isPlugInArgActualSet(self))

   @property
   def value(self):
      return void_pToNative(self.type, getPlugInArgValue(self))

   def getdefault(self):
      if not self.isDefaultSet():
         raise _opticks.error("Default value is not set.")
      return void_pToNative(self.type, getPlugInArgDefaultValue(self))

   def setdefault(self, value):
      value = _prepForSet(value, self.type)
      if isinstance(value, DataVariant):
         setPlugInArgDefaultValueFromDataVariant(self, value)
      elif isinstance(value, c_void_p):
         setPlugInArgDefaultValueFromVoid(self, value)
      else:
         raise _opticks.error("Unable to store value.")

   # this can be changed to use .setter when we supporting only python >= 2.6
   default = property(getdefault, setdefault)

   def getactual(self):
      if not self.isActualSet():
         raise _opticks.error("Actual value is not set.")
      return void_pToNative(self.type, getPlugInArgActualValue(self))

   def setactual(self, value):
      value = _prepForSet(value, self.type)
      if isinstance(value, DataVariant):
         setPlugInArgActualValueFromDataVariant(self, value)
      elif isinstance(value, c_void_p):
         setPlugInArgActualValueFromVoid(self, value)
      else:
         raise _opticks.error("Unable to store value.")

   # this can be changed to use .setter when we supporting only python >= 2.6
   actual = property(getactual, setactual)

class WizardNode(Structure):
   _fields_ = [("handle", c_void_p)]

   @property
   def name(self):
      return stringBufferWrap(getWizardNodeName, self)

   @property
   def type(self):
      return stringBufferWrap(getWizardNodeType, self)

   def getvalue(self):
      value = void_pToNative(self.type, getWizardNodeValue(self))
      if isinstance(value, c_void_p):
         dv = DataVariant(value, self.type)
         if dv.valid:
            value = dv
      return value

   def setvalue(self, value):
      value = _prepForSet(value, self.type)
      if isinstance(value, DataVariant):
         setWizardNodeValue(self, getDataVariantValue(value))
      elif isinstance(value, c_void_p):
         setWizardNodeValue(self, value)
      else:
         raise _opticks.error("Unable to store value.")

   value = property(getvalue, setvalue)

   def __repr__(self):
      return "<WizardNode object: '%s' of type: '%s'>" % (self.name, self.type)

####
# Function prototypes
####
# DynamicTypes.h
createDataVariant = genwrap("createDataVariant", DataVariant, c_char_p, c_void_p)
createDataVariantFromString = genwrap("createDataVariantFromString", DataVariant, c_char_p, c_char_p, c_int)
freeDataVariant = genwrap("freeDataVariant", None, DataVariant)
isDataVariantValid = genwrap("isDataVariantValid", c_int, DataVariant)
getDataVariantTypeName = genwrap("getDataVariantTypeName", c_uint32, DataVariant, c_char_p, c_uint32)
getDataVariantValue = genwrap("getDataVariantValue", c_void_p, DataVariant)
getDataVariantValueString = genwrap("getDataVariantValueString", c_uint32, DataVariant, c_int, c_char_p, c_uint32)
_vectorToArray = genwrap("vectorToArray", c_uint32, c_void_p, c_char_p, POINTER(c_void_p))
freePlugInArgList = genwrap("freePlugInArgList", None, PlugInArgList)
getPlugInArgCount = genwrap("getPlugInArgCount", c_uint32, PlugInArgList)
getPlugInArgByName = genwrap("getPlugInArgByName", PlugInArg, PlugInArgList, c_char_p)
getPlugInArgByIndex = genwrap("getPlugInArgByIndex", PlugInArg, PlugInArgList, c_uint32)
getPlugInArgName = genwrap("getPlugInArgName", c_uint32, PlugInArg, c_char_p, c_uint32)
getPlugInArgTypeName = genwrap("getPlugInArgTypeName", c_uint32, PlugInArg, c_char_p, c_uint32)
getPlugInArgDescription = genwrap("getPlugInArgDescription", c_uint32, PlugInArg, c_char_p, c_uint32)
isPlugInArgDefaultSet = genwrap("isPlugInArgDefaultSet", c_int, PlugInArg)
isPlugInArgActualSet = genwrap("isPlugInArgActualSet", c_int, PlugInArg)
getPlugInArgDefaultValue = genwrap("getPlugInArgDefaultValue", c_void_p, PlugInArg)
getPlugInArgActualValue = genwrap("getPlugInArgActualValue", c_void_p, PlugInArg)
getPlugInArgValue = genwrap("getPlugInArgValue", c_void_p, PlugInArg)
setPlugInArgDefaultValueFromVoid = genwrap("setPlugInArgDefaultValueFromVoid", None, PlugInArg, c_void_p)
setPlugInArgDefaultValueFromDataVariant = genwrap("setPlugInArgDefaultValueFromDataVariant", None, PlugInArg, DataVariant)
setPlugInArgActualValueFromVoid = genwrap("setPlugInArgActualValueFromVoid", None, PlugInArg, c_void_p)
setPlugInArgActualValueFromDataVariant = genwrap("setPlugInArgActualValueFromDataVariant", None, PlugInArg, DataVariant)
getWizardNodeName = genwrap("getWizardNodeName", c_uint32, WizardNode, c_char_p, c_uint32)
getWizardNodeType = genwrap("getWizardNodeType", c_uint32, WizardNode, c_char_p, c_uint32)
getWizardNodeValue = genwrap("getWizardNodeValue", c_void_p, WizardNode)
setWizardNodeValue = genwrap("setWizardNodeValue", c_int, WizardNode, c_void_p)

####
# Test suite
####
import unittest
class DataVariantTestCase(unittest.TestCase):
   def _stringTest(self, typ, val):
      d = DataVariant(val, typ)
      self.failUnless(d.valid)
      self.failUnlessEqual(d.xml, val)

   def _valTest(self, typ, val):
      d = DataVariant(val)
      self.failUnless(d.valid)
      self.failUnlessEqual(d.dvtype, typ)
      if typ == "float" or typ == "double":
         self.failUnlessAlmostEqual(d.value, val)
      else:
         self.failUnlessEqual(d.value, val)

   def testCreateFromString(self):
      import sys
      self._stringTest("DateTime", "2009-01-02T15:30:10Z")
      if sys.platform == "win32":
         self._stringTest("Filename", "file:///C:/this/is/a/path.ext")
      else:
         self._stringTest("Filename", "file:///this/is/a/path.ext")
      self._stringTest("char", "-2")
      self._stringTest("unsigned char", "2")
      self._stringTest("short", "-300")
      self._stringTest("unsigned short", "300")
      self._stringTest("int", "-40000")
      self._stringTest("unsigned int", "40000")
      self._stringTest("Int64", "-1000000000000")
      self._stringTest("UInt64", "1000000000000")
      self._stringTest("float", "1.2345")
      self._stringTest("double", "1.23456785830939")
      self._stringTest("bool", "true")
      self._stringTest("string", "this is a string")
      self._stringTest("ColorType", "#11223355")
      self._stringTest("ColorType", "InvalidColor")
      self._stringTest("LocationType", "42.0049 -60.1234567891")
      # not going to test every enum type, just a few reprsentatives
      self._stringTest("AnimationCycle", "play_once")
      self._stringTest("ComplexComponent", "Phase")
      self._stringTest("ProcessingLocation", "onDiskReadOnly")

   def testCreateFromPythonValue(self):
      self._valTest("string", "this is a string")
      self._valTest("char", -2)
      self._valTest("short", -300)
      self._valTest("int", -40000)
      self._valTest("Int64", -10000000000)
      self._valTest("unsigned char", 200)
      self._valTest("unsigned short", 32000)
      self._valTest("unsigned int", 3000000000)
      self._valTest("UInt64", 100000000000)
      self._valTest("float", 1.23)

   def testPositiveErrors(self):
      import errors
      self.failUnlessRaises(errors.SimpleApiError, DataVariant, "bad value", "int")
      self.failUnlessRaises(errors.SimpleApiError, DataVariant, "9999", "char")
      self.failIf(DataVariant().valid)
      val=1.23456789012345678
      d=DataVariant(val)
      self.failUnless(d.valid)
      self.failUnlessEqual(d.dvtype, "float")
      self.failIfEqual(d.value, val)

class PlugInArgTestCase(unittest.TestCase):
   def setUp(self):
      from . import execute
      self.p = execute.PlugIn("Passthrough PlugIn")
   
   def tearDown(self):
      del self.p

   def testValues(self):
      pial = self.p.inArgList
      self.failUnlessEqual(len(pial), 1)
      self.failUnlessEqual(pial.keys()[0], 'Input Integer')
      self.failUnlessEqual(pial[0].name, pial['Input Integer'].name)
      self.failUnlessEqual(pial[0].type, 'unsigned int')
      self.failUnless(pial[0].isDefaultSet())
      self.failIf(pial[0].isActualSet())
      self.failUnlessEqual(pial[0].default, 10)

   def testSet(self):
      pial = self.p.inArgList
      self.failUnlessEqual(pial[0].value, pial[0].default)
      pial[0].actual = 42
      self.failUnless(pial[0].isActualSet())
      self.failUnlessEqual(pial[0].value, pial[0].actual)
      self.failUnlessEqual(pial[0].value, 42)
