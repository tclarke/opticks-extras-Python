from ctypes import *
from .utils import genwrap, stringBufferWrap
import data, dynamictypes

__doc__ = "Functions to manipulate metadata."

####
# Data types
####
class DynamicObject(Structure):
   _fields_ = [("handle", c_void_p)]
   __owns = False

   def __init__(self, element=None, wrapper=None):
      if element is None and wrapper is None:
         self.handle, self.__owns = createDynamicObject().handle, True
      elif wrapper is None:
         self.handle, self.__owns = getDataElementMetadata(element).handle, False
      else:
         self.handle, self.__owns = wrapper, False

   def __del__(self):
      if self.__owns:
         freeDynamicObject(self)

   def clear(self):
      clearMetadata(self)

   def __len__(self):
      return getMetadataAttributeCount(self)

   def __getitem__(self, key):
      val = dynamictypes.DataVariant(getMetadataAttributeByPath(self, key))
      if not val.valid:
         raise KeyError("'DynamicObject' has no attribute '%s'" % key)
      elif val.dvtype == 'DynamicObject':
         val = DynamicObject(wrapper=cast(val.value, c_void_p))
      return val

   def __setitem__(self, key, value):
      if isinstance(value, DynamicObject):
         value = dynamictypes.DataVariant(cast(self, c_void_p), "DynamicObject")
      elif not isinstance(value, dynamictypes.DataVariant):
         value = dynamictypes.DataVariant(value)
      if not value.valid:
         raise ValueError("Invalid 'DataVariant' value.")
      setMetadataAttributeByPath(self, key, value)

   def __delitem__(self, key):
      try:
         removeMetadataAttributeByPath(self, key)
      except:
         return object.__delitem__(self, key)

   def __getattr__(self, name):
      if name == '__members__':
         rval = []
         for idx in range(len(self)):
            rval.append(stringBufferWrap(getMetadataAttributeName, self, idx))
         return rval
      val = dynamictypes.DataVariant(getMetadataAttribute(self, name))
      if not val.valid:
         raise AttributeError("'DynamicObject' has no attribute '%s'" % name)
      elif val.dvtype == 'DynamicObject':
         val = DynamicObject(wrapper=cast(val.value, c_void_p))
      return val

   def __setattr__(self, name, value):
      if name.startswith('_') or name == "handle":
         return object.__setattr__(self, name, value)
      return self.__setitem__(name, value)

   def __delattr__(self, name):
      try:
         removeMetadataAttribute(self, name)
      except:
         return object.__delattr__(self, name)

   def __iter__(self):
      return self.iterkeys()

   def iterkeys(self):
      def doiter(meta, cnt):
         for idx in xrange(cnt):
            yield stringBufferWrap(getMetadataAttributeName, meta, idx)
      return doiter(self, len(self))

   def __reversed__(self):
      def doiter(meta, cnt):
         for idx in xrange(cnt-1, -1, -1):
            yield stringBufferWrap(getMetadataAttributeName, meta, idx)
      return doiter(self, len(self))

   def __str__(self):
      return "<DynamicObject with %i attribute(s)>" % len(self)

   def __repr__(self):
      return "DynamicObject(wrapper=DynamicObject(%i))" % addressof(self)

class ConfigurationSettings(object):
   def __init__(self):
      self.__defaults = None

   def __getitem__(self, key):
      import dynamictypes
      return genwrap("getConfigurationSetting", dynamictypes.DataVariant, c_char_p)(key)

   def __setitem__(self, key, value):
      import dynamictypes
      if not isinstance(value, dynamictypes.DataVariant):
         value = dynamictypes.DataVariant(value)
      genwrap("setConfigurationSetting", c_int, c_char_p, dynamictypes.DataVariant)(key, value)

   def addToDefaults(self, key):
      """Add the specified configuration setting to the defaults list which is
         maintained as a member object until serialized or cleared."""
      import metadata
      if self.__defaults is None:
         self.__defaults = metadata.DynamicObject()
      genwrap("copyConfigurationSetting", c_int, c_char_p, metadata.DynamicObject)(key, self.__defaults)

   def serializeDefaults(self, filename):
      import metadata
      if self.__defaults is None:
         raise ValueError("No configuration settings in defaults.")
      genwrap("serializeConfigurationSettingDefaults", c_int, c_char_p, metadata.DynamicObject)(filename, self.__defaults)
      self.clearDefaults()

   def clearDefaults(self):
      self.__defaults = None

####
# Function prototypes
####
createDynamicObject = genwrap("createDynamicObject", DynamicObject)
freeDynamicObject = genwrap("freeDynamicObject", None, DynamicObject, errorCheck=False)
getDataElementMetadata = genwrap("getDataElementMetadata", DynamicObject, data.types.DataElement)
getMetadataAttributeCount = genwrap("getMetadataAttributeCount", c_uint32, DynamicObject)
getMetadataAttributeName = genwrap("getMetadataAttributeName", c_uint32, DynamicObject, c_uint32, c_char_p, c_uint32)
getMetadataAttribute = genwrap("getMetadataAttribute", dynamictypes.DataVariant, DynamicObject, c_char_p)
getMetadataAttributeByPath = genwrap("getMetadataAttributeByPath", dynamictypes.DataVariant, DynamicObject, c_char_p)
setMetadataAttribute = genwrap("setMetadataAttribute", None, DynamicObject, c_char_p, dynamictypes.DataVariant)
setMetadataAttributeByPath = genwrap("setMetadataAttributeByPath", None, DynamicObject, c_char_p, dynamictypes.DataVariant)
removeMetadataAttribute = genwrap("removeMetadataAttribute", None, DynamicObject, c_char_p)
removeMetadataAttributeByPath = genwrap("removeMetadataAttributeByPath", None, DynamicObject, c_char_p)
clearMetadata  = genwrap("clearMetadata", None, DynamicObject)

####
# Test suite
####
import unittest
from .utils import loadTestFile
class DynamicObjectTestCase(unittest.TestCase):
   def setUp(self):
      self.do = DynamicObject()

   def tearDown(self):
      self.do = None

   def testDynamicObjectCreation(self):
      self.failIf(self.do is None)

   def testDynamicObjectStoreRetrieve(self):
      self.do['foo'] = 42
      self.failUnlessEqual(self.do['foo'].value, 42)

   def testConfigurationSettings(self):
      settings = ConfigurationSettings()
      self.failUnless(settings['FileLocations/ImportPath'].valid)

class MetadataTestCase(unittest.TestCase):
   def setUp(self):
      self.failUnless(loadTestFile("ir_bushehr_06jun02_ps.tif", True))
      self.de = data.types.DataElement("ir_bushehr_06jun02_ps.tif")
      self.meta = DynamicObject(self.de)
      self.meta.clear()
      self.failUnlessEqual(len(self.meta), 0)

   def tearDown(self):
      self.de.destroy()
      self.de = None

   def testBasic(self):
      self.meta['a'] = 10
      self.meta.b = 20
      self.meta['c d'] = 30
      self.failUnlessEqual(len(self.meta), 3)
      self.failUnlessEqual(self.meta.a.value, 10)
      self.failUnlessEqual(self.meta['b'].value, 20)
      self.failUnlessEqual(self.meta['c d'].value, 30)

   def testHierachical(self):
      self.meta['a/b/c'] = 10
      self.meta['a/d'] = 20
      self.failUnlessEqual(len(self.meta), 1)
      self.failUnlessEqual(len(self.meta.a), 2)
      self.failUnlessEqual(len(self.meta.a.b), 1)
      self.failUnlessEqual(self.meta.a.b.c.value, 10)
      self.failUnlessEqual(self.meta['a/b/c'].value, 10)
      self.failUnlessEqual(self.meta.a.d.value, 20)
      self.failUnlessEqual(self.meta['a/d'].value, 20)
      self.meta.clear()
      self.failUnlessEqual(len(self.meta), 0)

   def testDelete(self):
      self.meta.a = 'bcd'
      self.failUnlessEqual(len(self.meta), 1)
      self.failUnlessEqual(self.meta.a.value, 'bcd')
      del self.meta.a
      self.failUnlessEqual(len(self.meta), 0)

      self.meta['bcd'] = 'bcd'
      self.failUnlessEqual(len(self.meta), 1)
      self.failUnlessEqual(self.meta['bcd'].value, 'bcd')
      del self.meta['bcd']
      self.failUnlessEqual(len(self.meta), 0)
