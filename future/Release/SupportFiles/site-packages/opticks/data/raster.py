from ctypes import *
from ..utils import genwrap
import types,_opticks

__doc__ = "Functions and data types for dealing with RasterElements"

class DataAccessor(Structure):
   "Wrapper for an Opticks data accessor. This is the most flexible data access method but is also the most complex."
   _fields_ = [("handle", c_void_p)]

   def __del__(self):
      if self.__owns:
         genwrap("destroyDataAccessor", None, DataAccessor, errorCheck=False)(self)

   def initialize(self, *args):
      "Not user callable...this is used by RasterElement.getDataAccessor"
      # args = owns, encoding, colcount, writable
      self.__owns, self.__encoding, self.__colCount, self.__writable = args

   def getRow(self):
      "Get a ctypes pointer to the current row."
      return cast(c_void_p(self._getDataAccessorRow(self)), self.__encoding)

   def nextRow(self, count = 1, resetColumn = True):
      "Advance the data accessor count number of rows. If reset column is True, the data accessor will point to the original start column of the new row."
      self._nextDataAccessorRow(self, count, resetColumn)

   def getColumn(self):
      "Get a ctypes pointer to the current column."
      return cast(c_void_p(self._getDataAccessorColumn(self)), self.__encoding)

   def nextColumn(self, count = 1):
      "Advance the data accessor count number of columns."
      self._nextDataAccessorColumn(self, count)

   def __getitem__(self, (row, column)):
      "Access the data point at a specific (row, column)."
      self.toPixel(row, column)
      if not self.valid:
         raise _opticks.error("Location (%i, %i) is invalid." % (row, column))
      return self.getColumn().contents.value

   def __setitem__(self, (row, column), value):
      if not self.__writable:
         raise _opticks.error("Accessor is read-only")
      self.toPixel(row, column)
      if not self.valid:
         raise _opticks.error("Location (%i, %i) is invalid." % (row, column))
      self.getColumn()[0] = value

   def toPixel(self, row, column):
      self._toPixel(self, row, column)

   def iterrows(self, incr = 1):
      "Create an iterator across rows which accesses the entire row each iteration."
      def doiter(acc, inc):
         while acc.valid:
            yield acc.getRow()
            acc.nextRow(incr)
      return doiter(self, incr)

   def itercolumns(self, incr = 1):
      "Create an iteractor across columns in the current row."
      def doiter(acc, colCount, inc):
         for idx in xrange(colCount):
            yield acc.getColumn()
            acc.nextColumn(incr)
      return doiter(self, self.__colCount, incr)

   @property
   def valid(self):
      return self._valid(self)

   @property
   def rowsize(self):
      return self._rowsize(self)
DataAccessor._getDataAccessorRow = genwrap("getDataAccessorRow", c_void_p, DataAccessor)
DataAccessor._getDataAccessorColumn = genwrap("getDataAccessorColumn", c_void_p, DataAccessor)
DataAccessor._nextDataAccessorRow = genwrap("nextDataAccessorRow", None, DataAccessor, c_uint32, c_int)
DataAccessor._nextDataAccessorColumn = genwrap("nextDataAccessorColumn", None, DataAccessor, c_uint32)
DataAccessor._valid = genwrap("isDataAccessorValid", c_int, DataAccessor)
DataAccessor._rowsize = genwrap("getDataAccessorRowSize", c_uint32, DataAccessor)
DataAccessor._toPixel = genwrap("toDataAccessorPixel", None, DataAccessor, c_uint32, c_uint32)

class RasterElement(types.DataElement):
   "A raster element."
   _createDataPointer = genwrap("createDataPointer", c_void_p, types.DataElement, POINTER(types.DataPointerArgs), POINTER(c_int))
   _createDataAccessor = genwrap("createDataAccessor", DataAccessor, types.DataElement, POINTER(types.DataAccessorArgs))
   _updateRasterElement = genwrap("updateRasterElement", None, types.DataElement)
   _copyDataToRasterElement = genwrap("copyDataToRasterElement", c_int, types.DataElement, POINTER(types.DataPointerArgs), c_void_p)

   def __init__(self, name=None, args=None, rawData=None, element=None):
      """Get a raster element.
         If name is specified, get the named raster.
         If name and args are specified, create a new raster.
         If element is specified, use an existing DataElement.
         If rawData is not None, a new RasterElement will be created and rawData
         be copied to the new RasterElement using copyData() or copyArray(). args
         must be specified with rawData. Most of the args fields can be derived
         with RasterElementArgs.fromNumpyArray()."""
      assert(name is not None or element is not None)
      assert(not (name is not None and element is not None))
      if element is not None:
         self.handle = element.handle
      elif args is None and rawData is None:
         super(RasterElement, self).__init__(name)
      else:
         self.handle = genwrap("createRasterElement", types.DataElement, c_char_p, types.RasterElementArgs)(name, args).handle
         if rawData is not None:
            try:
               import numpy
               if isinstance(rawData, numpy.ndarray):
                  self.copyArray(rawData)
                  return
            except ImportError:
               pass
            self.copyData(rawData)

   def getDataAccessor(self, args = None):
      "Create a DataAccessor for this raster element."
      nfo = types.DataInfo(self)
      colCount = None
      assert(args is None or isinstance(args, types.DataAccessorArgs))
      if args is None:
         acc = self._createDataAccessor(self, None)
      else:
         acc = self._createDataAccessor(self, byref(args))
      acc._DataAccessor__owns, acc._DataAccessor__encoding = True, nfo.encodingType.toCtype()
      if args is None:
         colcount, writable = nfo.numColumns, False
      else:
         colcount, writable = args.columnEnd - args.columnStart + 1, args.writable
      acc.initialize(True, nfo.encodingType.toCtype(), colcount, writable)
      return acc

   def update(self):
      self._updateRasterElement(self)

   def getDataPointer(self, args=None):
      """Create a data pointer to an element with optional DataPointerArgs.
         Returns the ctypes data pointer and an ownership variable. If the second return
         value is True, the caller must call destroyDataPointer() with the first return
         value. When done with the data, the caller must delete the deleter object (with
         del or by removing that last reference) in order to clean up allocated memory.
         If the memory is shared, the second return value will be None."""
      own, deleter = c_int(0), None
      ptr = self._createDataPointer(self, args, byref(own))
      if own:
         class deleterobj(object):
            def __init__(self, p):
               self.__ptr = p
            def __del__(self):
               genwrap("destroyDataPointer", None, c_void_p, errorCheck=False)(self.__ptr)
         deleter = deleterobj(ptr)
      return ptr,deleter

   def getDataPointerArray(self, args=None):
      """Create a data pointer to an element with optional DataPointerArgs.
         Returns a numpy array and a deleter object. When done with the data, the
         caller must delete the deleter object (with del or by removing the last reference)
         in order to clean up allocated memory. If the memory is shared, the second return
         value will be None."""
      try:
         import numpy
         ptr,deleter = self.getDataPointer(args)
         nfo = types.DataInfo(self)
         rows,cols,bands = nfo.numRows, nfo.numColumns, nfo.numBands
         if args is not None:
            rows,cols,bands = (args.rowEnd - args.rowStart + 1), (args.columnEnd - args.columnStart + 1), (args.bandEnd - args.bandStart + 1)
         func = pythonapi.PyBuffer_FromMemory
         func.restype = py_object
         datalen = rows * cols * bands * nfo.encodingTypeSize
         buffer = func(ptr, datalen)
         ar = numpy.frombuffer(buffer, dtype=nfo.encodingType.toNumpyType())
         ar.shape = (rows, cols, bands)
         return ar,deleter
      except ImportError:
         # numpy wrapper will not be available
         raise NotImplementedError("numpy is not available")

   def copyData(self, data, args=None):
      """Copy data to a RasterElement with optional DataPointerArgs.
         Data must be a c_void_p. The caller should call update() when this is
         complete to redisplay the data."""
      self._copyDataToRasterElement(self, args, data)

   def copyArray(self, data, args=None):
      """Copy data to a RasterElement with optional DataPointerArgs.
         Data must be a numpy.ndarray. The caller should call update() when this
         is complete to redisplay the data.
         The array info will be checked against args or if args is None, it will
         be populated with appropriate info."""
      try:
         import numpy
         if not isinstance(data, numpy.ndarray):
            raise TypeError("Invalid data type, must be numpy.ndarray or ctypes.c_void_p")
         nfo = types.DataInfo(self)
         if args is None:
            args = types.DataPointerArgs()
            args.interleaveFormat = nfo.interleaveFormat
            if len(data.shape) == 2:
               args.rowEnd,args.columnEnd = map(lambda x: x - 1, data.shape)
               args.bandEnd = 0
            elif len(data.shape) == 3:
               if args.interleaveFormat.value == types.InterleaveFormat.BSQ:
                  args.bandEnd,args.rowEnd,args.columnEnd = map(lambda x: x - 1, data.shape)
               elif args.interleaveFormat.value == types.InterleaveFormat.BIL:
                  args.rowEnd,args.bandEnd,args.columnEnd = map(lambda x: x - 1, data.shape)
               elif args.interleaveFormat.value == types.InterleaveFormat.BIP:
                  args.rowEnd,args.columnEnd,args.bandEnd = map(lambda x: x - 1, data.shape)
            else:
               raise ValueError("Data must be 2 or 3 dimensional.")
         if args.rowEnd - args.rowStart + 1 > nfo.numRows:
            raise ValueError("Array has too many rows.")
         elif args.columnEnd - args.columnStart + 1 > nfo.numColumns:
            raise ValueError("Array has too many columns.")
         elif args.bandEnd - args.bandStart + 1 > nfo.numBands:
            raise ValueError("Array has too many bands.")
         if nfo.encodingType.toNumpyType() != str(data.dtype):
            raise ValueError("Array has wrong dtype.")

         if (args.rowEnd - args.rowStart + 1) == nfo.numRows and (args.columnEnd - args.columnStart + 1) == nfo.numColumns and (args.bandEnd - args.bandStart + 1) == nfo.numBands:
            args = None
         rawdata = data.ctypes.data_as(c_void_p)
         self.copyData(rawdata, args)
      except ImportError:
         # numpy wrapper will not be available
         raise NotImplementedError("numpy is not available")

####
# Test suite
####
import unittest
from ..utils import loadTestFile
class RasterTestCase(unittest.TestCase):
   def setUp(self):
      self.failUnless(loadTestFile("ir_bushehr_06jun02_ps.tif", True))
      self.re = RasterElement("ir_bushehr_06jun02_ps.tif")
      self.re2 = None

   def tearDown(self):
      self.re.destroy()
      self.re = None
      if self.re2 is not None:
         self.re2.destroy()
         self.re2 = None

   def testGetElement(self):
      self.failUnless(self.re)

   def testDataInfo(self):
      di = types.DataInfo(self.re)
      self.failUnlessEqual(di.numRows, 997)
      self.failUnlessEqual(di.numColumns, 1000)
      self.failUnlessEqual(di.numBands, 3)
      self.failUnlessEqual(di.interleaveFormat.value, types.InterleaveFormat.BIP)
      self.failUnlessEqual(di.encodingType.value, types.EncodingType.INT2UBYTES)
      self.failUnlessEqual(di.encodingTypeSize, 2)
      self.failUnlessEqual(di.badValues, [0])

   def testCreateRasterElement(self):
      args = types.RasterElementArgs()
      args.numRows = 10
      args.numColumns = 12
      args.numBands = 2
      args.interleaveFormat = types.InterleaveFormat.BSQ
      args.encodingType = types.EncodingType.INT1UBYTE
      args.location = types.ProcessingLocationPreference.RAM
      args.badValues = [100,101,102]
      self.re2 = RasterElement("Test element", args)
      self.failUnless(self.re2)
      self.re2.destroy()

   def testDataAccessor(self):
      acc = self.re.getDataAccessor()
      self.failUnless(acc is not None and acc.valid)
      # data is BIP, locations are row, col, band zero indexed
      self.failUnlessEqual(acc.getRow()[0], 1437) # 0, 0, 0
      self.failUnlessEqual(acc.getRow()[1], 1421) # 0, 0, 1
      self.failUnlessEqual(acc.getColumn()[0], 1437) # 0, 0, 0
      acc.nextColumn()
      self.failUnlessEqual(acc.getColumn()[0], 1590) # 0, 1, 0
      acc.nextRow()
      self.failUnlessEqual(acc.getRow()[0], 1558) # 1, 0, 0
      acc.toPixel(0, 0)
      self.failUnlessEqual(acc.getRow()[0], 1437) # 0, 0, 0

      self.failUnlessEqual(acc[2,4], 1365) # 4, 2, 0
      self.failUnlessEqual(acc[4,2], 1654) # 2, 4, 0

   def testDataAccessorArgs(self):
      args = types.DataAccessorArgs()
      args.rowStart,args.rowEnd = 10,11
      args.columnStart,args.columnEnd = 5,7
      args.bandStart, args.bandEnd = 1,1
      args.interleaveFormat = types.InterleaveFormat.BSQ
      acc = self.re.getDataAccessor(args)
      self.failUnless(acc is not None and acc.valid)
      self.failUnlessEqual(map(lambda ad: ad.contents.value, acc.iterrows()), [1622, 1590])
      acc.toPixel(10,5)
      self.failUnlessEqual(map(lambda ad: ad.contents.value, acc.itercolumns()), [1622,1662,1686])

   def testDataAccessorWrite(self):
      args = types.DataAccessorArgs()
      args.rowStart,args.rowEnd = 0,1
      args.columnStart,args.columnEnd = 0,1
      args.interleaveFormat = types.InterleaveFormat.BIP
      acc = self.re.getDataAccessor(args)
      self.failUnless(acc is not None and acc.valid)
      def doAssign(acc): acc[0,0] = 10
      self.failUnlessRaises(_opticks.error, doAssign, acc)

      args.writable = True
      acc = self.re.getDataAccessor(args)
      self.failUnless(acc is not None and acc.valid)
      self.failUnlessEqual(acc[0,0], 1437)
      acc[0,0] = 10
      self.re.update()
      self.failUnlessEqual(acc[0,0], 10)
