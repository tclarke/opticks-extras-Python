from ctypes import *
from .utils import genwrap, stringBufferWrap
import dynamictypes

__doc__ = "Functions to execute plug-ins and wizards."

####
# Data types
####
class PlugIn(Structure):
   _fields_ = [("handle", c_void_p)]
   __owns = False
   
   def __init__(self, name, batch=True):
      self.handle, self.__owns = createPlugIn(name, batch).handle, True

   def __del__(self):
      if self.__owns:
         freePlugIn(self)

   @property
   def inArgList(self):
      return getPlugInInputArgList(self)

   @property
   def outArgList(self):
      return getPlugInOutputArgList(self)

   def __call__(self):
      return bool(executePlugIn(self))

class Wizard(Structure):
   _fields_ = [("handle", c_void_p)]

   class WizardNodeList(object):
      def __init__(self, wizard, inputList):
         assert(wizard is not None)
         self.__wizard, self.__inputList = wizard, inputList
      
      def __len__(self):
         if self.__inputList:
            return getWizardInputNodeCount(self.__wizard)
         return getWizardOutputNodeCount(self.__wizard)

      def __getitem__(self, key):
         from types import IntType
         if type(key) == IntType:
            if self.__inputList:
               return getWizardInputNodeByIndex(self.__wizard, key)
            return getWizardOutputNodeByIndex(self.__wizard, key)
         if self.__inputList:
            return getWizardInputNodeByName(self.__wizard, str(key))
         return getWizardOutputNodeByName(self.__wizard, str(key))

      def iter(self):
         return self.iterkeys()

      def itervalues(self):
         def doiter(wizard, cnt, inputList):
            for idx in xrange(cnt):
               if inputList:
                  yield getWizardInputNodeByIndex(wizard, idx)
               else:
                  yield getWizardInputNodeByIndex(wizard, idx)
         return doiter(self.__wizard, len(self), self.__inputList)

      def iterkeys(self):
         def doiter(wizard, cnt, inputList):
            for idx in xrange(cnt):
               n = None
               if inputList:
                  n = getWizardInputNodeByIndex(wizard, idx)
               else:
                  n = getWizardInputNodeByIndex(wizard, idx)
               yield n.name
         return doiter(self.__wizard, len(self), self.__inputList)

   def __init__(self, filename):
      self.handle, self.__owns = loadWizard(filename).handle, True

   def __del__(self):
      if self.__owns:
         freeWizard(self)

   @property
   def input(self):
      return Wizard.WizardNodeList(self, True)

   @property
   def output(self):
      return Wizard.WizardNodeList(self, False)

   def __call__(self):
      return bool(executeWizard(self))

   @property
   def name(self):
      return stringBufferWrap(getWizardName, self)

####
# Function prototypes
####
createPlugIn = genwrap("createPlugIn", PlugIn, c_char_p, c_int)
freePlugIn = genwrap("freePlugIn", None, PlugIn, errorCheck=False)
getPlugInInputArgList = genwrap("getPlugInInputArgList", dynamictypes.PlugInArgList, PlugIn)
getPlugInOutputArgList = genwrap("getPlugInOutputArgList", dynamictypes.PlugInArgList, PlugIn)
executePlugIn = genwrap("executePlugIn", c_int, PlugIn)
loadWizard = genwrap("loadWizard", Wizard, c_char_p)
freeWizard = genwrap("freeWizard", None, Wizard, errorCheck=False)
getWizardName = genwrap("getWizardName", c_uint32, Wizard, c_char_p, c_uint32)
getWizardInputNodeCount = genwrap("getWizardInputNodeCount", c_uint32, Wizard)
getWizardOutputNodeCount = genwrap("getWizardOutputNodeCount", c_uint32, Wizard)
getWizardInputNodeByIndex = genwrap("getWizardInputNodeByIndex", dynamictypes.WizardNode, Wizard, c_uint32)
getWizardOutputNodeByIndex = genwrap("getWizardOutputNodeByIndex", dynamictypes.WizardNode, Wizard, c_uint32)
getWizardInputNodeByName = genwrap("getWizardInputNodeByName", dynamictypes.WizardNode, Wizard, c_char_p)
getWizardOutputNodeByName = genwrap("getWizardOutputNodeByName", dynamictypes.WizardNode, Wizard, c_char_p)
executeWizard = genwrap("executeWizard", c_int, Wizard)

####
# Test suite
####
import unittest
from .utils import loadTestFile
import data
class ExecuteTestCase(unittest.TestCase):
   def setUp(self):
      self.p = PlugIn("Passthrough PlugIn")

   def tearDown(self):
      del self.p

   def testPassthrough(self):
      self.failUnless(self.p())
      self.failUnlessEqual(self.p.inArgList[0].value, self.p.outArgList[0].value)

   def testPassthroughNonDefault(self):
      self.p.inArgList[0].actual = 42
      self.failUnless(self.p())
      self.failUnlessEqual(self.p.outArgList[0].actual, 42)

class PcaTestCase(unittest.TestCase):
   def setUp(self):
      self.p = PlugIn("Principal Component Analysis")
      self.failUnless(loadTestFile("ir_bushehr_06jun02_ps.tif", True))
      self.de = data.types.DataElement("ir_bushehr_06jun02_ps.tif")
      self.pde = None

   def tearDown(self):
      if self.de: self.de.destroy()
      if self.pde: self.pde.destroy()
      self.de, self.pde = None, None

   def testPca(self):
      self.p.inArgList['Data Element'].actual = self.de
      self.failUnless(self.p.inArgList['Data Element'].isActualSet())
      self.p.inArgList['Transform Type'].actual = "Correlation Coefficient"
      self.failUnless(self.p())
      self.failUnless(self.p.outArgList['Corrected Data Cube'].isActualSet())
      self.pde = data.types.DataElement(subtypeAsVoid=self.p.outArgList['Corrected Data Cube'].actual, typ="RasterElement")
