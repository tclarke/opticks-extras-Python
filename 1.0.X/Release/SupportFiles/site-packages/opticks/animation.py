from ctypes import *
from .utils import genwrap
from .view.layer import Layer

__doc__ = "Functions to work with Opticks animations."

####
# Data types
####
class AnimationState(c_uint32):
   "Opticks AnimationState type."
   STOP = 0
   PLAY_FORWARD = 1
   PLAY_BACKWARD = 2
   PAUSE_FORWARD = 3
   PAUSE_BACKWARD = 4

   def __repr__(self):
      if self.value == self.STOP: return "<AnimationState: stopped>"
      elif self.value == self.PLAY_FORWARD: return "<AnimationState: playing forward>"
      elif self.value == self.PLAY_BACKWARD: return "<AnimationState: playing backward>"
      elif self.value == self.PAUSE_FORWARD: return "<AnimationState: paused, will resume forward>"
      elif self.value == self.PAUSE_BACKWARD: return "<AnimationState: paused, will resume backward>"
      return "<AnimationState: unknown value>"

class AnimationCycle(c_uint32):
   "Opticks AnimationCycle type."
   PLAY_ONCE = 0
   REPEAT = 1
   BOUNCE = 2

   def __repr__(self):
      if self.value == self.PLAY_ONCE: return "<AnimationCycle: play once>"
      elif self.value == self.REPEAT: return "<AnimationCycle: repeat>"
      elif self.value == self.BOUNCE: return "<AnimationCycle: bounce>"
      return "<AnimationCycle: unknown value>"

animation_callback_t = CFUNCTYPE(None, c_char_p, c_char_p, c_uint32, c_double, c_void_p)

class Animation(Structure):
   _fields_ = [("handle", c_void_p)]
   __owns = False

   def __init__(self, name=None, create=False, timeBased=True):
      """Get an animation by name. If name is none, get the active animation
         If create is True and the animation
         does not exist, it will be created. If created, timeBased will
         determine if the animation is time based of frame based."""
      self.__owns = False
      try:
         self.handle = genwrap("getAnimationController", Animation, c_char_p)(name).handle
      except errors.SimpleApiError, e:
         if not create:
            raise
         self.handle = genwrap("createAnimationController", Animation, c_char_p, c_int)(name, timeBased).handle

   def __del__(self):
      if self.__owns:
         self._destroyAnimationController(self)

   def destroy(self, val=True):
      """Mark this animation for destruction. When the animation object is garbage
         collected it will be destroyed. If val is False, destruction will be cancelled."""
      self.__owns = val

   def getstate(self):
      return self._getAnimationControllerState(self)
   def setstate(self, value):
      if not isinstance(value, AnimationState):
         value = AnimationState(value)
      self._setAnimationControllerState(self, value)
   state = property(getstate, setstate, doc="Playback state of the animation.")

   def getcycle(self):
      return self._getAnimationControllerCycle(self)
   def setcycle(self, value):
      if not isinstance(value, AnimationCycle):
         value = AnimationCycle(value)
      self._setAnimationControllerCycle(self, value)
   cycle = property(getcycle, setcycle, doc="Cycle mode of the animation.")

   def getcandropframes(self):
      return bool(self._canAnimationControllerDropFrames(self))
   def setcandropframes(self, value):
      self._setAnimationControllerCanDropFrames(self, value)
   candropframes = property(getcandropframes, setcandropframes, doc="""Allow the controller to drop
frames if necessary to maintain the frame rate.""")

   def getintervalmultiplier(self):
      return self._getAnimationControllerIntervalMultiplier(self)
   def setintervalmultiplier(self, value):
      self._setAnimationControllerIntervalMultiplier(self, value)
   intervalmultiplier = property(getintervalmultiplier, setintervalmultiplier, doc="Adjust the speed of playback.")

   def activate(self):
      "Make this animation active in the animation toolbar."
      self._activateAnimationController(self)

   def attach(self, raster):
      "Attach a raster element to an animation. Raster must be a raster layer."
      self._attachRasterLayerToAnimationController(self, raster)

   def callback(self, name, callbackFunc, frameCount, frameTimes=None, userData=None):
      """Attach a callbackFunc to an animation.
         If callbackFunc is a Python callable, it will be wrapped with animation_callback_t.
         name is the name for the new attachment.
         frameCount is the number of frames. Each time a frame is `displayed' callbackFunc
         will be executed.
         If the animation is time based, frameTimes can be a list of real values indicating
         playback times. The list must be of length equal to frameCount. If frameTimes is None,
         times will be generated for 1fps playback.
         userData will be passed as is to the callback function."""
      typ = (c_double * frameCount)
      if frameTimes is not None and not isinstance(frameTimes, typ):
         if len(frameTimes) != frameCount:
            raise TypeError("`frameTimes' must be None or a list of length %i" % frameCount)
         tmp = typ()
         for idx in xrange(frameCount):
            tmp[idx] = frameTimes[idx]
         frameTimes = tmp
      if not isinstance(callbackFunc, animation_callback_t):
         callbackFunc = animation_callback_t(callbackFunc)
      hndl = c_void_p(self._attachCallbackToAnimationController(self, name, callbackFunc, userData, frameCount, frameTimes))
      class deleterobj(object):
         def __init__(self, cntrl, name, hndl, cbFunc):
            self.__cntrl, self.__name, self.__hndl, self.__cbFunc = cntrl, name, hndl, cbFunc
         def __del__(self):
            w = genwrap("destroyAnimationControllerAttachment", None, Animation, c_char_p, c_void_p, errorCheck=False)
            w(self.__cntrl, self.__name, self.__hndl)
            del self.__cbFunc
      return deleterobj(self, name, hndl, callbackFunc)

   def play(self):
      self._playAnimationController(self)

   def pause(self):
      self._pauseAnimationController(self)

   def stop(self):
      self._stopAnimationController(self)

Animation._destroyAnimationController = genwrap("destroyAnimationController", None, Animation, errorCheck=False)
Animation._activateAnimationController = genwrap("activateAnimationController", c_int, Animation)
Animation._getAnimationControllerState = genwrap("getAnimationControllerState", AnimationState, Animation)
Animation._setAnimationControllerState = genwrap("setAnimationControllerState", c_int, Animation, AnimationState)
Animation._playAnimationController = genwrap("playAnimationController", c_int, Animation)
Animation._pauseAnimationController = genwrap("pauseAnimationController", c_int, Animation)
Animation._stopAnimationController = genwrap("stopAnimationController", c_int, Animation)
Animation._getAnimationControllerCycle = genwrap("getAnimationControllerCycle", AnimationCycle, Animation)
Animation._setAnimationControllerCycle = genwrap("setAnimationControllerCycle", c_int, Animation, AnimationCycle)
Animation._canAnimationControllerDropFrames = genwrap("canAnimationControllerDropFrames", c_int, Animation)
Animation._setAnimationControllerCanDropFrames = genwrap("setAnimationControllerCanDropFrames", c_int, Animation, c_int)
Animation._getAnimationControllerIntervalMultiplier = genwrap("getAnimationControllerIntervalMultiplier", c_double, Animation)
Animation._setAnimationControllerIntervalMultiplier = genwrap("setAnimationControllerIntervalMultiplier", c_int, Animation, c_double)
Animation._attachRasterLayerToAnimationController = genwrap("attachRasterLayerToAnimationController", c_int, Animation, Layer)
Animation._attachCallbackToAnimationController = genwrap("attachCallbackToAnimationController", c_void_p, Animation, c_char_p, animation_callback_t, c_void_p, c_uint32, POINTER(c_double))

####
# Test suite
####
import unittest
from .utils import loadTestFile
from . import errors
from .view import view
class AnimationTestCase(unittest.TestCase):
   def setUp(self):
      self.failUnless(loadTestFile("ir_bushehr_06jun02_ps.tif"))
      self.v = view.View()

   def tearDown(self):
      self.v.destroy()
      self.v = None

   def testAnimationGet(self):
      pass

class AnimationCallbackTestCase(unittest.TestCase):
   def setUp(self):
      self.anim = Animation('foo',create=True)
      self.deleter = None

   def tearDown(self):
      self.anim.destroy()
      self.anim = None
      self.deleter = None

   def testCallbackDeletion(self):
      self.anim.activate()
      def cb(*args): pass
      self.deleter = self.anim.callback('bar',cb,3)
