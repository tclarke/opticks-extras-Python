from ctypes import *
from ..utils import genwrap, stringBufferWrap

__doc__ = "Basic types used by opticks.data including enums, integral types, and argument structures."

class c_intcomplex32(Structure):
   "Integer complex with 16-bit real and 16-bit imaginary elements."
   _fields_ = [("real", c_int16), ("imag", c_int16)]

class c_floatcomplex64(Structure):
   "Floating point complex with 32-bit real and 32-bit imaginary elements."
   _fields_ = [("real", c_float), ("imag", c_float)]

class EncodingType(c_uint32):
   "Opticks data encoding type."
   INT1SBYTE = 0
   INT1UBYTE = 1
   INT2SBYTES = 2
   INT2UBYTES = 3
   INT4SCOMPLEX = 4
   INT4SBYTES = 5
   INT4UBYTES = 6
   FLT4BYTES = 7
   FLT8COMPLEX = 8
   FLT8BYTES = 9

   def __repr__(self):
      if self.value == self.INT1SBYTE: strname = "INT1SBYTE"
      elif self.value == self.INT1UBYTE: strname = "INT1UBYTE"
      elif self.value == self.INT2SBYTES: strname = "INT2SBYTES"
      elif self.value == self.INT2UBYTES: strname = "INT2UBYTES"
      elif self.value == self.INT4SBYTES: strname = "INT4SBYTES"
      elif self.value == self.INT4UBYTES: strname = "INT4UBYTES"
      elif self.value == self.INT4SCOMPLEX: strname = "INT4SCOMPLEX"
      elif self.value == self.FLT4BYTES: strname = "FLT4BYTES"
      elif self.value == self.FLT8BYTES: strname = "FLT8BYTES"
      elif self.value == self.FLT8COMPLEX: strname = "FLT8COMPLEX"
      else: strname = "Unknown"
      return "<EncodingType: %s>" % strname

   def toCtype(self):
      "Return an appropriate ctypes data type for this encoding type."
      if self.value == self.INT1SBYTE: return POINTER(c_int8)
      elif self.value == self.INT1UBYTE: return POINTER(c_uint8)
      elif self.value == self.INT2SBYTES: return POINTER(c_int16)
      elif self.value == self.INT2UBYTES: return POINTER(c_uint16)
      elif self.value == self.INT4SBYTES: return POINTER(c_int32)
      elif self.value == self.INT4UBYTES: return POINTER(c_uint32)
      elif self.value == self.INT4SCOMPLEX: return POINTER(c_intcomplex32)
      elif self.value == self.FLT4BYTES: return POINTER(c_float)
      elif self.value == self.FLT8BYTES: return POINTER(c_double)
      elif self.value == self.FLT8COMPLEX: return POINTER(c_floatcomplex64)
      else: return c_void_p

   def toNumpyType(self):
      "Return an appropriate numpy dtype for this encoding type."
      if self.value == self.INT1SBYTE: return "int8"
      elif self.value == self.INT1UBYTE: return "uint8"
      elif self.value == self.INT2SBYTES: return "int16"
      elif self.value == self.INT2UBYTES: return "uint16"
      elif self.value == self.INT4SBYTES: return "int32"
      elif self.value == self.INT4UBYTES: return "uint32"
      elif self.value == self.INT4SCOMPLEX: return "i2i2"
      elif self.value == self.FLT4BYTES: return "float32"
      elif self.value == self.FLT8BYTES: return "float64"
      elif self.value == self.FLT8COMPLEX: return "complex64"
      else: return "void"

   def fromNumpyType(self, typestr):
      "Return an appropriate numpy dtype for this encoding type."
      if typestr == "int8": return self.INT1SBYTE
      elif typestr == "uint8": return self.INT1UBYTE
      elif typestr == "int16": return self.INT2SBYTES
      elif typestr == "uint16": return self.INT2UBYTES
      elif typestr == "int32": return self.INT4SBYTES
      elif typestr == "uint32": return self.INT4UBYTES
      elif typestr == "float32": return self.FLT4BYTES
      elif typestr == "float64": return self.FLT8BYTES
      elif typestr == "complex64": return self.FLT8COMPLEX
      else: raise TypeError("'%s' can't be represented in Opticks." % typstr)

class InterleaveFormat(c_uint32):
   "Opticks data interleave format."
   BSQ = 0
   BIP = 1
   BIL = 2

   def __repr__(self):
      if self.value == self.BSQ: return "<InterleaveFormat: BSQ>"
      elif self.value == self.BIP: return "<InterleaveFormat: BIP>"
      elif self.value == self.BIL: return "<InterleaveFormat: BIL>"
      return "<InterleaveFormat: Unknown"

class ProcessingLocationPreference(c_uint32):
   "Processing location hint for creation of raster elements."
   PREFER_RAM = 0
   RAM = 1
   ONDISK = 2

   def __repr__(self):
      if self.value == self.ONDISK: return "<ProcessingLocationPreference: on-disk only>"
      elif self.value == self.RAM: return "<ProcessingLocationPreference: in memory only>"
      elif self.value == self.PREFER_RAM: return "<ProcessingLocationPreference: prefer in memory>"
      return "<InterleaveFormat: Unknown"

class DataElement(Structure, object):
   "An Opticks data element handle."
   _fields_ = [("handle", c_void_p)]
   __owns = False

   def __init__(self, name=None, create=False, subtypeAsVoid=None, typ=None):
      """Get a DataElement.
         If name is passed, the DataElement with that name is accessed.
         If subtypeAsVoid and typ are passed, the subtype specificed in typ is dynamic_cast to
         a DataElement.
         If create is True and typ is specified, an attempt is made to create the element if it does not exist."""
      assert((name is not None and subtypeAsVoid is None) or (name is None and subtypeAsVoid is not None))
      if name is not None:
         self.handle = genwrap("getDataElement", DataElement, c_char_p, c_char_p, c_int)(name, typ, int(create)).handle
      else:
         self.handle = genwrap("castToDataElement", DataElement, c_void_p, c_char_p)(subtypeAsVoid, typ).handle
      self.__owns = False

   def __del__(self):
      if self.__owns:
         genwrap("destroyDataElement", None, DataElement, errorCheck=False)(self)

   def destroy(self, val=True):
      self.__owns = val

   @property
   def name(self):
      return stringBufferWrap(self._getDataElementName, self)

   @property
   def type(self):
      return stringBufferWrap(self._getDataElementType, self)

   @property
   def filename(self):
      return stringBufferWrap(self._getDataElementFilename, self)

   @property
   def metadata(self):
      from ..metadata import DynamicObject
      return DynamicObject(self)

   @property
   def children(self):
      class ChildList(object):
         def __init__(self, element):
            self.element = element

         def __len__(self):
            return self.element._getDataElementChildCount(self.element)

         def __getitem__(self, index):
            if index >= len(self):
               raise IndexError
            return self.element._getDataElementChild(self.element, index)
      return ChildList(self)

   def castDataElement(self, typ):
      return self._castDataElement(self, typ)

DataElement._castDataElement = genwrap("castDataElement", c_void_p, DataElement, c_char_p)
DataElement._getDataElementName = genwrap("getDataElementName", c_uint32, DataElement, c_char_p, c_uint32)
DataElement._getDataElementType = genwrap("getDataElementType", c_uint32, DataElement, c_char_p, c_uint32)
DataElement._getDataElementFilename = genwrap("getDataElementFilename", c_uint32, DataElement, c_char_p, c_uint32)
DataElement._getDataElementChildCount = genwrap("getDataElementChildCount", c_uint32, DataElement)
DataElement._getDataElementChild = genwrap("getDataElementChild", DataElement, DataElement, c_uint32)

class DataInfo(Structure):
   "Information about a raster element."
   _fields_ = [("numRows", c_uint32),
               ("numColumns", c_uint32),
               ("numBands", c_uint32),
               ("interleaveFormat", InterleaveFormat),
               ("encodingType", EncodingType),
               ("encodingTypeSize", c_uint32),
               ("numBadValues", c_uint32),
               ("pBadValues", POINTER(c_int32))]

   def __init__(self, *args):
      pass # don't call the base class __init__

   def __new__(cls, dataElement=None):
      createDataInfo = genwrap("createDataInfo", POINTER(DataInfo), DataElement)
      rval = createDataInfo(dataElement).contents
      if rval:
         rval.__coreOwns = True
      return rval

   def __del__(self):
      if self.__coreOwns:
         genwrap("destroyDataInfo", None, POINTER(DataInfo), errorCheck=False)(self)

   def __repr__(self):
      return "<DataInfo: %i,%i,%i %s %s>" % (self.numRows,self.numColumns,self.numBands,self.interleaveFormat,self.encodingType)

   def getBadValues(self):
      rval = []
      for idx in range(self.numBadValues):
         rval.append(self.pBadValues[idx])
      return rval

   def setBadValues(self, val):
      assert(isinstance(val, list))
      self.numBadValues = len(val)
      self.pBadValues = cast(POINTER(c_int32), (c_int32 * self.numBadValues))
      for idx in range(self.numBadValues):
         self.pBadValues[idx] = c_int32(val[idx])

   badValues = property(getBadValues, setBadValues)

class RasterElementArgs(Structure):
   "Argument structure for creation of a new raster element."
   _fields_ = [("numRows", c_uint32),
               ("numColumns", c_uint32),
               ("numBands", c_uint32),
               ("interleaveFormat", InterleaveFormat),
               ("encodingType", EncodingType),
               ("location", ProcessingLocationPreference),
               ("parent", DataElement),
               ("numBadValues", c_uint32),
               ("pBadValues", POINTER(c_int32))]

   def __repr__(self):
      return "<RasterElementArgs: %i,%i,%i %s %s %s>" % (self.numRows,self.numColumns,self.numBands,self.interleaveFormat,self.encodingType,self.location)

   def fromNumpyArray(self, ar):
      """This will fill in details from a numpy array. Before calling this function
         you must set 'interleaveFormat' appropriately."""
      try:
         import numpy
         if len(ar.shape) == 3:
            if self.interleaveFormat.value == InterleaveFormat.BSQ:
               self.numBands, self.numRows, self.numColumns = ar.shape
            elif self.interleaveFormat.value == InterleaveFormat.BIL:
               self.numRows, self.numBands, self.numColumns = ar.shape
            elif self.interleaveFormat.value == InterleaveFormat.BIP:
               self.numRows, self.numColumns, self.numBands = ar.shape
         elif len(ar.shape) == 2:
            self.numBands = 1
            self.numRows, self.numColumns = ar.shape
         else:
            raise ValueError("Array must be 2-d or 3-d")
         self.encodingType = self.encodingType.fromNumpyType(ar.dtype.name)
      except ImportError:
         # numpy not available
         raise NotImplementedError("numpy is not available")

   def getBadValues(self):
      rval = []
      for idx in range(self.numBadValues):
         rval.append(self.pBadValues[idx])
      return rval

   def setBadValues(self, val):
      assert(isinstance(val, list))
      self.numBadValues = len(val)
      self.pBadValues = cast((c_int32 * self.numBadValues)(), POINTER(c_int32))
      for idx in range(self.numBadValues):
         self.pBadValues[idx] = c_int32(val[idx])

   badValues = property(getBadValues, setBadValues)

class DataPointerArgs(Structure):
   "Argument structure for creation of a new data pointer."
   _fields_ = [("rowStart", c_uint32),
               ("rowEnd", c_uint32),
               ("columnStart", c_uint32),
               ("columnEnd", c_uint32),
               ("bandStart", c_uint32),
               ("bandEnd", c_uint32),
               ("interleaveFormat", InterleaveFormat)]

   def __repr__(self):
      return "<DataPointerArgs: %i-%i, %i-%i, %i-%i, %s>" % (self.rowStart,self.rowEnd,self.columnStart,self.columnEnd,self.bandStart,self.bandEnd,self.interleaveFormat)

class DataAccessorArgs(Structure):
   "Argument structure for creation of a new data accessor."
   _fields_ = [("rowStart", c_uint32),
               ("rowEnd", c_uint32),
               ("concurrentRows", c_uint32),
               ("columnStart", c_uint32),
               ("columnEnd", c_uint32),
               ("concurrentColumns", c_uint32),
               ("bandStart", c_uint32),
               ("bandEnd", c_uint32),
               ("concurrentBands", c_uint32),
               ("interleaveFormat", InterleaveFormat),
               ("writable", c_uint32)]

   def __repr__(self):
      return "<DataAccessorArgs: %i-%i, %i-%i, %i-%i, %s>" % (self.rowStart,self.rowEnd,self.columnStart,self.columnEnd,self.bandStart,self.bandEnd,self.interleaveFormat)

####
# Test suite
####
import unittest
from ..utils import loadTestFile
class TypesTestCase(unittest.TestCase):
   def setUp(self):
      self.failUnless(loadTestFile("ir_bushehr_06jun02_ps.tif"))
      self.de = DataElement("ir_bushehr_06jun02_ps.tif")

   def tearDown(self):
      self.de.destroy()
      self.de = None

   def testGetElement(self):
      self.failUnless(self.de)

   def testCastElement(self):
      self.failUnless(self.de.castDataElement("RasterElement"))

   def testProperties(self):
      import os.path
      self.failUnless(self.de.name.endswith("ir_bushehr_06jun02_ps.tif"))
      self.failUnlessEqual(self.de.type, "RasterElement")
      self.failUnlessEqual(os.path.basename(self.de.filename), "ir_bushehr_06jun02_ps.tif")
      self.failUnlessEqual(len(self.de.children), 1)
      self.failUnlessEqual(self.de.children[0].name, "Corner Coordinates")
      self.failUnlessEqual(self.de.children[0].type, "GcpList")
